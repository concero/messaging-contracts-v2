var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// ../../../node_modules/abitype/dist/esm/version.js
var version = "1.0.8";

// ../../../node_modules/abitype/dist/esm/errors.js
var BaseError;
var init_errors = __esm(() => {
  BaseError = class BaseError extends Error {
    constructor(shortMessage, args = {}) {
      const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
      const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: abitype@${version}`
      ].join(`
`);
      super(message);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AbiTypeError"
      });
      if (args.cause)
        this.cause = args.cause;
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.shortMessage = shortMessage;
    }
  };
});

// ../../../node_modules/abitype/dist/esm/regex.js
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match?.groups;
}
var bytesRegex, integerRegex, isTupleRegex;
var init_regex = __esm(() => {
  bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  isTupleRegex = /^\(.+?\).*?$/;
});

// ../../../node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length = abiParameter.components.length;
    for (let i = 0;i < length; i++) {
      const component = abiParameter.components[i];
      type += formatAbiParameter(component);
      if (i < length - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
var tupleRegex;
var init_formatAbiParameter = __esm(() => {
  init_regex();
  tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
});

// ../../../node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
function formatAbiParameters(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i = 0;i < length; i++) {
    const abiParameter = abiParameters[i];
    params += formatAbiParameter(abiParameter);
    if (i !== length - 1)
      params += ", ";
  }
  return params;
}
var init_formatAbiParameters = __esm(() => {
  init_formatAbiParameter();
});

// ../../../node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  if (abiItem.type === "fallback")
    return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  return "receive() external payable";
}
var init_formatAbiItem = __esm(() => {
  init_formatAbiParameters();
});

// ../../../node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
function isErrorSignature(signature) {
  return errorSignatureRegex.test(signature);
}
function execErrorSignature(signature) {
  return execTyped(errorSignatureRegex, signature);
}
function isEventSignature(signature) {
  return eventSignatureRegex.test(signature);
}
function execEventSignature(signature) {
  return execTyped(eventSignatureRegex, signature);
}
function isFunctionSignature(signature) {
  return functionSignatureRegex.test(signature);
}
function execFunctionSignature(signature) {
  return execTyped(functionSignatureRegex, signature);
}
function isStructSignature(signature) {
  return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
  return execTyped(structSignatureRegex, signature);
}
function isConstructorSignature(signature) {
  return constructorSignatureRegex.test(signature);
}
function execConstructorSignature(signature) {
  return execTyped(constructorSignatureRegex, signature);
}
function isFallbackSignature(signature) {
  return fallbackSignatureRegex.test(signature);
}
function execFallbackSignature(signature) {
  return execTyped(fallbackSignatureRegex, signature);
}
function isReceiveSignature(signature) {
  return receiveSignatureRegex.test(signature);
}
var errorSignatureRegex, eventSignatureRegex, functionSignatureRegex, structSignatureRegex, constructorSignatureRegex, fallbackSignatureRegex, receiveSignatureRegex, modifiers, eventModifiers, functionModifiers;
var init_signatures = __esm(() => {
  init_regex();
  errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
  eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
  functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
  structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
  constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
  fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
  receiveSignatureRegex = /^receive\(\) external payable$/;
  modifiers = new Set([
    "memory",
    "indexed",
    "storage",
    "calldata"
  ]);
  eventModifiers = new Set(["indexed"]);
  functionModifiers = new Set([
    "calldata",
    "memory",
    "storage"
  ]);
});

// ../../../node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
var InvalidAbiItemError, UnknownTypeError, UnknownSolidityTypeError;
var init_abiItem = __esm(() => {
  init_errors();
  InvalidAbiItemError = class InvalidAbiItemError extends BaseError {
    constructor({ signature }) {
      super("Failed to parse ABI item.", {
        details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
        docsPath: "/api/human#parseabiitem-1"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiItemError"
      });
    }
  };
  UnknownTypeError = class UnknownTypeError extends BaseError {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [
          `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownTypeError"
      });
    }
  };
  UnknownSolidityTypeError = class UnknownSolidityTypeError extends BaseError {
    constructor({ type }) {
      super("Unknown type.", {
        metaMessages: [`Type "${type}" is not a valid ABI type.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSolidityTypeError"
      });
    }
  };
});

// ../../../node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
var InvalidParameterError, SolidityProtectedKeywordError, InvalidModifierError, InvalidFunctionModifierError, InvalidAbiTypeParameterError;
var init_abiParameter = __esm(() => {
  init_errors();
  InvalidParameterError = class InvalidParameterError extends BaseError {
    constructor({ param }) {
      super("Invalid ABI parameter.", {
        details: param
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParameterError"
      });
    }
  };
  SolidityProtectedKeywordError = class SolidityProtectedKeywordError extends BaseError {
    constructor({ param, name }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "SolidityProtectedKeywordError"
      });
    }
  };
  InvalidModifierError = class InvalidModifierError extends BaseError {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidModifierError"
      });
    }
  };
  InvalidFunctionModifierError = class InvalidFunctionModifierError extends BaseError {
    constructor({ param, type, modifier }) {
      super("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
          `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidFunctionModifierError"
      });
    }
  };
  InvalidAbiTypeParameterError = class InvalidAbiTypeParameterError extends BaseError {
    constructor({ abiParameter }) {
      super("Invalid ABI parameter.", {
        details: JSON.stringify(abiParameter, null, 2),
        metaMessages: ["ABI parameter type is invalid."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidAbiTypeParameterError"
      });
    }
  };
});

// ../../../node_modules/abitype/dist/esm/human-readable/errors/signature.js
var InvalidSignatureError, UnknownSignatureError, InvalidStructSignatureError;
var init_signature = __esm(() => {
  init_errors();
  InvalidSignatureError = class InvalidSignatureError extends BaseError {
    constructor({ signature, type }) {
      super(`Invalid ${type} signature.`, {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidSignatureError"
      });
    }
  };
  UnknownSignatureError = class UnknownSignatureError extends BaseError {
    constructor({ signature }) {
      super("Unknown signature.", {
        details: signature
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "UnknownSignatureError"
      });
    }
  };
  InvalidStructSignatureError = class InvalidStructSignatureError extends BaseError {
    constructor({ signature }) {
      super("Invalid struct signature.", {
        details: signature,
        metaMessages: ["No properties exist."]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidStructSignatureError"
      });
    }
  };
});

// ../../../node_modules/abitype/dist/esm/human-readable/errors/struct.js
var CircularReferenceError;
var init_struct = __esm(() => {
  init_errors();
  CircularReferenceError = class CircularReferenceError extends BaseError {
    constructor({ type }) {
      super("Circular reference detected.", {
        metaMessages: [`Struct "${type}" is a circular reference.`]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "CircularReferenceError"
      });
    }
  };
});

// ../../../node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
var InvalidParenthesisError;
var init_splitParameters = __esm(() => {
  init_errors();
  InvalidParenthesisError = class InvalidParenthesisError extends BaseError {
    constructor({ current, depth }) {
      super("Unbalanced parentheses.", {
        metaMessages: [
          `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
        ],
        details: `Depth "${depth}"`
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "InvalidParenthesisError"
      });
    }
  };
});

// ../../../node_modules/abitype/dist/esm/human-readable/runtime/cache.js
function getParameterCacheKey(param, type, structs) {
  let structKey = "";
  if (structs)
    for (const struct of Object.entries(structs)) {
      if (!struct)
        continue;
      let propertyKey = "";
      for (const property of struct[1]) {
        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ""}]`;
      }
      structKey += `(${struct[0]}{${propertyKey}})`;
    }
  if (type)
    return `${type}:${param}${structKey}`;
  return param;
}
var parameterCache;
var init_cache = __esm(() => {
  parameterCache = new Map([
    ["address", { type: "address" }],
    ["bool", { type: "bool" }],
    ["bytes", { type: "bytes" }],
    ["bytes32", { type: "bytes32" }],
    ["int", { type: "int256" }],
    ["int256", { type: "int256" }],
    ["string", { type: "string" }],
    ["uint", { type: "uint256" }],
    ["uint8", { type: "uint8" }],
    ["uint16", { type: "uint16" }],
    ["uint24", { type: "uint24" }],
    ["uint32", { type: "uint32" }],
    ["uint64", { type: "uint64" }],
    ["uint96", { type: "uint96" }],
    ["uint112", { type: "uint112" }],
    ["uint160", { type: "uint160" }],
    ["uint192", { type: "uint192" }],
    ["uint256", { type: "uint256" }],
    ["address owner", { type: "address", name: "owner" }],
    ["address to", { type: "address", name: "to" }],
    ["bool approved", { type: "bool", name: "approved" }],
    ["bytes _data", { type: "bytes", name: "_data" }],
    ["bytes data", { type: "bytes", name: "data" }],
    ["bytes signature", { type: "bytes", name: "signature" }],
    ["bytes32 hash", { type: "bytes32", name: "hash" }],
    ["bytes32 r", { type: "bytes32", name: "r" }],
    ["bytes32 root", { type: "bytes32", name: "root" }],
    ["bytes32 s", { type: "bytes32", name: "s" }],
    ["string name", { type: "string", name: "name" }],
    ["string symbol", { type: "string", name: "symbol" }],
    ["string tokenURI", { type: "string", name: "tokenURI" }],
    ["uint tokenId", { type: "uint256", name: "tokenId" }],
    ["uint8 v", { type: "uint8", name: "v" }],
    ["uint256 balance", { type: "uint256", name: "balance" }],
    ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
    ["uint256 value", { type: "uint256", name: "value" }],
    [
      "event:address indexed from",
      { type: "address", name: "from", indexed: true }
    ],
    ["event:address indexed to", { type: "address", name: "to", indexed: true }],
    [
      "event:uint indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ],
    [
      "event:uint256 indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ]
  ]);
});

// ../../../node_modules/abitype/dist/esm/human-readable/runtime/utils.js
function parseSignature(signature, structs = {}) {
  if (isFunctionSignature(signature))
    return parseFunctionSignature(signature, structs);
  if (isEventSignature(signature))
    return parseEventSignature(signature, structs);
  if (isErrorSignature(signature))
    return parseErrorSignature(signature, structs);
  if (isConstructorSignature(signature))
    return parseConstructorSignature(signature, structs);
  if (isFallbackSignature(signature))
    return parseFallbackSignature(signature);
  if (isReceiveSignature(signature))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature });
}
function parseFunctionSignature(signature, structs = {}) {
  const match = execFunctionSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "function" });
  const inputParams = splitParameters(match.parameters);
  const inputs = [];
  const inputLength = inputParams.length;
  for (let i = 0;i < inputLength; i++) {
    inputs.push(parseAbiParameter(inputParams[i], {
      modifiers: functionModifiers,
      structs,
      type: "function"
    }));
  }
  const outputs = [];
  if (match.returns) {
    const outputParams = splitParameters(match.returns);
    const outputLength = outputParams.length;
    for (let i = 0;i < outputLength; i++) {
      outputs.push(parseAbiParameter(outputParams[i], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
  }
  return {
    name: match.name,
    type: "function",
    stateMutability: match.stateMutability ?? "nonpayable",
    inputs,
    outputs
  };
}
function parseEventSignature(signature, structs = {}) {
  const match = execEventSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "event" });
  const params = splitParameters(match.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i = 0;i < length; i++)
    abiParameters.push(parseAbiParameter(params[i], {
      modifiers: eventModifiers,
      structs,
      type: "event"
    }));
  return { name: match.name, type: "event", inputs: abiParameters };
}
function parseErrorSignature(signature, structs = {}) {
  const match = execErrorSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "error" });
  const params = splitParameters(match.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i = 0;i < length; i++)
    abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
  return { name: match.name, type: "error", inputs: abiParameters };
}
function parseConstructorSignature(signature, structs = {}) {
  const match = execConstructorSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "constructor" });
  const params = splitParameters(match.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i = 0;i < length; i++)
    abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: match.stateMutability ?? "nonpayable",
    inputs: abiParameters
  };
}
function parseFallbackSignature(signature) {
  const match = execFallbackSignature(signature);
  if (!match)
    throw new InvalidSignatureError({ signature, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: match.stateMutability ?? "nonpayable"
  };
}
function parseAbiParameter(param, options) {
  const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(param);
  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
  if (!match)
    throw new InvalidParameterError({ param });
  if (match.name && isSolidityKeyword(match.name))
    throw new SolidityProtectedKeywordError({ param, name: match.name });
  const name = match.name ? { name: match.name } : {};
  const indexed = match.modifier === "indexed" ? { indexed: true } : {};
  const structs = options?.structs ?? {};
  let type;
  let components = {};
  if (isTuple) {
    type = "tuple";
    const params = splitParameters(match.type);
    const components_ = [];
    const length = params.length;
    for (let i = 0;i < length; i++) {
      components_.push(parseAbiParameter(params[i], { structs }));
    }
    components = { components: components_ };
  } else if (match.type in structs) {
    type = "tuple";
    components = { components: structs[match.type] };
  } else if (dynamicIntegerRegex.test(match.type)) {
    type = `${match.type}256`;
  } else {
    type = match.type;
    if (!(options?.type === "struct") && !isSolidityType(type))
      throw new UnknownSolidityTypeError({ type });
  }
  if (match.modifier) {
    if (!options?.modifiers?.has?.(match.modifier))
      throw new InvalidModifierError({
        param,
        type: options?.type,
        modifier: match.modifier
      });
    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
      throw new InvalidFunctionModifierError({
        param,
        type: options?.type,
        modifier: match.modifier
      });
  }
  const abiParameter = {
    type: `${type}${match.array ?? ""}`,
    ...name,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
function splitParameters(params, result = [], current = "", depth = 0) {
  const length = params.trim().length;
  for (let i = 0;i < length; i++) {
    const char = params[i];
    const tail = params.slice(i + 1);
    switch (char) {
      case ",":
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
      case "(":
        return splitParameters(tail, result, `${current}${char}`, depth + 1);
      case ")":
        return splitParameters(tail, result, `${current}${char}`, depth - 1);
      default:
        return splitParameters(tail, result, `${current}${char}`, depth);
    }
  }
  if (current === "")
    return result;
  if (depth !== 0)
    throw new InvalidParenthesisError({ current, depth });
  result.push(current.trim());
  return result;
}
function isSolidityType(type) {
  return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
}
function isSolidityKeyword(name) {
  return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
}
function isValidDataLocation(type, isArray) {
  return isArray || type === "bytes" || type === "string" || type === "tuple";
}
var abiParameterWithoutTupleRegex, abiParameterWithTupleRegex, dynamicIntegerRegex, protectedKeywordsRegex;
var init_utils = __esm(() => {
  init_regex();
  init_abiItem();
  init_abiParameter();
  init_signature();
  init_splitParameters();
  init_cache();
  init_signatures();
  abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
  abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
  dynamicIntegerRegex = /^u?int$/;
  protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
});

// ../../../node_modules/abitype/dist/esm/human-readable/runtime/structs.js
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let i = 0;i < signaturesLength; i++) {
    const signature = signatures[i];
    if (!isStructSignature(signature))
      continue;
    const match = execStructSignature(signature);
    if (!match)
      throw new InvalidSignatureError({ signature, type: "struct" });
    const properties = match.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k = 0;k < propertiesLength; k++) {
      const property = properties[k];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (!components.length)
      throw new InvalidStructSignatureError({ signature });
    shallowStructs[match.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let i = 0;i < entriesLength; i++) {
    const [name, parameters] = entries[i];
    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
function resolveStructs(abiParameters, structs, ancestors = new Set) {
  const components = [];
  const length = abiParameters.length;
  for (let i = 0;i < length; i++) {
    const abiParameter = abiParameters[i];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
      if (!match?.type)
        throw new InvalidAbiTypeParameterError({ abiParameter });
      const { array, type } = match;
      if (type in structs) {
        if (ancestors.has(type))
          throw new CircularReferenceError({ type });
        components.push({
          ...abiParameter,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type]))
        });
      } else {
        if (isSolidityType(type))
          components.push(abiParameter);
        else
          throw new UnknownTypeError({ type });
      }
    }
  }
  return components;
}
var typeWithoutTupleRegex;
var init_structs = __esm(() => {
  init_regex();
  init_abiItem();
  init_abiParameter();
  init_signature();
  init_struct();
  init_signatures();
  init_utils();
  typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
});

// ../../../node_modules/abitype/dist/esm/human-readable/parseAbi.js
function parseAbi(signatures) {
  const structs = parseStructs(signatures);
  const abi = [];
  const length = signatures.length;
  for (let i = 0;i < length; i++) {
    const signature = signatures[i];
    if (isStructSignature(signature))
      continue;
    abi.push(parseSignature(signature, structs));
  }
  return abi;
}
var init_parseAbi = __esm(() => {
  init_signatures();
  init_structs();
  init_utils();
});

// ../../../node_modules/abitype/dist/esm/human-readable/parseAbiItem.js
function parseAbiItem(signature) {
  let abiItem;
  if (typeof signature === "string")
    abiItem = parseSignature(signature);
  else {
    const structs = parseStructs(signature);
    const length = signature.length;
    for (let i = 0;i < length; i++) {
      const signature_ = signature[i];
      if (isStructSignature(signature_))
        continue;
      abiItem = parseSignature(signature_, structs);
      break;
    }
  }
  if (!abiItem)
    throw new InvalidAbiItemError({ signature });
  return abiItem;
}
var init_parseAbiItem = __esm(() => {
  init_abiItem();
  init_signatures();
  init_structs();
  init_utils();
});

// ../../../node_modules/abitype/dist/esm/exports/index.js
var init_exports = __esm(() => {
  init_formatAbiItem();
  init_parseAbi();
  init_parseAbiItem();
});

// ../../../node_modules/viem/_esm/utils/abi/formatAbiItem.js
function formatAbiItem2(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
var init_formatAbiItem2 = __esm(() => {
  init_abi();
});

// ../../../node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}

// ../../../node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = () => {
};

// ../../../node_modules/viem/_esm/errors/version.js
var version2 = "2.23.6";

// ../../../node_modules/viem/_esm/errors/base.js
function walk(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause !== undefined)
    return walk(err.cause, fn);
  return fn ? null : err;
}
var errorConfig, BaseError2;
var init_base = __esm(() => {
  errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : undefined,
    version: `viem@${version2}`
  };
  BaseError2 = class BaseError2 extends Error {
    constructor(shortMessage, args = {}) {
      const details = (() => {
        if (args.cause instanceof BaseError2)
          return args.cause.details;
        if (args.cause?.message)
          return args.cause.message;
        return args.details;
      })();
      const docsPath = (() => {
        if (args.cause instanceof BaseError2)
          return args.cause.docsPath || args.docsPath;
        return args.docsPath;
      })();
      const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsUrl ? [`Docs: ${docsUrl}`] : [],
        ...details ? [`Details: ${details}`] : [],
        ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
      ].join(`
`);
      super(message, args.cause ? { cause: args.cause } : undefined);
      Object.defineProperty(this, "details", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "docsPath", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "metaMessages", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "shortMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "version", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BaseError"
      });
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.name = args.name ?? this.name;
      this.shortMessage = shortMessage;
      this.version = version2;
    }
    walk(fn) {
      return walk(this, fn);
    }
  };
});

// ../../../node_modules/viem/_esm/errors/abi.js
var AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, AbiItemAmbiguityError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
var init_abi = __esm(() => {
  init_formatAbiItem2();
  init_size();
  init_base();
  AbiConstructorNotFoundError = class AbiConstructorNotFoundError extends BaseError2 {
    constructor({ docsPath }) {
      super([
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiConstructorNotFoundError"
      });
    }
  };
  AbiConstructorParamsNotFoundError = class AbiConstructorParamsNotFoundError extends BaseError2 {
    constructor({ docsPath }) {
      super([
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
      ].join(`
`), {
        docsPath,
        name: "AbiConstructorParamsNotFoundError"
      });
    }
  };
  AbiDecodingDataSizeTooSmallError = class AbiDecodingDataSizeTooSmallError extends BaseError2 {
    constructor({ data, params, size: size2 }) {
      super([`Data size of ${size2} bytes is too small for given parameters.`].join(`
`), {
        metaMessages: [
          `Params: (${formatAbiParams(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ],
        name: "AbiDecodingDataSizeTooSmallError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  };
  AbiDecodingZeroDataError = class AbiDecodingZeroDataError extends BaseError2 {
    constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.', {
        name: "AbiDecodingZeroDataError"
      });
    }
  };
  AbiEncodingArrayLengthMismatchError = class AbiEncodingArrayLengthMismatchError extends BaseError2 {
    constructor({ expectedLength, givenLength, type }) {
      super([
        `ABI encoding array length mismatch for type ${type}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`
      ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
    }
  };
  AbiEncodingBytesSizeMismatchError = class AbiEncodingBytesSizeMismatchError extends BaseError2 {
    constructor({ expectedSize, value }) {
      super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: "AbiEncodingBytesSizeMismatchError" });
    }
  };
  AbiEncodingLengthMismatchError = class AbiEncodingLengthMismatchError extends BaseError2 {
    constructor({ expectedLength, givenLength }) {
      super([
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`
      ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
    }
  };
  AbiErrorSignatureNotFoundError = class AbiErrorSignatureNotFoundError extends BaseError2 {
    constructor(signature, { docsPath }) {
      super([
        `Encoded error signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join(`
`), {
        docsPath,
        name: "AbiErrorSignatureNotFoundError"
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.signature = signature;
    }
  };
  AbiEventSignatureEmptyTopicsError = class AbiEventSignatureEmptyTopicsError extends BaseError2 {
    constructor({ docsPath }) {
      super("Cannot extract event signature from empty topics.", {
        docsPath,
        name: "AbiEventSignatureEmptyTopicsError"
      });
    }
  };
  AbiEventSignatureNotFoundError = class AbiEventSignatureNotFoundError extends BaseError2 {
    constructor(signature, { docsPath }) {
      super([
        `Encoded event signature "${signature}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
      ].join(`
`), {
        docsPath,
        name: "AbiEventSignatureNotFoundError"
      });
    }
  };
  AbiEventNotFoundError = class AbiEventNotFoundError extends BaseError2 {
    constructor(eventName, { docsPath } = {}) {
      super([
        `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiEventNotFoundError"
      });
    }
  };
  AbiFunctionNotFoundError = class AbiFunctionNotFoundError extends BaseError2 {
    constructor(functionName, { docsPath } = {}) {
      super([
        `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiFunctionNotFoundError"
      });
    }
  };
  AbiFunctionOutputsNotFoundError = class AbiFunctionOutputsNotFoundError extends BaseError2 {
    constructor(functionName, { docsPath }) {
      super([
        `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it."
      ].join(`
`), {
        docsPath,
        name: "AbiFunctionOutputsNotFoundError"
      });
    }
  };
  AbiItemAmbiguityError = class AbiItemAmbiguityError extends BaseError2 {
    constructor(x, y) {
      super("Found ambiguous types in overloaded ABI items.", {
        metaMessages: [
          `\`${x.type}\` in \`${formatAbiItem2(x.abiItem)}\`, and`,
          `\`${y.type}\` in \`${formatAbiItem2(y.abiItem)}\``,
          "",
          "These types encode differently and cannot be distinguished at runtime.",
          "Remove one of the ambiguous items in the ABI."
        ],
        name: "AbiItemAmbiguityError"
      });
    }
  };
  BytesSizeMismatchError = class BytesSizeMismatchError extends BaseError2 {
    constructor({ expectedSize, givenSize }) {
      super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
        name: "BytesSizeMismatchError"
      });
    }
  };
  DecodeLogDataMismatch = class DecodeLogDataMismatch extends BaseError2 {
    constructor({ abiItem, data, params, size: size2 }) {
      super([
        `Data size of ${size2} bytes is too small for non-indexed event parameters.`
      ].join(`
`), {
        metaMessages: [
          `Params: (${formatAbiParams(params, { includeName: true })})`,
          `Data:   ${data} (${size2} bytes)`
        ],
        name: "DecodeLogDataMismatch"
      });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "params", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "size", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
      this.data = data;
      this.params = params;
      this.size = size2;
    }
  };
  DecodeLogTopicsMismatch = class DecodeLogTopicsMismatch extends BaseError2 {
    constructor({ abiItem, param }) {
      super([
        `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem2(abiItem, { includeName: true })}".`
      ].join(`
`), { name: "DecodeLogTopicsMismatch" });
      Object.defineProperty(this, "abiItem", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abiItem = abiItem;
    }
  };
  InvalidAbiEncodingTypeError = class InvalidAbiEncodingTypeError extends BaseError2 {
    constructor(type, { docsPath }) {
      super([
        `Type "${type}" is not a valid encoding type.`,
        "Please provide a valid ABI type."
      ].join(`
`), { docsPath, name: "InvalidAbiEncodingType" });
    }
  };
  InvalidAbiDecodingTypeError = class InvalidAbiDecodingTypeError extends BaseError2 {
    constructor(type, { docsPath }) {
      super([
        `Type "${type}" is not a valid decoding type.`,
        "Please provide a valid ABI type."
      ].join(`
`), { docsPath, name: "InvalidAbiDecodingType" });
    }
  };
  InvalidArrayError = class InvalidArrayError extends BaseError2 {
    constructor(value) {
      super([`Value "${value}" is not a valid array.`].join(`
`), {
        name: "InvalidArrayError"
      });
    }
  };
  InvalidDefinitionTypeError = class InvalidDefinitionTypeError extends BaseError2 {
    constructor(type) {
      super([
        `"${type}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"'
      ].join(`
`), { name: "InvalidDefinitionTypeError" });
    }
  };
});

// ../../../node_modules/viem/_esm/errors/data.js
var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError, InvalidBytesLengthError;
var init_data = __esm(() => {
  init_base();
  SliceOffsetOutOfBoundsError = class SliceOffsetOutOfBoundsError extends BaseError2 {
    constructor({ offset, position, size: size2 }) {
      super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`, { name: "SliceOffsetOutOfBoundsError" });
    }
  };
  SizeExceedsPaddingSizeError = class SizeExceedsPaddingSizeError extends BaseError2 {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
    }
  };
  InvalidBytesLengthError = class InvalidBytesLengthError extends BaseError2 {
    constructor({ size: size2, targetSize, type }) {
      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size2} ${type} long.`, { name: "InvalidBytesLengthError" });
    }
  };
});

// ../../../node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes;
  if (bytes.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0;i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}
var init_pad = __esm(() => {
  init_data();
});

// ../../../node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError, InvalidBytesBooleanError, InvalidHexBooleanError, SizeOverflowError;
var init_encoding = __esm(() => {
  init_base();
  IntegerOutOfRangeError = class IntegerOutOfRangeError extends BaseError2 {
    constructor({ max, min, signed, size: size2, value }) {
      super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
    }
  };
  InvalidBytesBooleanError = class InvalidBytesBooleanError extends BaseError2 {
    constructor(bytes) {
      super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
        name: "InvalidBytesBooleanError"
      });
    }
  };
  InvalidHexBooleanError = class InvalidHexBooleanError extends BaseError2 {
    constructor(hex) {
      super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: "InvalidHexBooleanError" });
    }
  };
  SizeOverflowError = class SizeOverflowError extends BaseError2 {
    constructor({ givenSize, maxSize }) {
      super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
    }
  };
});

// ../../../node_modules/viem/_esm/utils/data/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0;i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}

// ../../../node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size2 }) {
  if (size(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = trim(hex);
  }
  if (trim(hex) === "0x00")
    return false;
  if (trim(hex) === "0x01")
    return true;
  throw new InvalidHexBooleanError(hex);
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
var init_fromHex = __esm(() => {
  init_encoding();
  init_size();
});

// ../../../node_modules/viem/_esm/utils/encoding/toHex.js
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex(value, opts = {}) {
  let string = "";
  for (let i = 0;i < value.length; i++) {
    string += hexes[value[i]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex, { size: size2 });
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex(value, opts);
}
var hexes, encoder;
var init_toHex = __esm(() => {
  init_encoding();
  init_pad();
  init_fromHex();
  hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  encoder = /* @__PURE__ */ new TextEncoder;
});

// ../../../node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { size: opts.size });
  }
  return bytes;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return;
}
function hexToBytes(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j = 0;index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new BaseError2(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { dir: "right", size: opts.size });
  }
  return bytes;
}
var encoder2, charCodeMap;
var init_toBytes = __esm(() => {
  init_base();
  init_pad();
  init_fromHex();
  init_toHex();
  encoder2 = /* @__PURE__ */ new TextEncoder;
  charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
  };
});

// ../../../node_modules/@noble/hashes/esm/_assert.js
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
var init__assert = () => {
};

// ../../../node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var U32_MASK64, _32n, rotlSH = (h, l, s) => h << s | l >>> 32 - s, rotlSL = (h, l, s) => l << s | h >>> 32 - s, rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s, rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
var init__u64 = __esm(() => {
  U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  _32n = /* @__PURE__ */ BigInt(32);
});

// ../../../node_modules/@noble/hashes/esm/crypto.js
var crypto2;
var init_crypto = __esm(() => {
  crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
});

// ../../../node_modules/@noble/hashes/esm/utils.js
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i = 0;i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}

class Hash {
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return crypto2.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var isLE;
var init_utils2 = __esm(() => {
  init_crypto();
  init__assert();
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
});

// ../../../node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s), rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s), Keccak, gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen)), sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)), shake128, shake256;
var init_sha3 = __esm(() => {
  init__assert();
  init__u64();
  init_utils2();
  SHA3_PI = [];
  SHA3_ROTL = [];
  _SHA3_IOTA = [];
  _0n = /* @__PURE__ */ BigInt(0);
  _1n = /* @__PURE__ */ BigInt(1);
  _2n = /* @__PURE__ */ BigInt(2);
  _7n = /* @__PURE__ */ BigInt(7);
  _256n = /* @__PURE__ */ BigInt(256);
  _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  Keccak = class Keccak extends Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      anumber(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      if (!isLE)
        byteSwap32(this.state32);
      keccakP(this.state32, this.rounds);
      if (!isLE)
        byteSwap32(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      aexists(this);
      const { blockLen, state } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0;i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      aexists(this, false);
      abytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length;pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      anumber(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      aoutput(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
});

// ../../../node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}
var init_keccak256 = __esm(() => {
  init_sha3();
  init_toBytes();
  init_toHex();
});

// ../../../node_modules/viem/_esm/utils/hash/hashSignature.js
function hashSignature(sig) {
  return hash(sig);
}
var hash = (value) => keccak256(toBytes(value));
var init_hashSignature = __esm(() => {
  init_toBytes();
  init_keccak256();
});

// ../../../node_modules/viem/_esm/utils/hash/normalizeSignature.js
function normalizeSignature(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0;i < signature.length; i++) {
    const char = signature[i];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError2("Unable to normalize signature.");
  return result;
}
var init_normalizeSignature = __esm(() => {
  init_base();
});

// ../../../node_modules/viem/_esm/utils/hash/toSignature.js
var toSignature = (def) => {
  const def_ = (() => {
    if (typeof def === "string")
      return def;
    return formatAbiItem(def);
  })();
  return normalizeSignature(def_);
};
var init_toSignature = __esm(() => {
  init_exports();
  init_normalizeSignature();
});

// ../../../node_modules/viem/_esm/utils/hash/toSignatureHash.js
function toSignatureHash(fn) {
  return hashSignature(toSignature(fn));
}
var init_toSignatureHash = __esm(() => {
  init_hashSignature();
  init_toSignature();
});

// ../../../node_modules/viem/_esm/utils/hash/toEventSelector.js
var toEventSelector;
var init_toEventSelector = __esm(() => {
  init_toSignatureHash();
  toEventSelector = toSignatureHash;
});

// ../../../node_modules/viem/_esm/errors/address.js
var InvalidAddressError;
var init_address = __esm(() => {
  init_base();
  InvalidAddressError = class InvalidAddressError extends BaseError2 {
    constructor({ address }) {
      super(`Address "${address}" is invalid.`, {
        metaMessages: [
          "- Address must be a hex value of 20 bytes (40 hex characters).",
          "- Address must match its checksum counterpart."
        ],
        name: "InvalidAddressError"
      });
    }
  };
});

// ../../../node_modules/viem/_esm/utils/lru.js
var LruMap;
var init_lru = __esm(() => {
  LruMap = class LruMap extends Map {
    constructor(size2) {
      super();
      Object.defineProperty(this, "maxSize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.maxSize = size2;
    }
    get(key) {
      const value = super.get(key);
      if (super.has(key) && value !== undefined) {
        this.delete(key);
        super.set(key, value);
      }
      return value;
    }
    set(key, value) {
      super.set(key, value);
      if (this.maxSize && this.size > this.maxSize) {
        const firstKey = this.keys().next().value;
        if (firstKey)
          this.delete(firstKey);
      }
      return this;
    }
  };
});

// ../../../node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0;i < 40; i += 2) {
    if (hash2[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
function getAddress(address, chainId) {
  if (!isAddress(address, { strict: false }))
    throw new InvalidAddressError({ address });
  return checksumAddress(address, chainId);
}
var checksumAddressCache;
var init_getAddress = __esm(() => {
  init_address();
  init_toBytes();
  init_keccak256();
  init_lru();
  init_isAddress();
  checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
});

// ../../../node_modules/viem/_esm/utils/address/isAddress.js
function isAddress(address, options) {
  const { strict = true } = options ?? {};
  const cacheKey = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey))
    return isAddressCache.get(cacheKey);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey, result);
  return result;
}
var addressRegex, isAddressCache;
var init_isAddress = __esm(() => {
  init_lru();
  init_getAddress();
  addressRegex = /^0x[a-fA-F0-9]{40}$/;
  isAddressCache = /* @__PURE__ */ new LruMap(8192);
});

// ../../../node_modules/viem/_esm/utils/data/concat.js
function concat(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes2(values);
}
function concatBytes2(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}

// ../../../node_modules/viem/_esm/utils/data/slice.js
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
var init_slice = __esm(() => {
  init_data();
  init_size();
});

// ../../../node_modules/viem/_esm/utils/regex.js
var bytesRegex2, integerRegex2;
var init_regex2 = __esm(() => {
  bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
});

// ../../../node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i = 0;i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    const [, , size2 = "256"] = integerRegex2.exec(param.type) ?? [];
    return encodeNumber(value, {
      signed,
      size: Number(size2)
    });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0;i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0;i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0;i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  if (typeof value !== "boolean")
    throw new BaseError2(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed, size: size2 = 256 }) {
  if (typeof size2 === "number") {
    const max = 2n ** (BigInt(size2) - (signed ? 1n : 0n)) - 1n;
    const min = signed ? -max - 1n : 0n;
    if (value > max || value < min)
      throw new IntegerOutOfRangeError({
        max: max.toString(),
        min: min.toString(),
        signed,
        size: size2 / 8,
        value: value.toString()
      });
  }
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size(hexValue) / 32);
  const parts = [];
  for (let i = 0;i < partsLength; i++) {
    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat([
      padHex(numberToHex(size(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0;i < param.components.length; i++) {
    const param_ = param.components[i];
    const index = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
}
var init_encodeAbiParameters = __esm(() => {
  init_abi();
  init_address();
  init_base();
  init_encoding();
  init_isAddress();
  init_pad();
  init_size();
  init_slice();
  init_toHex();
  init_regex2();
});

// ../../../node_modules/viem/_esm/utils/hash/toFunctionSelector.js
var toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);
var init_toFunctionSelector = __esm(() => {
  init_slice();
  init_toSignatureHash();
});

// ../../../node_modules/viem/_esm/utils/abi/getAbiItem.js
function getAbiItem(parameters) {
  const { abi, args = [], name } = parameters;
  const isSelector = isHex(name, { strict: false });
  const abiItems = abi.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return toFunctionSelector(abiItem) === name;
      if (abiItem.type === "event")
        return toEventSelector(abiItem) === name;
      return false;
    }
    return "name" in abiItem && abiItem.name === name;
  });
  if (abiItems.length === 0)
    return;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem = undefined;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index) => {
          return isArgOfType(Object.values(arg)[index], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
          ...abiParameter,
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types.includes("address") && types.includes("bytes20"))
        return true;
      if (types.includes("address") && types.includes("string"))
        return isAddress(args[parameterIndex], { strict: false });
      if (types.includes("address") && types.includes("bytes"))
        return isAddress(args[parameterIndex], { strict: false });
      return false;
    })();
    if (ambiguous)
      return types;
  }
  return;
}
var init_getAbiItem = __esm(() => {
  init_abi();
  init_isAddress();
  init_toEventSelector();
  init_toFunctionSelector();
});

// ../../../node_modules/viem/_esm/accounts/utils/parseAccount.js
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}

// ../../../node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js
function prepareEncodeFunctionData(parameters) {
  const { abi, args, functionName } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({
      abi,
      args,
      name: functionName
    });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath2 });
  return {
    abi: [abiItem],
    functionName: toFunctionSelector(formatAbiItem2(abiItem))
  };
}
var docsPath2 = "/docs/contract/encodeFunctionData";
var init_prepareEncodeFunctionData = __esm(() => {
  init_abi();
  init_toFunctionSelector();
  init_formatAbiItem2();
  init_getAbiItem();
});

// ../../../node_modules/viem/_esm/utils/abi/encodeFunctionData.js
function encodeFunctionData(parameters) {
  const { args } = parameters;
  const { abi, functionName } = (() => {
    if (parameters.abi.length === 1 && parameters.functionName?.startsWith("0x"))
      return parameters;
    return prepareEncodeFunctionData(parameters);
  })();
  const abiItem = abi[0];
  const signature = functionName;
  const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : undefined;
  return concatHex([signature, data ?? "0x"]);
}
var init_encodeFunctionData = __esm(() => {
  init_encodeAbiParameters();
  init_prepareEncodeFunctionData();
});

// ../../../node_modules/viem/_esm/constants/solidity.js
var panicReasons, solidityError, solidityPanic;
var init_solidity = __esm(() => {
  panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmetic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
  };
  solidityError = {
    inputs: [
      {
        name: "message",
        type: "string"
      }
    ],
    name: "Error",
    type: "error"
  };
  solidityPanic = {
    inputs: [
      {
        name: "reason",
        type: "uint256"
      }
    ],
    name: "Panic",
    type: "error"
  };
});

// ../../../node_modules/viem/_esm/errors/cursor.js
var NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;
var init_cursor = __esm(() => {
  init_base();
  NegativeOffsetError = class NegativeOffsetError extends BaseError2 {
    constructor({ offset }) {
      super(`Offset \`${offset}\` cannot be negative.`, {
        name: "NegativeOffsetError"
      });
    }
  };
  PositionOutOfBoundsError = class PositionOutOfBoundsError extends BaseError2 {
    constructor({ length, position }) {
      super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: "PositionOutOfBoundsError" });
    }
  };
  RecursiveReadLimitExceededError = class RecursiveReadLimitExceededError extends BaseError2 {
    constructor({ count, limit }) {
      super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: "RecursiveReadLimitExceededError" });
    }
  };
});

// ../../../node_modules/viem/_esm/utils/cursor.js
function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = new Map;
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
var staticCursor;
var init_cursor2 = __esm(() => {
  init_cursor();
  staticCursor = {
    bytes: new Uint8Array,
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map,
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit() {
      if (this.recursiveReadCount >= this.recursiveReadLimit)
        throw new RecursiveReadLimitExceededError({
          count: this.recursiveReadCount + 1,
          limit: this.recursiveReadLimit
        });
    },
    assertPosition(position) {
      if (position < 0 || position > this.bytes.length - 1)
        throw new PositionOutOfBoundsError({
          length: this.bytes.length,
          position
        });
    },
    decrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position - offset;
      this.assertPosition(position);
      this.position = position;
    },
    getReadCount(position) {
      return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
      if (offset < 0)
        throw new NegativeOffsetError({ offset });
      const position = this.position + offset;
      this.assertPosition(position);
      this.position = position;
    },
    inspectByte(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectBytes(length, position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + length - 1);
      return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position);
      return this.bytes[position];
    },
    inspectUint16(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 1);
      return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 2);
      return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32(position_) {
      const position = position_ ?? this.position;
      this.assertPosition(position + 3);
      return this.dataView.getUint32(position);
    },
    pushByte(byte) {
      this.assertPosition(this.position);
      this.bytes[this.position] = byte;
      this.position++;
    },
    pushBytes(bytes) {
      this.assertPosition(this.position + bytes.length - 1);
      this.bytes.set(bytes, this.position);
      this.position += bytes.length;
    },
    pushUint8(value) {
      this.assertPosition(this.position);
      this.bytes[this.position] = value;
      this.position++;
    },
    pushUint16(value) {
      this.assertPosition(this.position + 1);
      this.dataView.setUint16(this.position, value);
      this.position += 2;
    },
    pushUint24(value) {
      this.assertPosition(this.position + 2);
      this.dataView.setUint16(this.position, value >> 8);
      this.dataView.setUint8(this.position + 2, value & ~4294967040);
      this.position += 3;
    },
    pushUint32(value) {
      this.assertPosition(this.position + 3);
      this.dataView.setUint32(this.position, value);
      this.position += 4;
    },
    readByte() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectByte();
      this.position++;
      return value;
    },
    readBytes(length, size2) {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectBytes(length);
      this.position += size2 ?? length;
      return value;
    },
    readUint8() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint8();
      this.position += 1;
      return value;
    },
    readUint16() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint16();
      this.position += 2;
      return value;
    },
    readUint24() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint24();
      this.position += 3;
      return value;
    },
    readUint32() {
      this.assertReadLimit();
      this._touch();
      const value = this.inspectUint32();
      this.position += 4;
      return value;
    },
    get remaining() {
      return this.bytes.length - this.position;
    },
    setPosition(position) {
      const oldPosition = this.position;
      this.assertPosition(position);
      this.position = position;
      return () => this.position = oldPosition;
    },
    _touch() {
      if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
        return;
      const count = this.getReadCount();
      this.positionReadCount.set(this.position, count + 1);
      if (count > 0)
        this.recursiveReadCount++;
    }
  };
});

// ../../../node_modules/viem/_esm/utils/encoding/fromBytes.js
function bytesToBigInt(bytes, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes, { size: opts.size });
  const hex = bytesToHex(bytes, opts);
  return hexToBigInt(hex, opts);
}
function bytesToBool(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes);
  }
  if (bytes.length > 1 || bytes[0] > 1)
    throw new InvalidBytesBooleanError(bytes);
  return Boolean(bytes[0]);
}
function bytesToNumber(bytes, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize(bytes, { size: opts.size });
  const hex = bytesToHex(bytes, opts);
  return hexToNumber(hex, opts);
}
function bytesToString(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize(bytes, { size: opts.size });
    bytes = trim(bytes, { dir: "right" });
  }
  return new TextDecoder().decode(bytes);
}
var init_fromBytes = __esm(() => {
  init_encoding();
  init_fromHex();
  init_toHex();
});

// ../../../node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
function decodeAbiParameters(params, data) {
  const bytes = typeof data === "string" ? hexToBytes(data) : data;
  const cursor = createCursor(bytes);
  if (size(bytes) === 0 && params.length > 0)
    throw new AbiDecodingZeroDataError;
  if (size(data) && size(data) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof data === "string" ? data : bytesToHex(data),
      params,
      size: size(data)
    });
  let consumed = 0;
  const values = [];
  for (let i = 0;i < params.length; ++i) {
    const param = params[i];
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter(cursor, param, {
      staticPosition: 0
    });
    consumed += consumed_;
    values.push(data2);
  }
  return values;
}
function decodeParameter(cursor, param, { staticPosition }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return decodeArray(cursor, { ...param, type }, { length, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor, param, { staticPosition });
  if (param.type === "address")
    return decodeAddress(cursor);
  if (param.type === "bool")
    return decodeBool(cursor);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor, param);
  if (param.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress(cursor) {
  const value = cursor.readBytes(32);
  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];
}
function decodeArray(cursor, param, { length, staticPosition }) {
  if (!length) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const startOfData = start + sizeOfLength;
    cursor.setPosition(start);
    const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value2 = [];
    for (let i = 0;i < length2; ++i) {
      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
      const [data, consumed_] = decodeParameter(cursor, param, {
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  if (hasDynamicChild(param)) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const value2 = [];
    for (let i = 0;i < length; ++i) {
      cursor.setPosition(start + i * 32);
      const [data] = decodeParameter(cursor, param, {
        staticPosition: start
      });
      value2.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  let consumed = 0;
  const value = [];
  for (let i = 0;i < length; ++i) {
    const [data, consumed_] = decodeParameter(cursor, param, {
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value.push(data);
  }
  return [value, consumed];
}
function decodeBool(cursor) {
  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
  const [_, size2] = param.type.split("bytes");
  if (!size2) {
    const offset = bytesToNumber(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset);
    const length = bytesToNumber(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length);
    cursor.setPosition(staticPosition + 32);
    return [bytesToHex(data), 32];
  }
  const value = bytesToHex(cursor.readBytes(Number.parseInt(size2), 32));
  return [value, 32];
}
function decodeNumber(cursor, param) {
  const signed = param.type.startsWith("int");
  const size2 = Number.parseInt(param.type.split("int")[1] || "256");
  const value = cursor.readBytes(32);
  return [
    size2 > 48 ? bytesToBigInt(value, { signed }) : bytesToNumber(value, { signed }),
    32
  ];
}
function decodeTuple(cursor, param, { staticPosition }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    for (let i = 0;i < param.components.length; ++i) {
      const component = param.components[i];
      cursor.setPosition(start + consumed);
      const [data, consumed_] = decodeParameter(cursor, component, {
        staticPosition: start
      });
      consumed += consumed_;
      value[hasUnnamedChild ? i : component?.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
  }
  for (let i = 0;i < param.components.length; ++i) {
    const component = param.components[i];
    const [data, consumed_] = decodeParameter(cursor, component, {
      staticPosition
    });
    value[hasUnnamedChild ? i : component?.name] = data;
    consumed += consumed_;
  }
  return [value, consumed];
}
function decodeString(cursor, { staticPosition }) {
  const offset = bytesToNumber(cursor.readBytes(32));
  const start = staticPosition + offset;
  cursor.setPosition(start);
  const length = bytesToNumber(cursor.readBytes(32));
  if (length === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length, 32);
  const value = bytesToString(trim(data));
  cursor.setPosition(staticPosition + 32);
  return [value, 32];
}
function hasDynamicChild(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return param.components?.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
var sizeOfLength = 32, sizeOfOffset = 32;
var init_decodeAbiParameters = __esm(() => {
  init_abi();
  init_getAddress();
  init_cursor2();
  init_size();
  init_slice();
  init_fromBytes();
  init_toBytes();
  init_toHex();
  init_encodeAbiParameters();
});

// ../../../node_modules/viem/_esm/utils/abi/decodeErrorResult.js
function decodeErrorResult(parameters) {
  const { abi, data } = parameters;
  const signature = slice(data, 0, 4);
  if (signature === "0x")
    throw new AbiDecodingZeroDataError;
  const abi_ = [...abi || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x) => x.type === "error" && signature === toFunctionSelector(formatAbiItem2(x)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : undefined,
    errorName: abiItem.name
  };
}
var init_decodeErrorResult = __esm(() => {
  init_solidity();
  init_abi();
  init_slice();
  init_toFunctionSelector();
  init_decodeAbiParameters();
  init_formatAbiItem2();
});

// ../../../node_modules/viem/_esm/utils/stringify.js
var stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return typeof replacer === "function" ? replacer(key, value2) : value2;
}, space);

// ../../../node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? stringify(args[i]) : args[i]}`).join(", ")})`;
}
var init_formatAbiItemWithArgs = () => {
};

// ../../../node_modules/viem/_esm/constants/unit.js
var etherUnits, gweiUnits;
var init_unit = __esm(() => {
  etherUnits = {
    gwei: 9,
    wei: 18
  };
  gweiUnits = {
    ether: -9,
    wei: 9
  };
});

// ../../../node_modules/viem/_esm/utils/unit/formatUnits.js
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// ../../../node_modules/viem/_esm/utils/unit/formatEther.js
function formatEther(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}
var init_formatEther = __esm(() => {
  init_unit();
});

// ../../../node_modules/viem/_esm/utils/unit/formatGwei.js
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
var init_formatGwei = __esm(() => {
  init_unit();
});

// ../../../node_modules/viem/_esm/errors/stateOverride.js
function prettyStateMapping(stateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}
`;
  }, "");
}
function prettyStateOverride(stateOverride) {
  return stateOverride.reduce((pretty, { address, ...state }) => {
    let val = `${pretty}    ${address}:
`;
    if (state.nonce)
      val += `      nonce: ${state.nonce}
`;
    if (state.balance)
      val += `      balance: ${state.balance}
`;
    if (state.code)
      val += `      code: ${state.code}
`;
    if (state.state) {
      val += `      state:
`;
      val += prettyStateMapping(state.state);
    }
    if (state.stateDiff) {
      val += `      stateDiff:
`;
      val += prettyStateMapping(state.stateDiff);
    }
    return val;
  }, `  State Override:
`).slice(0, -1);
}
var AccountStateConflictError, StateAssignmentConflictError;
var init_stateOverride = __esm(() => {
  init_base();
  AccountStateConflictError = class AccountStateConflictError extends BaseError2 {
    constructor({ address }) {
      super(`State for account "${address}" is set multiple times.`, {
        name: "AccountStateConflictError"
      });
    }
  };
  StateAssignmentConflictError = class StateAssignmentConflictError extends BaseError2 {
    constructor() {
      super("state and stateDiff are set on the same account.", {
        name: "StateAssignmentConflictError"
      });
    }
  };
});

// ../../../node_modules/viem/_esm/errors/transaction.js
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === undefined || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(`
`);
}
var FeeConflictError, InvalidLegacyVError, InvalidSerializableTransactionError, InvalidStorageKeySizeError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;
var init_transaction = __esm(() => {
  init_base();
  FeeConflictError = class FeeConflictError extends BaseError2 {
    constructor() {
      super([
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
      ].join(`
`), { name: "FeeConflictError" });
    }
  };
  InvalidLegacyVError = class InvalidLegacyVError extends BaseError2 {
    constructor({ v }) {
      super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
        name: "InvalidLegacyVError"
      });
    }
  };
  InvalidSerializableTransactionError = class InvalidSerializableTransactionError extends BaseError2 {
    constructor({ transaction }) {
      super("Cannot infer a transaction type from provided transaction.", {
        metaMessages: [
          "Provided Transaction:",
          "{",
          prettyPrint(transaction),
          "}",
          "",
          "To infer the type, either provide:",
          "- a `type` to the Transaction, or",
          "- an EIP-1559 Transaction with `maxFeePerGas`, or",
          "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
          "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
          "- an EIP-7702 Transaction with `authorizationList`, or",
          "- a Legacy Transaction with `gasPrice`"
        ],
        name: "InvalidSerializableTransactionError"
      });
    }
  };
  InvalidStorageKeySizeError = class InvalidStorageKeySizeError extends BaseError2 {
    constructor({ storageKey }) {
      super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
    }
  };
  TransactionNotFoundError = class TransactionNotFoundError extends BaseError2 {
    constructor({ blockHash, blockNumber, blockTag, hash: hash2, index }) {
      let identifier = "Transaction";
      if (blockTag && index !== undefined)
        identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
      if (blockHash && index !== undefined)
        identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
      if (blockNumber && index !== undefined)
        identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
      if (hash2)
        identifier = `Transaction with hash "${hash2}"`;
      super(`${identifier} could not be found.`, {
        name: "TransactionNotFoundError"
      });
    }
  };
  TransactionReceiptNotFoundError = class TransactionReceiptNotFoundError extends BaseError2 {
    constructor({ hash: hash2 }) {
      super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`, {
        name: "TransactionReceiptNotFoundError"
      });
    }
  };
  WaitForTransactionReceiptTimeoutError = class WaitForTransactionReceiptTimeoutError extends BaseError2 {
    constructor({ hash: hash2 }) {
      super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
    }
  };
});

// ../../../node_modules/viem/_esm/errors/utils.js
var getContractAddress = (address) => address, getUrl = (url) => url;

// ../../../node_modules/viem/_esm/errors/contract.js
var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, CounterfactualDeploymentFailedError, RawContractError;
var init_contract = __esm(() => {
  init_solidity();
  init_decodeErrorResult();
  init_formatAbiItem2();
  init_formatAbiItemWithArgs();
  init_getAbiItem();
  init_formatEther();
  init_formatGwei();
  init_abi();
  init_base();
  init_stateOverride();
  init_transaction();
  CallExecutionError = class CallExecutionError extends BaseError2 {
    constructor(cause, { account: account_, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
      const account = account_ ? parseAccount(account_) : undefined;
      let prettyArgs = prettyPrint({
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      if (stateOverride) {
        prettyArgs += `
${prettyStateOverride(stateOverride)}`;
      }
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath3,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Raw Call Arguments:",
          prettyArgs
        ].filter(Boolean),
        name: "CallExecutionError"
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.cause = cause;
    }
  };
  ContractFunctionExecutionError = class ContractFunctionExecutionError extends BaseError2 {
    constructor(cause, { abi, args, contractAddress, docsPath: docsPath3, functionName, sender }) {
      const abiItem = getAbiItem({ abi, args, name: functionName });
      const formattedArgs = abiItem ? formatAbiItemWithArgs({
        abiItem,
        args,
        includeFunctionName: false,
        includeName: false
      }) : undefined;
      const functionWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : undefined;
      const prettyArgs = prettyPrint({
        address: contractAddress && getContractAddress(contractAddress),
        function: functionWithParams,
        args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
        sender
      });
      super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
        cause,
        docsPath: docsPath3,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          prettyArgs && "Contract Call:",
          prettyArgs
        ].filter(Boolean),
        name: "ContractFunctionExecutionError"
      });
      Object.defineProperty(this, "abi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "args", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "contractAddress", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "formattedArgs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "functionName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "sender", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.abi = abi;
      this.args = args;
      this.cause = cause;
      this.contractAddress = contractAddress;
      this.functionName = functionName;
      this.sender = sender;
    }
  };
  ContractFunctionRevertedError = class ContractFunctionRevertedError extends BaseError2 {
    constructor({ abi, data, functionName, message }) {
      let cause;
      let decodedData = undefined;
      let metaMessages;
      let reason;
      if (data && data !== "0x") {
        try {
          decodedData = decodeErrorResult({ abi, data });
          const { abiItem, errorName, args: errorArgs } = decodedData;
          if (errorName === "Error") {
            reason = errorArgs[0];
          } else if (errorName === "Panic") {
            const [firstArg] = errorArgs;
            reason = panicReasons[firstArg];
          } else {
            const errorWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : undefined;
            const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
              abiItem,
              args: errorArgs,
              includeFunctionName: false,
              includeName: false
            }) : undefined;
            metaMessages = [
              errorWithParams ? `Error: ${errorWithParams}` : "",
              formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
            ];
          }
        } catch (err) {
          cause = err;
        }
      } else if (message)
        reason = message;
      let signature;
      if (cause instanceof AbiErrorSignatureNotFoundError) {
        signature = cause.signature;
        metaMessages = [
          `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ];
      }
      super(reason && reason !== "execution reverted" || signature ? [
        `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
        reason || signature
      ].join(`
`) : `The contract function "${functionName}" reverted.`, {
        cause,
        metaMessages,
        name: "ContractFunctionRevertedError"
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "raw", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "reason", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "signature", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = decodedData;
      this.raw = data;
      this.reason = reason;
      this.signature = signature;
    }
  };
  ContractFunctionZeroDataError = class ContractFunctionZeroDataError extends BaseError2 {
    constructor({ functionName }) {
      super(`The contract function "${functionName}" returned no data ("0x").`, {
        metaMessages: [
          "This could be due to any of the following:",
          `  - The contract does not have the function "${functionName}",`,
          "  - The parameters passed to the contract function may be invalid, or",
          "  - The address is not a contract."
        ],
        name: "ContractFunctionZeroDataError"
      });
    }
  };
  CounterfactualDeploymentFailedError = class CounterfactualDeploymentFailedError extends BaseError2 {
    constructor({ factory }) {
      super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ""}`, {
        metaMessages: [
          "Please ensure:",
          "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
          "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
        ],
        name: "CounterfactualDeploymentFailedError"
      });
    }
  };
  RawContractError = class RawContractError extends BaseError2 {
    constructor({ data, message }) {
      super(message || "", { name: "RawContractError" });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = data;
    }
  };
});

// ../../../node_modules/viem/_esm/errors/request.js
var HttpRequestError, RpcRequestError, TimeoutError;
var init_request = __esm(() => {
  init_base();
  HttpRequestError = class HttpRequestError extends BaseError2 {
    constructor({ body, cause, details, headers, status, url }) {
      super("HTTP request failed.", {
        cause,
        details,
        metaMessages: [
          status && `Status: ${status}`,
          `URL: ${getUrl(url)}`,
          body && `Request body: ${stringify(body)}`
        ].filter(Boolean),
        name: "HttpRequestError"
      });
      Object.defineProperty(this, "body", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "headers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "status", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "url", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.body = body;
      this.headers = headers;
      this.status = status;
      this.url = url;
    }
  };
  RpcRequestError = class RpcRequestError extends BaseError2 {
    constructor({ body, error, url }) {
      super("RPC Request failed.", {
        cause: error,
        details: error.message,
        metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
        name: "RpcRequestError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.code = error.code;
      this.data = error.data;
    }
  };
  TimeoutError = class TimeoutError extends BaseError2 {
    constructor({ body, url }) {
      super("The request took too long to respond.", {
        details: "The request timed out.",
        metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
        name: "TimeoutError"
      });
    }
  };
});

// ../../../node_modules/viem/_esm/errors/rpc.js
var unknownErrorCode = -1, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnknownRpcError;
var init_rpc = __esm(() => {
  init_base();
  init_request();
  RpcError = class RpcError extends BaseError2 {
    constructor(cause, { code, docsPath: docsPath3, metaMessages, name, shortMessage }) {
      super(shortMessage, {
        cause,
        docsPath: docsPath3,
        metaMessages: metaMessages || cause?.metaMessages,
        name: name || "RpcError"
      });
      Object.defineProperty(this, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.name = name || cause.name;
      this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
    }
  };
  ProviderRpcError = class ProviderRpcError extends RpcError {
    constructor(cause, options) {
      super(cause, options);
      Object.defineProperty(this, "data", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.data = options.data;
    }
  };
  ParseRpcError = class ParseRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ParseRpcError.code,
        name: "ParseRpcError",
        shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      });
    }
  };
  Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
  });
  InvalidRequestRpcError = class InvalidRequestRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidRequestRpcError.code,
        name: "InvalidRequestRpcError",
        shortMessage: "JSON is not a valid request object."
      });
    }
  };
  Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
  });
  MethodNotFoundRpcError = class MethodNotFoundRpcError extends RpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: MethodNotFoundRpcError.code,
        name: "MethodNotFoundRpcError",
        shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
      });
    }
  };
  Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
  });
  InvalidParamsRpcError = class InvalidParamsRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidParamsRpcError.code,
        name: "InvalidParamsRpcError",
        shortMessage: [
          "Invalid parameters were provided to the RPC method.",
          "Double check you have provided the correct parameters."
        ].join(`
`)
      });
    }
  };
  Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
  });
  InternalRpcError = class InternalRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InternalRpcError.code,
        name: "InternalRpcError",
        shortMessage: "An internal error was received."
      });
    }
  };
  Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
  });
  InvalidInputRpcError = class InvalidInputRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: InvalidInputRpcError.code,
        name: "InvalidInputRpcError",
        shortMessage: [
          "Missing or invalid parameters.",
          "Double check you have provided the correct parameters."
        ].join(`
`)
      });
    }
  };
  Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
  });
  ResourceNotFoundRpcError = class ResourceNotFoundRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ResourceNotFoundRpcError.code,
        name: "ResourceNotFoundRpcError",
        shortMessage: "Requested resource not found."
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "ResourceNotFoundRpcError"
      });
    }
  };
  Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
  });
  ResourceUnavailableRpcError = class ResourceUnavailableRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: ResourceUnavailableRpcError.code,
        name: "ResourceUnavailableRpcError",
        shortMessage: "Requested resource not available."
      });
    }
  };
  Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
  });
  TransactionRejectedRpcError = class TransactionRejectedRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: TransactionRejectedRpcError.code,
        name: "TransactionRejectedRpcError",
        shortMessage: "Transaction creation failed."
      });
    }
  };
  Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
  });
  MethodNotSupportedRpcError = class MethodNotSupportedRpcError extends RpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: MethodNotSupportedRpcError.code,
        name: "MethodNotSupportedRpcError",
        shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
      });
    }
  };
  Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
  });
  LimitExceededRpcError = class LimitExceededRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: LimitExceededRpcError.code,
        name: "LimitExceededRpcError",
        shortMessage: "Request exceeds defined limit."
      });
    }
  };
  Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
  });
  JsonRpcVersionUnsupportedError = class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(cause) {
      super(cause, {
        code: JsonRpcVersionUnsupportedError.code,
        name: "JsonRpcVersionUnsupportedError",
        shortMessage: "Version of JSON-RPC protocol is not supported."
      });
    }
  };
  Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
  });
  UserRejectedRequestError = class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UserRejectedRequestError.code,
        name: "UserRejectedRequestError",
        shortMessage: "User rejected the request."
      });
    }
  };
  Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
  });
  UnauthorizedProviderError = class UnauthorizedProviderError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: UnauthorizedProviderError.code,
        name: "UnauthorizedProviderError",
        shortMessage: "The requested method and/or account has not been authorized by the user."
      });
    }
  };
  Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
  });
  UnsupportedProviderMethodError = class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(cause, { method } = {}) {
      super(cause, {
        code: UnsupportedProviderMethodError.code,
        name: "UnsupportedProviderMethodError",
        shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
      });
    }
  };
  Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
  });
  ProviderDisconnectedError = class ProviderDisconnectedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: ProviderDisconnectedError.code,
        name: "ProviderDisconnectedError",
        shortMessage: "The Provider is disconnected from all chains."
      });
    }
  };
  Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
  });
  ChainDisconnectedError = class ChainDisconnectedError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: ChainDisconnectedError.code,
        name: "ChainDisconnectedError",
        shortMessage: "The Provider is not connected to the requested chain."
      });
    }
  };
  Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
  });
  SwitchChainError = class SwitchChainError extends ProviderRpcError {
    constructor(cause) {
      super(cause, {
        code: SwitchChainError.code,
        name: "SwitchChainError",
        shortMessage: "An error occurred when attempting to switch chain."
      });
    }
  };
  Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
  });
  UnknownRpcError = class UnknownRpcError extends RpcError {
    constructor(cause) {
      super(cause, {
        name: "UnknownRpcError",
        shortMessage: "An unknown RPC error occurred."
      });
    }
  };
});

// ../../../node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD;
var init__md = __esm(() => {
  init__assert();
  init_utils2();
  HashMD = class HashMD extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes2(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };
});

// ../../../node_modules/@noble/hashes/esm/sha256.js
var SHA256_K, SHA256_IV, SHA256_W, SHA256, sha256;
var init_sha256 = __esm(() => {
  init__md();
  init_utils2();
  SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  SHA256_IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  SHA256 = class SHA256 extends HashMD {
    constructor() {
      super(64, 32, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256);
});

// ../../../node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
var init_hmac = __esm(() => {
  init__assert();
  init_utils2();
  HMAC = class HMAC extends Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      ahash(hash2);
      const key = toBytes2(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad2 = new Uint8Array(blockLen);
      pad2.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i = 0;i < pad2.length; i++)
        pad2[i] ^= 54;
      this.iHash.update(pad2);
      this.oHash = hash2.create();
      for (let i = 0;i < pad2.length; i++)
        pad2[i] ^= 54 ^ 92;
      this.oHash.update(pad2);
      pad2.fill(0);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  hmac.create = (hash2, key) => new HMAC(hash2, key);
});

// ../../../node_modules/viem/node_modules/@noble/curves/esm/abstract/utils.js
var exports_utils = {};
__export(exports_utils, {
  validateObject: () => validateObject,
  utf8ToBytes: () => utf8ToBytes2,
  numberToVarBytesBE: () => numberToVarBytesBE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToBytesLE: () => numberToBytesLE,
  numberToBytesBE: () => numberToBytesBE,
  notImplemented: () => notImplemented,
  memoized: () => memoized,
  isBytes: () => isBytes2,
  inRange: () => inRange,
  hexToNumber: () => hexToNumber2,
  hexToBytes: () => hexToBytes2,
  equalBytes: () => equalBytes,
  ensureBytes: () => ensureBytes,
  createHmacDrbg: () => createHmacDrbg,
  concatBytes: () => concatBytes3,
  bytesToNumberLE: () => bytesToNumberLE,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToHex: () => bytesToHex2,
  bitSet: () => bitSet,
  bitMask: () => bitMask,
  bitLen: () => bitLen,
  bitGet: () => bitGet,
  abytes: () => abytes2,
  abool: () => abool,
  aInRange: () => aInRange
});
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes2(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function bytesToHex2(bytes) {
  abytes2(bytes);
  let hex = "";
  for (let i = 0;i < bytes.length; i++) {
    hex += hexes2[bytes[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n2 : BigInt("0x" + hex);
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes) {
  return hexToNumber2(bytesToHex2(bytes));
}
function bytesToNumberLE(bytes) {
  abytes2(bytes);
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes2(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes3(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    abytes2(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad2 = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad2);
    pad2 += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0;i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0;n > _0n2; n >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n2;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n2 : _0n2) << BigInt(pos);
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes3(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === undefined)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
function memoized(fn) {
  const map = new WeakMap;
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== undefined)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
var _0n2, _1n2, _2n2, hexes2, asciis, isPosBig = (n) => typeof n === "bigint" && _0n2 <= n, bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2, u8n = (data) => new Uint8Array(data), u8fr = (arr) => Uint8Array.from(arr), validatorFns, notImplemented = () => {
  throw new Error("not implemented");
};
var init_utils3 = __esm(() => {
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n2 = /* @__PURE__ */ BigInt(0);
  _1n2 = /* @__PURE__ */ BigInt(1);
  _2n2 = /* @__PURE__ */ BigInt(2);
  hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
});

// ../../../node_modules/viem/node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n3)
    throw new Error("invalid modulus");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n3)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n3)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S, Z;
  for (Q = P - _1n3, S = 0;Q % _2n3 === _0n3; Q /= _2n3, S++)
    ;
  for (Z = _2n3;Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++) {
    if (Z > 1000)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b);m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n3);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n3), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n3)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n3)
    return f.ONE;
  if (power === _1n3)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      return isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n3, _1n3, _2n3, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;
var init_modular = __esm(() => {
  init_utils3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n3 = BigInt(0);
  _1n3 = BigInt(1);
  _2n3 = /* @__PURE__ */ BigInt(2);
  _3n = /* @__PURE__ */ BigInt(3);
  _4n = /* @__PURE__ */ BigInt(4);
  _5n = /* @__PURE__ */ BigInt(5);
  _8n = /* @__PURE__ */ BigInt(8);
  _9n = /* @__PURE__ */ BigInt(9);
  _16n = /* @__PURE__ */ BigInt(16);
  FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
});

// ../../../node_modules/viem/node_modules/@noble/curves/esm/abstract/curve.js
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, bits) {
  validateW(W, bits);
  const windows = Math.ceil(bits / W) + 1;
  const windowSize = 2 ** (W - 1);
  return { windows, windowSize };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    unsafeLadder(elm, n, p = c.ZERO) {
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1;i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = calcWOpts(W, bits);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        if (n === _0n4)
          break;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        if (wbits === 0)
          continue;
        let curr = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          curr = curr.negate();
        acc = acc.add(curr);
      }
      return acc;
    },
    getPrecomputes(W, P, transform) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return comp;
    },
    wNAFCached(P, n, transform) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
    },
    wNAFCachedUnsafe(P, n, transform, prev) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
    },
    setWindowSize(P, W) {
      validateW(W, bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits;i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0;j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero;j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0;j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
var _0n4, _1n4, pointPrecomputes, pointWindowSizes;
var init_curve = __esm(() => {
  init_modular();
  init_utils3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n4 = BigInt(0);
  _1n4 = BigInt(1);
  pointPrecomputes = new WeakMap;
  pointWindowSizes = new WeakMap;
});

// ../../../node_modules/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== undefined)
    abool("lowS", opts.lowS);
  if (opts.prehash !== undefined)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes3(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange(num, _1n5, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes2(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num = mod(num, N);
    aInRange("private key", num, _1n5, N);
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y, pz: z } = p;
    if (Fp.eql(z, Fp.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(z);
    const ax = Fp.mul(x, iz);
    const ay = Fp.mul(y, iz);
    const zz = Fp.mul(z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not FE");
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    if (!Fp.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });

  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp.eql(i, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    multiplyUnsafe(sc) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", sc, _0n5, N);
      const I = Point.ZERO;
      if (sc === _0n5)
        return I;
      if (this.is0() || sc === _1n5)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", scalar, _1n5, N);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? undefined : sum;
    }
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes3(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes3;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!inRange(x, _1n5, Fp.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n5;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));

  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      aInRange("r", this.r, _1n5, CURVE_ORDER);
      aInRange("s", this.s, _1n5, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes2(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
    return modN(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    aInRange("num < 2^" + CURVE.nBitLength, num, _0n5, ORDER_MASK);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes2(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes3(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n5)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== undefined && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex2 = typeof sg === "string" || isBytes2(sg);
    const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = undefined;
    let P;
    try {
      if (isObj)
        _sig = new Signature(sg.r, sg.s);
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio(Fp, Z) {
  const q = Fp.ORDER;
  let l = _0n5;
  for (let o = q - _1n5;o % _2n4 === _0n5; o /= _2n4)
    l += _1n5;
  const c1 = l;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c2 = (q - _1n5) / _2n_pow_c1;
  const c3 = (c2 - _1n5) / _2n4;
  const c4 = _2n_pow_c1 - _1n5;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp.pow(Z, c2);
  const c7 = Fp.pow(Z, (c2 + _1n5) / _2n4);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp.pow(v, c4);
    let tv3 = Fp.sqr(tv2);
    tv3 = Fp.mul(tv3, v);
    let tv5 = Fp.mul(u, tv3);
    tv5 = Fp.pow(tv5, c3);
    tv5 = Fp.mul(tv5, tv2);
    tv2 = Fp.mul(tv5, v);
    tv3 = Fp.mul(tv5, u);
    let tv4 = Fp.mul(tv3, tv2);
    tv5 = Fp.pow(tv4, c5);
    let isQR = Fp.eql(tv5, Fp.ONE);
    tv2 = Fp.mul(tv3, c7);
    tv5 = Fp.mul(tv4, tv1);
    tv3 = Fp.cmov(tv2, tv3, isQR);
    tv4 = Fp.cmov(tv5, tv4, isQR);
    for (let i = c1;i > _1n5; i--) {
      let tv52 = i - _2n4;
      tv52 = _2n4 << tv52 - _1n5;
      let tvv5 = Fp.pow(tv4, tv52);
      const e1 = Fp.eql(tvv5, Fp.ONE);
      tv2 = Fp.mul(tv3, tv1);
      tv1 = Fp.mul(tv1, tv1);
      tvv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, e1);
      tv4 = Fp.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp.ORDER % _4n2 === _3n2) {
    const c12 = (Fp.ORDER - _3n2) / _4n2;
    const c22 = Fp.sqrt(Fp.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp.sqr(v);
      const tv2 = Fp.mul(u, v);
      tv1 = Fp.mul(tv1, tv2);
      let y1 = Fp.pow(tv1, c12);
      y1 = Fp.mul(y1, tv2);
      const y2 = Fp.mul(y1, c22);
      const tv3 = Fp.mul(Fp.sqr(y1), v);
      const isQR = Fp.eql(tv3, u);
      let y = Fp.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
  validateField(Fp);
  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
  if (!Fp.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp.sqr(u);
    tv1 = Fp.mul(tv1, opts.Z);
    tv2 = Fp.sqr(tv1);
    tv2 = Fp.add(tv2, tv1);
    tv3 = Fp.add(tv2, Fp.ONE);
    tv3 = Fp.mul(tv3, opts.B);
    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
    tv4 = Fp.mul(tv4, opts.A);
    tv2 = Fp.sqr(tv3);
    tv6 = Fp.sqr(tv4);
    tv5 = Fp.mul(tv6, opts.A);
    tv2 = Fp.add(tv2, tv5);
    tv2 = Fp.mul(tv2, tv3);
    tv6 = Fp.mul(tv6, tv4);
    tv5 = Fp.mul(tv6, opts.B);
    tv2 = Fp.add(tv2, tv5);
    x = Fp.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp.mul(tv1, u);
    y = Fp.mul(y, value);
    x = Fp.cmov(x, tv3, isValid);
    y = Fp.cmov(y, value, isValid);
    const e1 = Fp.isOdd(u) === Fp.isOdd(y);
    y = Fp.cmov(Fp.neg(y), y, e1);
    x = Fp.div(x, tv4);
    return { x, y };
  };
}
var b2n, h2b, DERErr, DER, _0n5, _1n5, _2n4, _3n2, _4n2;
var init_weierstrass = __esm(() => {
  init_curve();
  init_modular();
  init_utils3();
  init_utils3();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  ({ bytesToNumberBE: b2n, hexToBytes: h2b } = exports_utils);
  DERErr = class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  };
  DER = {
    Err: DERErr,
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
        const t = numberToHexUnpadded(tag);
        return t + lenLen + len + data;
      },
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong)
          length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length = length << 8 | b;
          pos += lenLen;
          if (length < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length);
        if (v.length !== length)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length) };
      }
    },
    _int: {
      encode(num) {
        const { Err: E } = DER;
        if (num < _0n5)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return b2n(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      abytes2(data);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  _0n5 = BigInt(0);
  _1n5 = BigInt(1);
  _2n4 = BigInt(2);
  _3n2 = BigInt(3);
  _4n2 = BigInt(4);
});

// ../../../node_modules/viem/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return { ...create(defHash), create };
}
var init__shortw_utils = __esm(() => {
  init_hmac();
  init_utils2();
  init_weierstrass();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
});

// ../../../node_modules/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1;i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0;i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes3(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes3(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes3(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes3(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1;i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes3(...args));
  }
  const pseudo_random_bytes = concatBytes3(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes2(msg);
  abytes2(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash2, expand, DST: _DST } = options;
  abytes2(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes2(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0;i < count; i++) {
    const e = new Array(m);
    for (let j = 0;j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point.fromAffine(mapToCurve(u[0]));
      const u1 = Point.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    },
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("mapToCurve: expected array of bigints");
      const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}
var os2ip;
var init_hash_to_curve = __esm(() => {
  init_modular();
  init_utils3();
  os2ip = bytesToNumberBE;
});

// ../../../node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js
var exports_secp256k1 = {};
__export(exports_secp256k1, {
  secp256k1: () => secp256k1,
  schnorr: () => schnorr,
  hashToCurve: () => hashToCurve,
  encodeToCurve: () => encodeToCurve
});
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === undefined) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes3(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes3(tagP, ...messages));
}
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  aInRange("x", x, _1n6, secp256k1P);
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n5 !== _0n6)
    y = modP(-y);
  const p = new Point(x, y, _1n6);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(num(rand));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n6, secp256k1P))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n6, secp256k1N))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var secp256k1P, secp256k1N, _1n6, _2n5, divNearest = (a, b) => (a + b / _2n5) / b, Fpk1, secp256k1, _0n6, TAGGED_HASH_PREFIXES, pointToBytes = (point) => point.toRawBytes(true).slice(1), numTo32b = (n) => numberToBytesBE(n, 32), modP = (x) => mod(x, secp256k1P), modN = (x) => mod(x, secp256k1N), Point, GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b), num, schnorr, isoMap, mapSWU, htf, hashToCurve, encodeToCurve;
var init_secp256k1 = __esm(() => {
  init_sha256();
  init_utils2();
  init__shortw_utils();
  init_hash_to_curve();
  init_modular();
  init_utils3();
  init_weierstrass();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  _1n6 = BigInt(1);
  _2n5 = BigInt(2);
  Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
  secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fpk1,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256);
  _0n6 = BigInt(0);
  TAGGED_HASH_PREFIXES = {};
  Point = secp256k1.ProjectivePoint;
  num = bytesToNumberBE;
  schnorr = /* @__PURE__ */ (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      taggedHash,
      mod
    }
  }))();
  isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((i) => i.map((j) => BigInt(j)))))();
  mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fpk1.create(BigInt("-11"))
  }))();
  htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha256
  }))();
  hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();
  encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();
});

// ../../../node_modules/viem/_esm/errors/node.js
var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
var init_node = __esm(() => {
  init_formatGwei();
  init_base();
  ExecutionRevertedError = class ExecutionRevertedError extends BaseError2 {
    constructor({ cause, message } = {}) {
      const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
      super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
        cause,
        name: "ExecutionRevertedError"
      });
    }
  };
  Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
  });
  Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
  });
  FeeCapTooHighError = class FeeCapTooHighError extends BaseError2 {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
        cause,
        name: "FeeCapTooHighError"
      });
    }
  };
  Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
  });
  FeeCapTooLowError = class FeeCapTooLowError extends BaseError2 {
    constructor({ cause, maxFeePerGas } = {}) {
      super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
        cause,
        name: "FeeCapTooLowError"
      });
    }
  };
  Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
  });
  NonceTooHighError = class NonceTooHighError extends BaseError2 {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
    }
  };
  Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
  });
  NonceTooLowError = class NonceTooLowError extends BaseError2 {
    constructor({ cause, nonce } = {}) {
      super([
        `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
      ].join(`
`), { cause, name: "NonceTooLowError" });
    }
  };
  Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
  });
  NonceMaxValueError = class NonceMaxValueError extends BaseError2 {
    constructor({ cause, nonce } = {}) {
      super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
    }
  };
  Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
  });
  InsufficientFundsError = class InsufficientFundsError extends BaseError2 {
    constructor({ cause } = {}) {
      super([
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
      ].join(`
`), {
        cause,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient."
        ],
        name: "InsufficientFundsError"
      });
    }
  };
  Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds|exceeds transaction sender account balance/
  });
  IntrinsicGasTooHighError = class IntrinsicGasTooHighError extends BaseError2 {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
        cause,
        name: "IntrinsicGasTooHighError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
  });
  IntrinsicGasTooLowError = class IntrinsicGasTooLowError extends BaseError2 {
    constructor({ cause, gas } = {}) {
      super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
        cause,
        name: "IntrinsicGasTooLowError"
      });
    }
  };
  Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
  });
  TransactionTypeNotSupportedError = class TransactionTypeNotSupportedError extends BaseError2 {
    constructor({ cause }) {
      super("The transaction type is not supported for this chain.", {
        cause,
        name: "TransactionTypeNotSupportedError"
      });
    }
  };
  Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
  });
  TipAboveFeeCapError = class TipAboveFeeCapError extends BaseError2 {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
      super([
        `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
      ].join(`
`), {
        cause,
        name: "TipAboveFeeCapError"
      });
    }
  };
  Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
  });
  UnknownNodeError = class UnknownNodeError extends BaseError2 {
    constructor({ cause }) {
      super(`An error occurred while executing: ${cause?.shortMessage}`, {
        cause,
        name: "UnknownNodeError"
      });
    }
  };
});

// ../../../node_modules/viem/_esm/utils/errors/getNodeError.js
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err instanceof BaseError2 ? err.walk((e) => e?.code === ExecutionRevertedError.code) : err;
  if (executionRevertedError instanceof BaseError2)
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
var init_getNodeError = __esm(() => {
  init_base();
  init_node();
});

// ../../../node_modules/viem/_esm/utils/formatters/extract.js
function extract(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key of keys) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}

// ../../../node_modules/viem/_esm/utils/formatters/formatter.js
function defineFormatter(type, format) {
  return ({ exclude, format: overrides }) => {
    return {
      exclude,
      format: (args) => {
        const formatted = format(args);
        if (exclude) {
          for (const key of exclude) {
            delete formatted[key];
          }
        }
        return {
          ...formatted,
          ...overrides(args)
        };
      },
      type
    };
  };
}

// ../../../node_modules/viem/_esm/utils/formatters/transactionRequest.js
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (typeof request.authorizationList !== "undefined")
    rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);
  if (typeof request.accessList !== "undefined")
    rpcRequest.accessList = request.accessList;
  if (typeof request.blobVersionedHashes !== "undefined")
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined") {
    if (typeof request.blobs[0] !== "string")
      rpcRequest.blobs = request.blobs.map((x) => bytesToHex(x));
    else
      rpcRequest.blobs = request.blobs;
  }
  if (typeof request.data !== "undefined")
    rpcRequest.data = request.data;
  if (typeof request.from !== "undefined")
    rpcRequest.from = request.from;
  if (typeof request.gas !== "undefined")
    rpcRequest.gas = numberToHex(request.gas);
  if (typeof request.gasPrice !== "undefined")
    rpcRequest.gasPrice = numberToHex(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request.nonce);
  if (typeof request.to !== "undefined")
    rpcRequest.to = request.to;
  if (typeof request.type !== "undefined")
    rpcRequest.type = rpcTransactionType[request.type];
  if (typeof request.value !== "undefined")
    rpcRequest.value = numberToHex(request.value);
  return rpcRequest;
}
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.contractAddress,
    r: authorization.r,
    s: authorization.s,
    chainId: numberToHex(authorization.chainId),
    nonce: numberToHex(authorization.nonce),
    ...typeof authorization.yParity !== "undefined" ? { yParity: numberToHex(authorization.yParity) } : {},
    ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: numberToHex(authorization.v) } : {}
  }));
}
var rpcTransactionType;
var init_transactionRequest = __esm(() => {
  init_toHex();
  rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2",
    eip4844: "0x3",
    eip7702: "0x4"
  };
});

// ../../../node_modules/viem/_esm/utils/stateOverride.js
function serializeStateMapping(stateMapping) {
  if (!stateMapping || stateMapping.length === 0)
    return;
  return stateMapping.reduce((acc, { slot, value }) => {
    if (slot.length !== 66)
      throw new InvalidBytesLengthError({
        size: slot.length,
        targetSize: 66,
        type: "hex"
      });
    if (value.length !== 66)
      throw new InvalidBytesLengthError({
        size: value.length,
        targetSize: 66,
        type: "hex"
      });
    acc[slot] = value;
    return acc;
  }, {});
}
function serializeAccountStateOverride(parameters) {
  const { balance, nonce, state, stateDiff, code } = parameters;
  const rpcAccountStateOverride = {};
  if (code !== undefined)
    rpcAccountStateOverride.code = code;
  if (balance !== undefined)
    rpcAccountStateOverride.balance = numberToHex(balance);
  if (nonce !== undefined)
    rpcAccountStateOverride.nonce = numberToHex(nonce);
  if (state !== undefined)
    rpcAccountStateOverride.state = serializeStateMapping(state);
  if (stateDiff !== undefined) {
    if (rpcAccountStateOverride.state)
      throw new StateAssignmentConflictError;
    rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
  }
  return rpcAccountStateOverride;
}
function serializeStateOverride(parameters) {
  if (!parameters)
    return;
  const rpcStateOverride = {};
  for (const { address, ...accountState } of parameters) {
    if (!isAddress(address, { strict: false }))
      throw new InvalidAddressError({ address });
    if (rpcStateOverride[address])
      throw new AccountStateConflictError({ address });
    rpcStateOverride[address] = serializeAccountStateOverride(accountState);
  }
  return rpcStateOverride;
}
var init_stateOverride2 = __esm(() => {
  init_address();
  init_data();
  init_stateOverride();
  init_isAddress();
  init_toHex();
});

// ../../../node_modules/viem/_esm/constants/number.js
var maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256;
var init_number = __esm(() => {
  maxInt8 = 2n ** (8n - 1n) - 1n;
  maxInt16 = 2n ** (16n - 1n) - 1n;
  maxInt24 = 2n ** (24n - 1n) - 1n;
  maxInt32 = 2n ** (32n - 1n) - 1n;
  maxInt40 = 2n ** (40n - 1n) - 1n;
  maxInt48 = 2n ** (48n - 1n) - 1n;
  maxInt56 = 2n ** (56n - 1n) - 1n;
  maxInt64 = 2n ** (64n - 1n) - 1n;
  maxInt72 = 2n ** (72n - 1n) - 1n;
  maxInt80 = 2n ** (80n - 1n) - 1n;
  maxInt88 = 2n ** (88n - 1n) - 1n;
  maxInt96 = 2n ** (96n - 1n) - 1n;
  maxInt104 = 2n ** (104n - 1n) - 1n;
  maxInt112 = 2n ** (112n - 1n) - 1n;
  maxInt120 = 2n ** (120n - 1n) - 1n;
  maxInt128 = 2n ** (128n - 1n) - 1n;
  maxInt136 = 2n ** (136n - 1n) - 1n;
  maxInt144 = 2n ** (144n - 1n) - 1n;
  maxInt152 = 2n ** (152n - 1n) - 1n;
  maxInt160 = 2n ** (160n - 1n) - 1n;
  maxInt168 = 2n ** (168n - 1n) - 1n;
  maxInt176 = 2n ** (176n - 1n) - 1n;
  maxInt184 = 2n ** (184n - 1n) - 1n;
  maxInt192 = 2n ** (192n - 1n) - 1n;
  maxInt200 = 2n ** (200n - 1n) - 1n;
  maxInt208 = 2n ** (208n - 1n) - 1n;
  maxInt216 = 2n ** (216n - 1n) - 1n;
  maxInt224 = 2n ** (224n - 1n) - 1n;
  maxInt232 = 2n ** (232n - 1n) - 1n;
  maxInt240 = 2n ** (240n - 1n) - 1n;
  maxInt248 = 2n ** (248n - 1n) - 1n;
  maxInt256 = 2n ** (256n - 1n) - 1n;
  minInt8 = -(2n ** (8n - 1n));
  minInt16 = -(2n ** (16n - 1n));
  minInt24 = -(2n ** (24n - 1n));
  minInt32 = -(2n ** (32n - 1n));
  minInt40 = -(2n ** (40n - 1n));
  minInt48 = -(2n ** (48n - 1n));
  minInt56 = -(2n ** (56n - 1n));
  minInt64 = -(2n ** (64n - 1n));
  minInt72 = -(2n ** (72n - 1n));
  minInt80 = -(2n ** (80n - 1n));
  minInt88 = -(2n ** (88n - 1n));
  minInt96 = -(2n ** (96n - 1n));
  minInt104 = -(2n ** (104n - 1n));
  minInt112 = -(2n ** (112n - 1n));
  minInt120 = -(2n ** (120n - 1n));
  minInt128 = -(2n ** (128n - 1n));
  minInt136 = -(2n ** (136n - 1n));
  minInt144 = -(2n ** (144n - 1n));
  minInt152 = -(2n ** (152n - 1n));
  minInt160 = -(2n ** (160n - 1n));
  minInt168 = -(2n ** (168n - 1n));
  minInt176 = -(2n ** (176n - 1n));
  minInt184 = -(2n ** (184n - 1n));
  minInt192 = -(2n ** (192n - 1n));
  minInt200 = -(2n ** (200n - 1n));
  minInt208 = -(2n ** (208n - 1n));
  minInt216 = -(2n ** (216n - 1n));
  minInt224 = -(2n ** (224n - 1n));
  minInt232 = -(2n ** (232n - 1n));
  minInt240 = -(2n ** (240n - 1n));
  minInt248 = -(2n ** (248n - 1n));
  minInt256 = -(2n ** (256n - 1n));
  maxUint8 = 2n ** 8n - 1n;
  maxUint16 = 2n ** 16n - 1n;
  maxUint24 = 2n ** 24n - 1n;
  maxUint32 = 2n ** 32n - 1n;
  maxUint40 = 2n ** 40n - 1n;
  maxUint48 = 2n ** 48n - 1n;
  maxUint56 = 2n ** 56n - 1n;
  maxUint64 = 2n ** 64n - 1n;
  maxUint72 = 2n ** 72n - 1n;
  maxUint80 = 2n ** 80n - 1n;
  maxUint88 = 2n ** 88n - 1n;
  maxUint96 = 2n ** 96n - 1n;
  maxUint104 = 2n ** 104n - 1n;
  maxUint112 = 2n ** 112n - 1n;
  maxUint120 = 2n ** 120n - 1n;
  maxUint128 = 2n ** 128n - 1n;
  maxUint136 = 2n ** 136n - 1n;
  maxUint144 = 2n ** 144n - 1n;
  maxUint152 = 2n ** 152n - 1n;
  maxUint160 = 2n ** 160n - 1n;
  maxUint168 = 2n ** 168n - 1n;
  maxUint176 = 2n ** 176n - 1n;
  maxUint184 = 2n ** 184n - 1n;
  maxUint192 = 2n ** 192n - 1n;
  maxUint200 = 2n ** 200n - 1n;
  maxUint208 = 2n ** 208n - 1n;
  maxUint216 = 2n ** 216n - 1n;
  maxUint224 = 2n ** 224n - 1n;
  maxUint232 = 2n ** 232n - 1n;
  maxUint240 = 2n ** 240n - 1n;
  maxUint248 = 2n ** 248n - 1n;
  maxUint256 = 2n ** 256n - 1n;
});

// ../../../node_modules/viem/_esm/utils/transaction/assertRequest.js
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError;
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
var init_assertRequest = __esm(() => {
  init_number();
  init_address();
  init_node();
  init_transaction();
  init_isAddress();
});

// ../../../node_modules/viem/_esm/utils/address/isAddressEqual.js
function isAddressEqual(a, b) {
  if (!isAddress(a, { strict: false }))
    throw new InvalidAddressError({ address: a });
  if (!isAddress(b, { strict: false }))
    throw new InvalidAddressError({ address: b });
  return a.toLowerCase() === b.toLowerCase();
}
var init_isAddressEqual = __esm(() => {
  init_address();
  init_isAddress();
});

// ../../../node_modules/viem/_esm/utils/abi/decodeFunctionResult.js
function decodeFunctionResult(parameters) {
  const { abi, args, functionName, data } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({ abi, args, name: functionName });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath4 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
  const values = decodeAbiParameters(abiItem.outputs, data);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return;
}
var docsPath4 = "/docs/contract/decodeFunctionResult";
var init_decodeFunctionResult = __esm(() => {
  init_abi();
  init_decodeAbiParameters();
  init_getAbiItem();
});

// ../../../node_modules/viem/_esm/constants/abis.js
var multicall3Abi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi, textResolverAbi, addressResolverAbi, universalSignatureValidatorAbi;
var init_abis = __esm(() => {
  multicall3Abi = [
    {
      inputs: [
        {
          components: [
            {
              name: "target",
              type: "address"
            },
            {
              name: "allowFailure",
              type: "bool"
            },
            {
              name: "callData",
              type: "bytes"
            }
          ],
          name: "calls",
          type: "tuple[]"
        }
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            {
              name: "success",
              type: "bool"
            },
            {
              name: "returnData",
              type: "bytes"
            }
          ],
          name: "returnData",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ];
  universalResolverErrors = [
    {
      inputs: [],
      name: "ResolverNotFound",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverWildcardNotSupported",
      type: "error"
    },
    {
      inputs: [],
      name: "ResolverNotContract",
      type: "error"
    },
    {
      inputs: [
        {
          name: "returnData",
          type: "bytes"
        }
      ],
      name: "ResolverError",
      type: "error"
    },
    {
      inputs: [
        {
          components: [
            {
              name: "status",
              type: "uint16"
            },
            {
              name: "message",
              type: "string"
            }
          ],
          name: "errors",
          type: "tuple[]"
        }
      ],
      name: "HttpError",
      type: "error"
    }
  ];
  universalResolverResolveAbi = [
    ...universalResolverErrors,
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    },
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" },
        { name: "gateways", type: "string[]" }
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" }
      ]
    }
  ];
  universalResolverReverseAbi = [
    ...universalResolverErrors,
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [{ type: "bytes", name: "reverseName" }],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    },
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [
        { type: "bytes", name: "reverseName" },
        { type: "string[]", name: "gateways" }
      ],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" }
      ]
    }
  ];
  textResolverAbi = [
    {
      name: "text",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "key", type: "string" }
      ],
      outputs: [{ name: "", type: "string" }]
    }
  ];
  addressResolverAbi = [
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [{ name: "name", type: "bytes32" }],
      outputs: [{ name: "", type: "address" }]
    },
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "coinType", type: "uint256" }
      ],
      outputs: [{ name: "", type: "bytes" }]
    }
  ];
  universalSignatureValidatorAbi = [
    {
      inputs: [
        {
          name: "_signer",
          type: "address"
        },
        {
          name: "_hash",
          type: "bytes32"
        },
        {
          name: "_signature",
          type: "bytes"
        }
      ],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      inputs: [
        {
          name: "_signer",
          type: "address"
        },
        {
          name: "_hash",
          type: "bytes32"
        },
        {
          name: "_signature",
          type: "bytes"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function",
      name: "isValidSig"
    }
  ];
});

// ../../../node_modules/viem/_esm/constants/contract.js
var aggregate3Signature = "0x82ad56cb";

// ../../../node_modules/viem/_esm/constants/contracts.js
var deploylessCallViaBytecodeBytecode = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe", deploylessCallViaFactoryBytecode = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe", universalSignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

// ../../../node_modules/viem/_esm/errors/chain.js
var ChainDoesNotSupportContract, ClientChainNotConfiguredError, InvalidChainIdError;
var init_chain = __esm(() => {
  init_base();
  ChainDoesNotSupportContract = class ChainDoesNotSupportContract extends BaseError2 {
    constructor({ blockNumber, chain, contract }) {
      super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
        metaMessages: [
          "This could be due to any of the following:",
          ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
            `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
          ] : [
            `- The chain does not have the contract "${contract.name}" configured.`
          ]
        ],
        name: "ChainDoesNotSupportContract"
      });
    }
  };
  ClientChainNotConfiguredError = class ClientChainNotConfiguredError extends BaseError2 {
    constructor() {
      super("No chain was provided to the Client.", {
        name: "ClientChainNotConfiguredError"
      });
    }
  };
  InvalidChainIdError = class InvalidChainIdError extends BaseError2 {
    constructor({ chainId }) {
      super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
    }
  };
});

// ../../../node_modules/viem/_esm/utils/abi/encodeDeployData.js
function encodeDeployData(parameters) {
  const { abi, args, bytecode } = parameters;
  if (!args || args.length === 0)
    return bytecode;
  const description = abi.find((x) => ("type" in x) && x.type === "constructor");
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath5 });
  if (!("inputs" in description))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });
  const data = encodeAbiParameters(description.inputs, args);
  return concatHex([bytecode, data]);
}
var docsPath5 = "/docs/contract/encodeDeployData";
var init_encodeDeployData = __esm(() => {
  init_abi();
  init_encodeAbiParameters();
});

// ../../../node_modules/viem/_esm/utils/chain/getChainContractAddress.js
function getChainContractAddress({ blockNumber, chain, contract: name }) {
  const contract = chain?.contracts?.[name];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
var init_getChainContractAddress = __esm(() => {
  init_chain();
});

// ../../../node_modules/viem/_esm/utils/errors/getCallError.js
function getCallError(err, { docsPath: docsPath6, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath6,
    ...args
  });
}
var init_getCallError = __esm(() => {
  init_contract();
  init_node();
  init_getNodeError();
});

// ../../../node_modules/viem/_esm/utils/promise/withResolvers.js
function withResolvers() {
  let resolve = () => {
    return;
  };
  let reject = () => {
    return;
  };
  const promise = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return { promise, resolve, reject };
}

// ../../../node_modules/viem/_esm/utils/promise/createBatchScheduler.js
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort }) {
  const exec = async () => {
    const scheduler = getScheduler();
    flush();
    const args = scheduler.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data) => {
      if (sort && Array.isArray(data))
        data.sort(sort);
      for (let i = 0;i < scheduler.length; i++) {
        const { resolve } = scheduler[i];
        resolve?.([data[i], data]);
      }
    }).catch((err) => {
      for (let i = 0;i < scheduler.length; i++) {
        const { reject } = scheduler[i];
        reject?.(err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id) || [];
  const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const { promise, resolve, reject } = withResolvers();
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, resolve, reject });
        return promise;
      }
      setScheduler({ args, resolve, reject });
      setTimeout(exec, wait);
      return promise;
    }
  };
}
var schedulerCache;
var init_createBatchScheduler = __esm(() => {
  schedulerCache = /* @__PURE__ */ new Map;
});

// ../../../node_modules/viem/_esm/errors/ccip.js
var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
var init_ccip = __esm(() => {
  init_base();
  OffchainLookupError = class OffchainLookupError extends BaseError2 {
    constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
      super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
        cause,
        metaMessages: [
          ...cause.metaMessages || [],
          cause.metaMessages?.length ? "" : [],
          "Offchain Gateway Call:",
          urls && [
            "  Gateway URL(s):",
            ...urls.map((url) => `    ${getUrl(url)}`)
          ],
          `  Sender: ${sender}`,
          `  Data: ${data}`,
          `  Callback selector: ${callbackSelector}`,
          `  Extra data: ${extraData}`
        ].flat(),
        name: "OffchainLookupError"
      });
    }
  };
  OffchainLookupResponseMalformedError = class OffchainLookupResponseMalformedError extends BaseError2 {
    constructor({ result, url }) {
      super("Offchain gateway response is malformed. Response data must be a hex value.", {
        metaMessages: [
          `Gateway URL: ${getUrl(url)}`,
          `Response: ${stringify(result)}`
        ],
        name: "OffchainLookupResponseMalformedError"
      });
    }
  };
  OffchainLookupSenderMismatchError = class OffchainLookupSenderMismatchError extends BaseError2 {
    constructor({ sender, to }) {
      super("Reverted sender address does not match target contract address (`to`).", {
        metaMessages: [
          `Contract address: ${to}`,
          `OffchainLookup sender address: ${sender}`
        ],
        name: "OffchainLookupSenderMismatchError"
      });
    }
  };
});

// ../../../node_modules/viem/_esm/utils/ccip.js
var exports_ccip = {};
__export(exports_ccip, {
  offchainLookupSignature: () => offchainLookupSignature,
  offchainLookupAbiItem: () => offchainLookupAbiItem,
  offchainLookup: () => offchainLookup,
  ccipRequest: () => ccipRequest
});
async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
  const { args } = decodeErrorResult({
    data,
    abi: [offchainLookupAbiItem]
  });
  const [sender, urls, callData, callbackSelector, extraData] = args;
  const { ccipRead } = client;
  const ccipRequest_ = ccipRead && typeof ccipRead?.request === "function" ? ccipRead.request : ccipRequest;
  try {
    if (!isAddressEqual(to, sender))
      throw new OffchainLookupSenderMismatchError({ sender, to });
    const result = await ccipRequest_({ data: callData, sender, urls });
    const { data: data_ } = await call(client, {
      blockNumber,
      blockTag,
      data: concat([
        callbackSelector,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
      ]),
      to
    });
    return data_;
  } catch (err) {
    throw new OffchainLookupError({
      callbackSelector,
      cause: err,
      data,
      extraData,
      sender,
      urls
    });
  }
}
async function ccipRequest({ data, sender, urls }) {
  let error = new Error("An unknown error occurred.");
  for (let i = 0;i < urls.length; i++) {
    const url = urls[i];
    const method = url.includes("{data}") ? "GET" : "POST";
    const body = method === "POST" ? { data, sender } : undefined;
    const headers = method === "POST" ? { "Content-Type": "application/json" } : {};
    try {
      const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
        body: JSON.stringify(body),
        headers,
        method
      });
      let result;
      if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        result = (await response.json()).data;
      } else {
        result = await response.text();
      }
      if (!response.ok) {
        error = new HttpRequestError({
          body,
          details: result?.error ? stringify(result.error) : response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
        continue;
      }
      if (!isHex(result)) {
        error = new OffchainLookupResponseMalformedError({
          result,
          url
        });
        continue;
      }
      return result;
    } catch (err) {
      error = new HttpRequestError({
        body,
        details: err.message,
        url
      });
    }
  }
  throw error;
}
var offchainLookupSignature = "0x556f1830", offchainLookupAbiItem;
var init_ccip2 = __esm(() => {
  init_call();
  init_ccip();
  init_request();
  init_decodeErrorResult();
  init_encodeAbiParameters();
  init_isAddressEqual();
  offchainLookupAbiItem = {
    name: "OffchainLookup",
    type: "error",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "urls",
        type: "string[]"
      },
      {
        name: "callData",
        type: "bytes"
      },
      {
        name: "callbackFunction",
        type: "bytes4"
      },
      {
        name: "extraData",
        type: "bytes"
      }
    ]
  };
});

// ../../../node_modules/viem/_esm/actions/public/call.js
async function call(client, args) {
  const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, blobs, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  if (code && (factory || factoryData))
    throw new BaseError2("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (code && to)
    throw new BaseError2("Cannot provide both `code` & `to` as parameters.");
  const deploylessCallViaBytecode = code && data_;
  const deploylessCallViaFactory = factory && factoryData && to && data_;
  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
  const data = (() => {
    if (deploylessCallViaBytecode)
      return toDeploylessCallViaBytecodeData({
        code,
        data: data_
      });
    if (deploylessCallViaFactory)
      return toDeploylessCallViaFactoryData({
        data: data_,
        factory,
        factoryData,
        to
      });
    return data_;
  })();
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: deploylessCall ? undefined : to,
      value
    });
    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {
      try {
        return await scheduleMulticall(client, {
          ...request,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const response = await client.request({
      method: "eth_call",
      params: rpcStateOverride ? [
        request,
        block,
        rpcStateOverride
      ] : [request, block]
    });
    if (response === "0x")
      return { data: undefined };
    return { data: response };
  } catch (err) {
    const data2 = getRevertErrorData(err);
    const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), exports_ccip));
    if (client.ccipRead !== false && data2?.slice(0, 10) === offchainLookupSignature2 && to)
      return { data: await offchainLookup2(client, { data: data2, to }) };
    if (deploylessCall && data2?.slice(0, 10) === "0x101bb98d")
      throw new CounterfactualDeploymentFailedError({ factory });
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}
function shouldPerformMulticall({ request }) {
  const { data, to, ...request_ } = request;
  if (!data)
    return false;
  if (data.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client, args) {
  const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new ClientChainNotConfiguredError;
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const block = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client.uid}.${block}`,
    wait,
    shouldSplitBatch(args2) {
      const size2 = args2.reduce((size3, { data: data2 }) => size3 + (data2.length - 2), 0);
      return size2 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request) => ({
        allowFailure: true,
        callData: request.data,
        target: request.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data2 = await client.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data2 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: undefined };
  return { data: returnData };
}
function toDeploylessCallViaBytecodeData(parameters) {
  const { code, data } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(bytes, bytes)"]),
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [code, data]
  });
}
function toDeploylessCallViaFactoryData(parameters) {
  const { data, factory, factoryData, to } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(address, bytes, address, bytes)"]),
    bytecode: deploylessCallViaFactoryBytecode,
    args: [to, data, factory, factoryData]
  });
}
function getRevertErrorData(err) {
  if (!(err instanceof BaseError2))
    return;
  const error = err.walk();
  return typeof error?.data === "object" ? error.data?.data : error.data;
}
var init_call = __esm(() => {
  init_exports();
  init_abis();
  init_base();
  init_chain();
  init_contract();
  init_decodeFunctionResult();
  init_encodeDeployData();
  init_encodeFunctionData();
  init_getChainContractAddress();
  init_toHex();
  init_getCallError();
  init_transactionRequest();
  init_createBatchScheduler();
  init_stateOverride2();
  init_assertRequest();
});

// ../../../../../../../../../bun-vfs$$/node_modules/path/index.js
var exports_path = {};
__export(exports_path, {
  win32: () => y,
  toNamespacedPath: () => U,
  sep: () => I,
  resolve: () => B,
  relative: () => Q,
  posix: () => g,
  parse: () => $,
  normalize: () => G,
  join: () => K,
  isAbsolute: () => H,
  format: () => Z,
  extname: () => Y,
  dirname: () => V,
  delimiter: () => O,
  default: () => q,
  basename: () => X
});
var L, h, D, T, _, E, R = (s, e) => () => (e || s((e = { exports: {} }).exports, e), e.exports), N = (s, e, r, t) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of T(e))
      !E.call(s, i) && i !== r && h(s, i, { get: () => e[i], enumerable: !(t = D(e, i)) || t.enumerable });
  return s;
}, j = (s, e, r) => (r = s != null ? L(_(s)) : {}, N(e || !s || !s.__esModule ? h(r, "default", { value: s, enumerable: true }) : r, s)), k, x, u, J, P = function(s) {
  return s;
}, S = function() {
  throw new Error("Not implemented");
}, g, y, q, B, G, H, K, Q, U, V, X, Y, Z, $, I, O;
var init_path = __esm(() => {
  L = Object.create;
  h = Object.defineProperty;
  D = Object.getOwnPropertyDescriptor;
  T = Object.getOwnPropertyNames;
  _ = Object.getPrototypeOf;
  E = Object.prototype.hasOwnProperty;
  k = R((W, w) => {
    function v(s) {
      if (typeof s != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(s));
    }
    function C(s, e) {
      for (var r = "", t = 0, i = -1, a = 0, n, l = 0;l <= s.length; ++l) {
        if (l < s.length)
          n = s.charCodeAt(l);
        else {
          if (n === 47)
            break;
          n = 47;
        }
        if (n === 47) {
          if (!(i === l - 1 || a === 1))
            if (i !== l - 1 && a === 2) {
              if (r.length < 2 || t !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                if (r.length > 2) {
                  var f = r.lastIndexOf("/");
                  if (f !== r.length - 1) {
                    f === -1 ? (r = "", t = 0) : (r = r.slice(0, f), t = r.length - 1 - r.lastIndexOf("/")), i = l, a = 0;
                    continue;
                  }
                } else if (r.length === 2 || r.length === 1) {
                  r = "", t = 0, i = l, a = 0;
                  continue;
                }
              }
              e && (r.length > 0 ? r += "/.." : r = "..", t = 2);
            } else
              r.length > 0 ? r += "/" + s.slice(i + 1, l) : r = s.slice(i + 1, l), t = l - i - 1;
          i = l, a = 0;
        } else
          n === 46 && a !== -1 ? ++a : a = -1;
      }
      return r;
    }
    function F(s, e) {
      var r = e.dir || e.root, t = e.base || (e.name || "") + (e.ext || "");
      return r ? r === e.root ? r + t : r + s + t : t;
    }
    var m = { resolve: function() {
      for (var e = "", r = false, t, i = arguments.length - 1;i >= -1 && !r; i--) {
        var a;
        i >= 0 ? a = arguments[i] : (t === undefined && (t = process.cwd()), a = t), v(a), a.length !== 0 && (e = a + "/" + e, r = a.charCodeAt(0) === 47);
      }
      return e = C(e, !r), r ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
    }, normalize: function(e) {
      if (v(e), e.length === 0)
        return ".";
      var r = e.charCodeAt(0) === 47, t = e.charCodeAt(e.length - 1) === 47;
      return e = C(e, !r), e.length === 0 && !r && (e = "."), e.length > 0 && t && (e += "/"), r ? "/" + e : e;
    }, isAbsolute: function(e) {
      return v(e), e.length > 0 && e.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var e, r = 0;r < arguments.length; ++r) {
        var t = arguments[r];
        v(t), t.length > 0 && (e === undefined ? e = t : e += "/" + t);
      }
      return e === undefined ? "." : m.normalize(e);
    }, relative: function(e, r) {
      if (v(e), v(r), e === r || (e = m.resolve(e), r = m.resolve(r), e === r))
        return "";
      for (var t = 1;t < e.length && e.charCodeAt(t) === 47; ++t)
        ;
      for (var i = e.length, a = i - t, n = 1;n < r.length && r.charCodeAt(n) === 47; ++n)
        ;
      for (var l = r.length, f = l - n, c = a < f ? a : f, d = -1, o = 0;o <= c; ++o) {
        if (o === c) {
          if (f > c) {
            if (r.charCodeAt(n + o) === 47)
              return r.slice(n + o + 1);
            if (o === 0)
              return r.slice(n + o);
          } else
            a > c && (e.charCodeAt(t + o) === 47 ? d = o : o === 0 && (d = 0));
          break;
        }
        var A = e.charCodeAt(t + o), z = r.charCodeAt(n + o);
        if (A !== z)
          break;
        A === 47 && (d = o);
      }
      var b = "";
      for (o = t + d + 1;o <= i; ++o)
        (o === i || e.charCodeAt(o) === 47) && (b.length === 0 ? b += ".." : b += "/..");
      return b.length > 0 ? b + r.slice(n + d) : (n += d, r.charCodeAt(n) === 47 && ++n, r.slice(n));
    }, _makeLong: function(e) {
      return e;
    }, dirname: function(e) {
      if (v(e), e.length === 0)
        return ".";
      for (var r = e.charCodeAt(0), t = r === 47, i = -1, a = true, n = e.length - 1;n >= 1; --n)
        if (r = e.charCodeAt(n), r === 47) {
          if (!a) {
            i = n;
            break;
          }
        } else
          a = false;
      return i === -1 ? t ? "/" : "." : t && i === 1 ? "//" : e.slice(0, i);
    }, basename: function(e, r) {
      if (r !== undefined && typeof r != "string")
        throw new TypeError('"ext" argument must be a string');
      v(e);
      var t = 0, i = -1, a = true, n;
      if (r !== undefined && r.length > 0 && r.length <= e.length) {
        if (r.length === e.length && r === e)
          return "";
        var l = r.length - 1, f = -1;
        for (n = e.length - 1;n >= 0; --n) {
          var c = e.charCodeAt(n);
          if (c === 47) {
            if (!a) {
              t = n + 1;
              break;
            }
          } else
            f === -1 && (a = false, f = n + 1), l >= 0 && (c === r.charCodeAt(l) ? --l === -1 && (i = n) : (l = -1, i = f));
        }
        return t === i ? i = f : i === -1 && (i = e.length), e.slice(t, i);
      } else {
        for (n = e.length - 1;n >= 0; --n)
          if (e.charCodeAt(n) === 47) {
            if (!a) {
              t = n + 1;
              break;
            }
          } else
            i === -1 && (a = false, i = n + 1);
        return i === -1 ? "" : e.slice(t, i);
      }
    }, extname: function(e) {
      v(e);
      for (var r = -1, t = 0, i = -1, a = true, n = 0, l = e.length - 1;l >= 0; --l) {
        var f = e.charCodeAt(l);
        if (f === 47) {
          if (!a) {
            t = l + 1;
            break;
          }
          continue;
        }
        i === -1 && (a = false, i = l + 1), f === 46 ? r === -1 ? r = l : n !== 1 && (n = 1) : r !== -1 && (n = -1);
      }
      return r === -1 || i === -1 || n === 0 || n === 1 && r === i - 1 && r === t + 1 ? "" : e.slice(r, i);
    }, format: function(e) {
      if (e === null || typeof e != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
      return F("/", e);
    }, parse: function(e) {
      v(e);
      var r = { root: "", dir: "", base: "", ext: "", name: "" };
      if (e.length === 0)
        return r;
      var t = e.charCodeAt(0), i = t === 47, a;
      i ? (r.root = "/", a = 1) : a = 0;
      for (var n = -1, l = 0, f = -1, c = true, d = e.length - 1, o = 0;d >= a; --d) {
        if (t = e.charCodeAt(d), t === 47) {
          if (!c) {
            l = d + 1;
            break;
          }
          continue;
        }
        f === -1 && (c = false, f = d + 1), t === 46 ? n === -1 ? n = d : o !== 1 && (o = 1) : n !== -1 && (o = -1);
      }
      return n === -1 || f === -1 || o === 0 || o === 1 && n === f - 1 && n === l + 1 ? f !== -1 && (l === 0 && i ? r.base = r.name = e.slice(1, f) : r.base = r.name = e.slice(l, f)) : (l === 0 && i ? (r.name = e.slice(1, n), r.base = e.slice(1, f)) : (r.name = e.slice(l, n), r.base = e.slice(l, f)), r.ext = e.slice(n, f)), l > 0 ? r.dir = e.slice(0, l - 1) : i && (r.dir = "/"), r;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    m.posix = m;
    w.exports = m;
  });
  x = j(k());
  u = x;
  J = x;
  u.parse ??= S;
  J.parse ??= S;
  g = { resolve: u.resolve.bind(u), normalize: u.normalize.bind(u), isAbsolute: u.isAbsolute.bind(u), join: u.join.bind(u), relative: u.relative.bind(u), toNamespacedPath: P, dirname: u.dirname.bind(u), basename: u.basename.bind(u), extname: u.extname.bind(u), format: u.format.bind(u), parse: u.parse.bind(u), sep: "/", delimiter: ":", win32: undefined, posix: undefined, _makeLong: P };
  y = { sep: "\\", delimiter: ";", win32: undefined, ...g, posix: g };
  g.win32 = y.win32 = y;
  g.posix = g;
  q = g;
  ({ resolve: B, normalize: G, isAbsolute: H, join: K, relative: Q, toNamespacedPath: U, dirname: V, basename: X, extname: Y, format: Z, parse: $, sep: I, delimiter: O } = g);
});

// ../../../../../../../../../bun-vfs$$/node_modules/os/index.js
var exports_os = {};
__export(exports_os, {
  uptime: () => A,
  type: () => V2,
  totalmem: () => N2,
  tmpdir: () => U2,
  release: () => x2,
  platform: () => O2,
  networkInterfaces: () => j2,
  loadavg: () => y2,
  hostname: () => k2,
  homedir: () => _2,
  getNetworkInterfaces: () => B2,
  freemem: () => I2,
  endianness: () => L2,
  default: () => E2,
  cpus: () => b,
  arch: () => M,
  EOL: () => X2
});
var c, a, m, s, p, d, l = (r, n) => () => (n || r((n = { exports: {} }).exports, n), n.exports), h2 = (r, n, t, i) => {
  if (n && typeof n == "object" || typeof n == "function")
    for (let o of s(n))
      !d.call(r, o) && o !== t && a(r, o, { get: () => n[o], enumerable: !(i = m(n, o)) || i.enumerable });
  return r;
}, g2 = (r, n, t) => (t = r != null ? c(p(r)) : {}, h2(n || !r || !r.__esModule ? a(t, "default", { value: r, enumerable: true }) : t, r)), f, u2, E2, L2, k2, y2, A, I2, N2, b, V2, x2, M, O2, U2, X2, _2, j2, B2;
var init_os = __esm(() => {
  c = Object.create;
  a = Object.defineProperty;
  m = Object.getOwnPropertyDescriptor;
  s = Object.getOwnPropertyNames;
  p = Object.getPrototypeOf;
  d = Object.prototype.hasOwnProperty;
  f = l((e) => {
    e.endianness = function() {
      return "LE";
    };
    e.hostname = function() {
      return typeof location < "u" ? location.hostname : "";
    };
    e.loadavg = function() {
      return [];
    };
    e.uptime = function() {
      return 0;
    };
    e.freemem = function() {
      return Number.MAX_VALUE;
    };
    e.totalmem = function() {
      return Number.MAX_VALUE;
    };
    e.cpus = function() {
      return [];
    };
    e.type = function() {
      return "Browser";
    };
    e.release = function() {
      return typeof navigator < "u" ? navigator.appVersion : "";
    };
    e.networkInterfaces = e.getNetworkInterfaces = function() {
      return {};
    };
    e.arch = function() {
      return "javascript";
    };
    e.platform = function() {
      return "browser";
    };
    e.tmpdir = e.tmpDir = function() {
      return "/tmp";
    };
    e.EOL = `
`;
    e.homedir = function() {
      return "/";
    };
  });
  u2 = g2(f());
  E2 = u2.default;
  ({ endianness: L2, hostname: k2, loadavg: y2, uptime: A, freemem: I2, totalmem: N2, cpus: b, type: V2, release: x2, arch: M, platform: O2, tmpdir: U2, EOL: X2, homedir: _2, networkInterfaces: j2, getNetworkInterfaces: B2 } = u2.default);
});

// ../../../../../../../../../bun-vfs$$/node_modules/crypto/index.js
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => cw,
  timingSafeEqual: () => x0,
  scryptSync: () => Id,
  scrypt: () => Td,
  randomUUID: () => lw,
  getRandomValues: () => uw,
  getCurves: () => dw,
  default: () => Wq,
  DEFAULT_ENCODING: () => Ga
});
function dw() {
  return Hq;
}
var pw, Xa, vw, bw, mw, gw, R0 = (t, e) => () => (t && (e = t(t = 0)), e), T2 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Ja = (t, e) => {
  for (var r in e)
    Xa(t, r, { get: e[r], enumerable: true });
}, Ya = (t, e, r, o) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let f2 of bw(e))
      !gw.call(t, f2) && f2 !== r && Xa(t, f2, { get: () => e[f2], enumerable: !(o = vw(e, f2)) || o.enumerable });
  return t;
}, ot = (t, e, r) => (Ya(t, e, "default"), r && Ya(r, e, "default")), rn = (t, e, r) => (r = t != null ? pw(mw(t)) : {}, Ya(e || !t || !t.__esModule ? Xa(r, "default", { value: t, enumerable: true }) : r, t)), ur = (t) => Ya(Xa({}, "__esModule", { value: true }), t), Nd, Dd, Ut, Te, on, Ie, ki, W0, $f, pc, Z0, sn, V0, G0, J0, hn, co, Jf, po, Qf, vo, Pc, Oc, th, ph, Qc, np, ap, bh, Ao, Bo, pn, _p, Ep, gh, qp, yh, Op, ko, Tt, Gr, No, Jt, pa, Rh, pr, Y_, Oi, Fi, Ui, k1, yn, Vo, Go, Z1, Xo, Fh, ba, Jh, Dv, Qr, fu, ou, os, eb, cu, lb, bu, vf, S7, db, yi, bf, wb, mu, wu, Mu, Eb, _u, xu, Eu, Au, Ub, Iu, Tu, ar, vs, ku, Yb, Qb, em, im, nm, yf, om, um, dm, pm, bm, Pu, Ou, Fu, ws, Aa, Em, Wu, ju, Ba, Dm, Fm, Es, Hm, Vm, ji, Yu, Ym, Xm, As, tl, ol, rg, ag, hg, hl, pg, dl, kn, cl, bl, Ln, Ds, Lg, Dg, yl, Il, Yg, t2, i2, Ws, Ks, s2, ri, Nl, or, Oa, b2, y22, _22, Pl, Cr, Tf, Cl, N22, Fl, F2, Wl, Z2, V22, Q2, ty, e0, ny, t0, uy, dy, vy, yy, xy, Ey, Iy, o0, td, h0, u0, Kf, d0, c0, nd, Hy, od, hd, Jy, dd, r3, n3, o3, cd, d3, p3, v3, m3, Ha, bd, _3, A3, k3, N3, P3, _d, xd, w0, Ed, j3, Y3, X3, ow, qd, Xt, zq, Ga = "buffer", uw = (t) => crypto.getRandomValues(t), lw = () => crypto.randomUUID(), Hq, x0, Id, Td, cw, Wq;
var init_crypto2 = __esm(() => {
  pw = Object.create;
  Xa = Object.defineProperty;
  vw = Object.getOwnPropertyDescriptor;
  bw = Object.getOwnPropertyNames;
  mw = Object.getPrototypeOf;
  gw = Object.prototype.hasOwnProperty;
  Nd = T2((Qa) => {
    Qa.byteLength = ww;
    Qa.toByteArray = _w;
    Qa.fromByteArray = Ew;
    var jr = [], lr = [], yw = typeof Uint8Array < "u" ? Uint8Array : Array, B0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (nn = 0, kd = B0.length;nn < kd; ++nn)
      jr[nn] = B0[nn], lr[B0.charCodeAt(nn)] = nn;
    var nn, kd;
    lr[45] = 62;
    lr[95] = 63;
    function Ld(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = t.indexOf("=");
      r === -1 && (r = e);
      var o = r === e ? 0 : 4 - r % 4;
      return [r, o];
    }
    function ww(t) {
      var e = Ld(t), r = e[0], o = e[1];
      return (r + o) * 3 / 4 - o;
    }
    function Mw(t, e, r) {
      return (e + r) * 3 / 4 - r;
    }
    function _w(t) {
      var e, r = Ld(t), o = r[0], f2 = r[1], p2 = new yw(Mw(t, o, f2)), m2 = 0, y3 = f2 > 0 ? o - 4 : o, M2;
      for (M2 = 0;M2 < y3; M2 += 4)
        e = lr[t.charCodeAt(M2)] << 18 | lr[t.charCodeAt(M2 + 1)] << 12 | lr[t.charCodeAt(M2 + 2)] << 6 | lr[t.charCodeAt(M2 + 3)], p2[m2++] = e >> 16 & 255, p2[m2++] = e >> 8 & 255, p2[m2++] = e & 255;
      return f2 === 2 && (e = lr[t.charCodeAt(M2)] << 2 | lr[t.charCodeAt(M2 + 1)] >> 4, p2[m2++] = e & 255), f2 === 1 && (e = lr[t.charCodeAt(M2)] << 10 | lr[t.charCodeAt(M2 + 1)] << 4 | lr[t.charCodeAt(M2 + 2)] >> 2, p2[m2++] = e >> 8 & 255, p2[m2++] = e & 255), p2;
    }
    function xw(t) {
      return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
    }
    function Sw(t, e, r) {
      for (var o, f2 = [], p2 = e;p2 < r; p2 += 3)
        o = (t[p2] << 16 & 16711680) + (t[p2 + 1] << 8 & 65280) + (t[p2 + 2] & 255), f2.push(xw(o));
      return f2.join("");
    }
    function Ew(t) {
      for (var e, r = t.length, o = r % 3, f2 = [], p2 = 16383, m2 = 0, y3 = r - o;m2 < y3; m2 += p2)
        f2.push(Sw(t, m2, m2 + p2 > y3 ? y3 : m2 + p2));
      return o === 1 ? (e = t[r - 1], f2.push(jr[e >> 2] + jr[e << 4 & 63] + "==")) : o === 2 && (e = (t[r - 2] << 8) + t[r - 1], f2.push(jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "=")), f2.join("");
    }
  });
  Dd = T2((q0) => {
    q0.read = function(t, e, r, o, f2) {
      var p2, m2, y3 = f2 * 8 - o - 1, M2 = (1 << y3) - 1, x3 = M2 >> 1, S2 = -7, E3 = r ? f2 - 1 : 0, B3 = r ? -1 : 1, q2 = t[e + E3];
      for (E3 += B3, p2 = q2 & (1 << -S2) - 1, q2 >>= -S2, S2 += y3;S2 > 0; p2 = p2 * 256 + t[e + E3], E3 += B3, S2 -= 8)
        ;
      for (m2 = p2 & (1 << -S2) - 1, p2 >>= -S2, S2 += o;S2 > 0; m2 = m2 * 256 + t[e + E3], E3 += B3, S2 -= 8)
        ;
      if (p2 === 0)
        p2 = 1 - x3;
      else {
        if (p2 === M2)
          return m2 ? NaN : (q2 ? -1 : 1) * (1 / 0);
        m2 = m2 + Math.pow(2, o), p2 = p2 - x3;
      }
      return (q2 ? -1 : 1) * m2 * Math.pow(2, p2 - o);
    };
    q0.write = function(t, e, r, o, f2, p2) {
      var m2, y3, M2, x3 = p2 * 8 - f2 - 1, S2 = (1 << x3) - 1, E3 = S2 >> 1, B3 = f2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q2 = o ? 0 : p2 - 1, L3 = o ? 1 : -1, ge = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y3 = isNaN(e) ? 1 : 0, m2 = S2) : (m2 = Math.floor(Math.log(e) / Math.LN2), e * (M2 = Math.pow(2, -m2)) < 1 && (m2--, M2 *= 2), m2 + E3 >= 1 ? e += B3 / M2 : e += B3 * Math.pow(2, 1 - E3), e * M2 >= 2 && (m2++, M2 /= 2), m2 + E3 >= S2 ? (y3 = 0, m2 = S2) : m2 + E3 >= 1 ? (y3 = (e * M2 - 1) * Math.pow(2, f2), m2 = m2 + E3) : (y3 = e * Math.pow(2, E3 - 1) * Math.pow(2, f2), m2 = 0));f2 >= 8; t[r + q2] = y3 & 255, q2 += L3, y3 /= 256, f2 -= 8)
        ;
      for (m2 = m2 << f2 | y3, x3 += f2;x3 > 0; t[r + q2] = m2 & 255, q2 += L3, m2 /= 256, x3 -= 8)
        ;
      t[r + q2 - L3] |= ge * 128;
    };
  });
  Ut = T2((Xn) => {
    var I0 = Nd(), Gn = Dd(), Pd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Xn.Buffer = me;
    Xn.SlowBuffer = Tw;
    Xn.INSPECT_MAX_BYTES = 50;
    var eo = 2147483647;
    Xn.kMaxLength = eo;
    me.TYPED_ARRAY_SUPPORT = Aw();
    !me.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Aw() {
      try {
        let t = new Uint8Array(1), e = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(me.prototype, "parent", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(me.prototype, "offset", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.byteOffset;
    } });
    function li(t) {
      if (t > eo)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      let e = new Uint8Array(t);
      return Object.setPrototypeOf(e, me.prototype), e;
    }
    function me(t, e, r) {
      if (typeof t == "number") {
        if (typeof e == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return N0(t);
      }
      return Ud(t, e, r);
    }
    me.poolSize = 8192;
    function Ud(t, e, r) {
      if (typeof t == "string")
        return Bw(t, e);
      if (ArrayBuffer.isView(t))
        return qw(t);
      if (t == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      if (Zr(t, ArrayBuffer) || t && Zr(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr(t, SharedArrayBuffer) || t && Zr(t.buffer, SharedArrayBuffer)))
        return k0(t, e, r);
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let o = t.valueOf && t.valueOf();
      if (o != null && o !== t)
        return me.from(o, e, r);
      let f2 = Iw(t);
      if (f2)
        return f2;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
        return me.from(t[Symbol.toPrimitive]("string"), e, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    me.from = function(t, e, r) {
      return Ud(t, e, r);
    };
    Object.setPrototypeOf(me.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(me, Uint8Array);
    function zd(t) {
      if (typeof t != "number")
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    function Rw(t, e, r) {
      return zd(t), t <= 0 ? li(t) : e !== undefined ? typeof r == "string" ? li(t).fill(e, r) : li(t).fill(e) : li(t);
    }
    me.alloc = function(t, e, r) {
      return Rw(t, e, r);
    };
    function N0(t) {
      return zd(t), li(t < 0 ? 0 : D0(t) | 0);
    }
    me.allocUnsafe = function(t) {
      return N0(t);
    };
    me.allocUnsafeSlow = function(t) {
      return N0(t);
    };
    function Bw(t, e) {
      if ((typeof e != "string" || e === "") && (e = "utf8"), !me.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      let r = Hd(t, e) | 0, o = li(r), f2 = o.write(t, e);
      return f2 !== r && (o = o.slice(0, f2)), o;
    }
    function T0(t) {
      let e = t.length < 0 ? 0 : D0(t.length) | 0, r = li(e);
      for (let o = 0;o < e; o += 1)
        r[o] = t[o] & 255;
      return r;
    }
    function qw(t) {
      if (Zr(t, Uint8Array)) {
        let e = new Uint8Array(t);
        return k0(e.buffer, e.byteOffset, e.byteLength);
      }
      return T0(t);
    }
    function k0(t, e, r) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let o;
      return e === undefined && r === undefined ? o = new Uint8Array(t) : r === undefined ? o = new Uint8Array(t, e) : o = new Uint8Array(t, e, r), Object.setPrototypeOf(o, me.prototype), o;
    }
    function Iw(t) {
      if (me.isBuffer(t)) {
        let e = D0(t.length) | 0, r = li(e);
        return r.length === 0 || t.copy(r, 0, 0, e), r;
      }
      if (t.length !== undefined)
        return typeof t.length != "number" || C0(t.length) ? li(0) : T0(t);
      if (t.type === "Buffer" && Array.isArray(t.data))
        return T0(t.data);
    }
    function D0(t) {
      if (t >= eo)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eo.toString(16) + " bytes");
      return t | 0;
    }
    function Tw(t) {
      return +t != t && (t = 0), me.alloc(+t);
    }
    me.isBuffer = function(e) {
      return e != null && e._isBuffer === true && e !== me.prototype;
    };
    me.compare = function(e, r) {
      if (Zr(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), Zr(r, Uint8Array) && (r = me.from(r, r.offset, r.byteLength)), !me.isBuffer(e) || !me.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e === r)
        return 0;
      let o = e.length, f2 = r.length;
      for (let p2 = 0, m2 = Math.min(o, f2);p2 < m2; ++p2)
        if (e[p2] !== r[p2]) {
          o = e[p2], f2 = r[p2];
          break;
        }
      return o < f2 ? -1 : f2 < o ? 1 : 0;
    };
    me.isEncoding = function(e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    me.concat = function(e, r) {
      if (!Array.isArray(e))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e.length === 0)
        return me.alloc(0);
      let o;
      if (r === undefined)
        for (r = 0, o = 0;o < e.length; ++o)
          r += e[o].length;
      let f2 = me.allocUnsafe(r), p2 = 0;
      for (o = 0;o < e.length; ++o) {
        let m2 = e[o];
        if (Zr(m2, Uint8Array))
          p2 + m2.length > f2.length ? (me.isBuffer(m2) || (m2 = me.from(m2)), m2.copy(f2, p2)) : Uint8Array.prototype.set.call(f2, m2, p2);
        else if (me.isBuffer(m2))
          m2.copy(f2, p2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        p2 += m2.length;
      }
      return f2;
    };
    function Hd(t, e) {
      if (me.isBuffer(t))
        return t.length;
      if (ArrayBuffer.isView(t) || Zr(t, ArrayBuffer))
        return t.byteLength;
      if (typeof t != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
      let r = t.length, o = arguments.length > 2 && arguments[2] === true;
      if (!o && r === 0)
        return 0;
      let f2 = false;
      for (;; )
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return L0(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return Xd(t).length;
          default:
            if (f2)
              return o ? -1 : L0(t).length;
            e = ("" + e).toLowerCase(), f2 = true;
        }
    }
    me.byteLength = Hd;
    function kw(t, e, r) {
      let o = false;
      if ((e === undefined || e < 0) && (e = 0), e > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
        return "";
      for (t || (t = "utf8");; )
        switch (t) {
          case "hex":
            return Hw(this, e, r);
          case "utf8":
          case "utf-8":
            return Kd(this, e, r);
          case "ascii":
            return Uw(this, e, r);
          case "latin1":
          case "binary":
            return zw(this, e, r);
          case "base64":
            return Ow(this, e, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ww(this, e, r);
          default:
            if (o)
              throw new TypeError("Unknown encoding: " + t);
            t = (t + "").toLowerCase(), o = true;
        }
    }
    me.prototype._isBuffer = true;
    function fn(t, e, r) {
      let o = t[e];
      t[e] = t[r], t[r] = o;
    }
    me.prototype.swap16 = function() {
      let e = this.length;
      if (e % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < e; r += 2)
        fn(this, r, r + 1);
      return this;
    };
    me.prototype.swap32 = function() {
      let e = this.length;
      if (e % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < e; r += 4)
        fn(this, r, r + 3), fn(this, r + 1, r + 2);
      return this;
    };
    me.prototype.swap64 = function() {
      let e = this.length;
      if (e % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < e; r += 8)
        fn(this, r, r + 7), fn(this, r + 1, r + 6), fn(this, r + 2, r + 5), fn(this, r + 3, r + 4);
      return this;
    };
    me.prototype.toString = function() {
      let e = this.length;
      return e === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e) : kw.apply(this, arguments);
    };
    me.prototype.toLocaleString = me.prototype.toString;
    me.prototype.equals = function(e) {
      if (!me.isBuffer(e))
        throw new TypeError("Argument must be a Buffer");
      return this === e ? true : me.compare(this, e) === 0;
    };
    me.prototype.inspect = function() {
      let e = "", r = Xn.INSPECT_MAX_BYTES;
      return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
    };
    Pd && (me.prototype[Pd] = me.prototype.inspect);
    me.prototype.compare = function(e, r, o, f2, p2) {
      if (Zr(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), !me.isBuffer(e))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
      if (r === undefined && (r = 0), o === undefined && (o = e ? e.length : 0), f2 === undefined && (f2 = 0), p2 === undefined && (p2 = this.length), r < 0 || o > e.length || f2 < 0 || p2 > this.length)
        throw new RangeError("out of range index");
      if (f2 >= p2 && r >= o)
        return 0;
      if (f2 >= p2)
        return -1;
      if (r >= o)
        return 1;
      if (r >>>= 0, o >>>= 0, f2 >>>= 0, p2 >>>= 0, this === e)
        return 0;
      let m2 = p2 - f2, y3 = o - r, M2 = Math.min(m2, y3), x3 = this.slice(f2, p2), S2 = e.slice(r, o);
      for (let E3 = 0;E3 < M2; ++E3)
        if (x3[E3] !== S2[E3]) {
          m2 = x3[E3], y3 = S2[E3];
          break;
        }
      return m2 < y3 ? -1 : y3 < m2 ? 1 : 0;
    };
    function Wd(t, e, r, o, f2) {
      if (t.length === 0)
        return -1;
      if (typeof r == "string" ? (o = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, C0(r) && (r = f2 ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
        if (f2)
          return -1;
        r = t.length - 1;
      } else if (r < 0)
        if (f2)
          r = 0;
        else
          return -1;
      if (typeof e == "string" && (e = me.from(e, o)), me.isBuffer(e))
        return e.length === 0 ? -1 : Cd(t, e, r, o, f2);
      if (typeof e == "number")
        return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? f2 ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Cd(t, [e], r, o, f2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Cd(t, e, r, o, f2) {
      let p2 = 1, m2 = t.length, y3 = e.length;
      if (o !== undefined && (o = String(o).toLowerCase(), o === "ucs2" || o === "ucs-2" || o === "utf16le" || o === "utf-16le")) {
        if (t.length < 2 || e.length < 2)
          return -1;
        p2 = 2, m2 /= 2, y3 /= 2, r /= 2;
      }
      function M2(S2, E3) {
        return p2 === 1 ? S2[E3] : S2.readUInt16BE(E3 * p2);
      }
      let x3;
      if (f2) {
        let S2 = -1;
        for (x3 = r;x3 < m2; x3++)
          if (M2(t, x3) === M2(e, S2 === -1 ? 0 : x3 - S2)) {
            if (S2 === -1 && (S2 = x3), x3 - S2 + 1 === y3)
              return S2 * p2;
          } else
            S2 !== -1 && (x3 -= x3 - S2), S2 = -1;
      } else
        for (r + y3 > m2 && (r = m2 - y3), x3 = r;x3 >= 0; x3--) {
          let S2 = true;
          for (let E3 = 0;E3 < y3; E3++)
            if (M2(t, x3 + E3) !== M2(e, E3)) {
              S2 = false;
              break;
            }
          if (S2)
            return x3;
        }
      return -1;
    }
    me.prototype.includes = function(e, r, o) {
      return this.indexOf(e, r, o) !== -1;
    };
    me.prototype.indexOf = function(e, r, o) {
      return Wd(this, e, r, o, true);
    };
    me.prototype.lastIndexOf = function(e, r, o) {
      return Wd(this, e, r, o, false);
    };
    function Lw(t, e, r, o) {
      r = Number(r) || 0;
      let f2 = t.length - r;
      o ? (o = Number(o), o > f2 && (o = f2)) : o = f2;
      let p2 = e.length;
      o > p2 / 2 && (o = p2 / 2);
      let m2;
      for (m2 = 0;m2 < o; ++m2) {
        let y3 = parseInt(e.substr(m2 * 2, 2), 16);
        if (C0(y3))
          return m2;
        t[r + m2] = y3;
      }
      return m2;
    }
    function Nw(t, e, r, o) {
      return to(L0(e, t.length - r), t, r, o);
    }
    function Dw(t, e, r, o) {
      return to(Vw(e), t, r, o);
    }
    function Pw(t, e, r, o) {
      return to(Xd(e), t, r, o);
    }
    function Cw(t, e, r, o) {
      return to($w(e, t.length - r), t, r, o);
    }
    me.prototype.write = function(e, r, o, f2) {
      if (r === undefined)
        f2 = "utf8", o = this.length, r = 0;
      else if (o === undefined && typeof r == "string")
        f2 = r, o = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(o) ? (o = o >>> 0, f2 === undefined && (f2 = "utf8")) : (f2 = o, o = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let p2 = this.length - r;
      if ((o === undefined || o > p2) && (o = p2), e.length > 0 && (o < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      f2 || (f2 = "utf8");
      let m2 = false;
      for (;; )
        switch (f2) {
          case "hex":
            return Lw(this, e, r, o);
          case "utf8":
          case "utf-8":
            return Nw(this, e, r, o);
          case "ascii":
          case "latin1":
          case "binary":
            return Dw(this, e, r, o);
          case "base64":
            return Pw(this, e, r, o);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Cw(this, e, r, o);
          default:
            if (m2)
              throw new TypeError("Unknown encoding: " + f2);
            f2 = ("" + f2).toLowerCase(), m2 = true;
        }
    };
    me.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Ow(t, e, r) {
      return e === 0 && r === t.length ? I0.fromByteArray(t) : I0.fromByteArray(t.slice(e, r));
    }
    function Kd(t, e, r) {
      r = Math.min(t.length, r);
      let o = [], f2 = e;
      for (;f2 < r; ) {
        let p2 = t[f2], m2 = null, y3 = p2 > 239 ? 4 : p2 > 223 ? 3 : p2 > 191 ? 2 : 1;
        if (f2 + y3 <= r) {
          let M2, x3, S2, E3;
          switch (y3) {
            case 1:
              p2 < 128 && (m2 = p2);
              break;
            case 2:
              M2 = t[f2 + 1], (M2 & 192) === 128 && (E3 = (p2 & 31) << 6 | M2 & 63, E3 > 127 && (m2 = E3));
              break;
            case 3:
              M2 = t[f2 + 1], x3 = t[f2 + 2], (M2 & 192) === 128 && (x3 & 192) === 128 && (E3 = (p2 & 15) << 12 | (M2 & 63) << 6 | x3 & 63, E3 > 2047 && (E3 < 55296 || E3 > 57343) && (m2 = E3));
              break;
            case 4:
              M2 = t[f2 + 1], x3 = t[f2 + 2], S2 = t[f2 + 3], (M2 & 192) === 128 && (x3 & 192) === 128 && (S2 & 192) === 128 && (E3 = (p2 & 15) << 18 | (M2 & 63) << 12 | (x3 & 63) << 6 | S2 & 63, E3 > 65535 && E3 < 1114112 && (m2 = E3));
          }
        }
        m2 === null ? (m2 = 65533, y3 = 1) : m2 > 65535 && (m2 -= 65536, o.push(m2 >>> 10 & 1023 | 55296), m2 = 56320 | m2 & 1023), o.push(m2), f2 += y3;
      }
      return Fw(o);
    }
    var Od = 4096;
    function Fw(t) {
      let e = t.length;
      if (e <= Od)
        return String.fromCharCode.apply(String, t);
      let r = "", o = 0;
      for (;o < e; )
        r += String.fromCharCode.apply(String, t.slice(o, o += Od));
      return r;
    }
    function Uw(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f2 = e;f2 < r; ++f2)
        o += String.fromCharCode(t[f2] & 127);
      return o;
    }
    function zw(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f2 = e;f2 < r; ++f2)
        o += String.fromCharCode(t[f2]);
      return o;
    }
    function Hw(t, e, r) {
      let o = t.length;
      (!e || e < 0) && (e = 0), (!r || r < 0 || r > o) && (r = o);
      let f2 = "";
      for (let p2 = e;p2 < r; ++p2)
        f2 += Gw[t[p2]];
      return f2;
    }
    function Ww(t, e, r) {
      let o = t.slice(e, r), f2 = "";
      for (let p2 = 0;p2 < o.length - 1; p2 += 2)
        f2 += String.fromCharCode(o[p2] + o[p2 + 1] * 256);
      return f2;
    }
    me.prototype.slice = function(e, r) {
      let o = this.length;
      e = ~~e, r = r === undefined ? o : ~~r, e < 0 ? (e += o, e < 0 && (e = 0)) : e > o && (e = o), r < 0 ? (r += o, r < 0 && (r = 0)) : r > o && (r = o), r < e && (r = e);
      let f2 = this.subarray(e, r);
      return Object.setPrototypeOf(f2, me.prototype), f2;
    };
    function Dt(t, e, r) {
      if (t % 1 !== 0 || t < 0)
        throw new RangeError("offset is not uint");
      if (t + e > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    me.prototype.readUintLE = me.prototype.readUIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f2 = this[e], p2 = 1, m2 = 0;
      for (;++m2 < r && (p2 *= 256); )
        f2 += this[e + m2] * p2;
      return f2;
    };
    me.prototype.readUintBE = me.prototype.readUIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f2 = this[e + --r], p2 = 1;
      for (;r > 0 && (p2 *= 256); )
        f2 += this[e + --r] * p2;
      return f2;
    };
    me.prototype.readUint8 = me.prototype.readUInt8 = function(e, r) {
      return e = e >>> 0, r || Dt(e, 1, this.length), this[e];
    };
    me.prototype.readUint16LE = me.prototype.readUInt16LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 2, this.length), this[e] | this[e + 1] << 8;
    };
    me.prototype.readUint16BE = me.prototype.readUInt16BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 2, this.length), this[e] << 8 | this[e + 1];
    };
    me.prototype.readUint32LE = me.prototype.readUInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    };
    me.prototype.readUint32BE = me.prototype.readUInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    };
    me.prototype.readBigUInt64LE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f2 = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, p2 = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + o * 2 ** 24;
      return BigInt(f2) + (BigInt(p2) << BigInt(32));
    });
    me.prototype.readBigUInt64BE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f2 = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], p2 = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o;
      return (BigInt(f2) << BigInt(32)) + BigInt(p2);
    });
    me.prototype.readIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f2 = this[e], p2 = 1, m2 = 0;
      for (;++m2 < r && (p2 *= 256); )
        f2 += this[e + m2] * p2;
      return p2 *= 128, f2 >= p2 && (f2 -= Math.pow(2, 8 * r)), f2;
    };
    me.prototype.readIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f2 = r, p2 = 1, m2 = this[e + --f2];
      for (;f2 > 0 && (p2 *= 256); )
        m2 += this[e + --f2] * p2;
      return p2 *= 128, m2 >= p2 && (m2 -= Math.pow(2, 8 * r)), m2;
    };
    me.prototype.readInt8 = function(e, r) {
      return e = e >>> 0, r || Dt(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    };
    me.prototype.readInt16LE = function(e, r) {
      e = e >>> 0, r || Dt(e, 2, this.length);
      let o = this[e] | this[e + 1] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt16BE = function(e, r) {
      e = e >>> 0, r || Dt(e, 2, this.length);
      let o = this[e + 1] | this[e] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    };
    me.prototype.readInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    };
    me.prototype.readBigInt64LE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f2 = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (o << 24);
      return (BigInt(f2) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    });
    me.prototype.readBigInt64BE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f2 = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
      return (BigInt(f2) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o);
    });
    me.prototype.readFloatLE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, true, 23, 4);
    };
    me.prototype.readFloatBE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, false, 23, 4);
    };
    me.prototype.readDoubleLE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, true, 52, 8);
    };
    me.prototype.readDoubleBE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, false, 52, 8);
    };
    function er(t, e, r, o, f2, p2) {
      if (!me.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > f2 || e < p2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + o > t.length)
        throw new RangeError("Index out of range");
    }
    me.prototype.writeUintLE = me.prototype.writeUIntLE = function(e, r, o, f2) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f2) {
        let y3 = Math.pow(2, 8 * o) - 1;
        er(this, e, r, o, y3, 0);
      }
      let p2 = 1, m2 = 0;
      for (this[r] = e & 255;++m2 < o && (p2 *= 256); )
        this[r + m2] = e / p2 & 255;
      return r + o;
    };
    me.prototype.writeUintBE = me.prototype.writeUIntBE = function(e, r, o, f2) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f2) {
        let y3 = Math.pow(2, 8 * o) - 1;
        er(this, e, r, o, y3, 0);
      }
      let p2 = o - 1, m2 = 1;
      for (this[r + p2] = e & 255;--p2 >= 0 && (m2 *= 256); )
        this[r + p2] = e / m2 & 255;
      return r + o;
    };
    me.prototype.writeUint8 = me.prototype.writeUInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
    };
    me.prototype.writeUint16LE = me.prototype.writeUInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeUint16BE = me.prototype.writeUInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeUint32LE = me.prototype.writeUInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
    };
    me.prototype.writeUint32BE = me.prototype.writeUInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    function jd(t, e, r, o, f2) {
      Yd(e, o, f2, t, r, 7);
      let p2 = Number(e & BigInt(4294967295));
      t[r++] = p2, p2 = p2 >> 8, t[r++] = p2, p2 = p2 >> 8, t[r++] = p2, p2 = p2 >> 8, t[r++] = p2;
      let m2 = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r++] = m2, m2 = m2 >> 8, t[r++] = m2, m2 = m2 >> 8, t[r++] = m2, m2 = m2 >> 8, t[r++] = m2, r;
    }
    function Zd(t, e, r, o, f2) {
      Yd(e, o, f2, t, r, 7);
      let p2 = Number(e & BigInt(4294967295));
      t[r + 7] = p2, p2 = p2 >> 8, t[r + 6] = p2, p2 = p2 >> 8, t[r + 5] = p2, p2 = p2 >> 8, t[r + 4] = p2;
      let m2 = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r + 3] = m2, m2 = m2 >> 8, t[r + 2] = m2, m2 = m2 >> 8, t[r + 1] = m2, m2 = m2 >> 8, t[r] = m2, r + 8;
    }
    me.prototype.writeBigUInt64LE = Ti(function(e, r = 0) {
      return jd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeBigUInt64BE = Ti(function(e, r = 0) {
      return Zd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeIntLE = function(e, r, o, f2) {
      if (e = +e, r = r >>> 0, !f2) {
        let M2 = Math.pow(2, 8 * o - 1);
        er(this, e, r, o, M2 - 1, -M2);
      }
      let p2 = 0, m2 = 1, y3 = 0;
      for (this[r] = e & 255;++p2 < o && (m2 *= 256); )
        e < 0 && y3 === 0 && this[r + p2 - 1] !== 0 && (y3 = 1), this[r + p2] = (e / m2 >> 0) - y3 & 255;
      return r + o;
    };
    me.prototype.writeIntBE = function(e, r, o, f2) {
      if (e = +e, r = r >>> 0, !f2) {
        let M2 = Math.pow(2, 8 * o - 1);
        er(this, e, r, o, M2 - 1, -M2);
      }
      let p2 = o - 1, m2 = 1, y3 = 0;
      for (this[r + p2] = e & 255;--p2 >= 0 && (m2 *= 256); )
        e < 0 && y3 === 0 && this[r + p2 + 1] !== 0 && (y3 = 1), this[r + p2] = (e / m2 >> 0) - y3 & 255;
      return r + o;
    };
    me.prototype.writeInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
    };
    me.prototype.writeInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
    };
    me.prototype.writeInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    me.prototype.writeBigInt64LE = Ti(function(e, r = 0) {
      return jd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    me.prototype.writeBigInt64BE = Ti(function(e, r = 0) {
      return Zd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Vd(t, e, r, o, f2, p2) {
      if (r + o > t.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function $d(t, e, r, o, f2) {
      return e = +e, r = r >>> 0, f2 || Vd(t, e, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Gn.write(t, e, r, o, 23, 4), r + 4;
    }
    me.prototype.writeFloatLE = function(e, r, o) {
      return $d(this, e, r, true, o);
    };
    me.prototype.writeFloatBE = function(e, r, o) {
      return $d(this, e, r, false, o);
    };
    function Gd(t, e, r, o, f2) {
      return e = +e, r = r >>> 0, f2 || Vd(t, e, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Gn.write(t, e, r, o, 52, 8), r + 8;
    }
    me.prototype.writeDoubleLE = function(e, r, o) {
      return Gd(this, e, r, true, o);
    };
    me.prototype.writeDoubleBE = function(e, r, o) {
      return Gd(this, e, r, false, o);
    };
    me.prototype.copy = function(e, r, o, f2) {
      if (!me.isBuffer(e))
        throw new TypeError("argument should be a Buffer");
      if (o || (o = 0), !f2 && f2 !== 0 && (f2 = this.length), r >= e.length && (r = e.length), r || (r = 0), f2 > 0 && f2 < o && (f2 = o), f2 === o || e.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (o < 0 || o >= this.length)
        throw new RangeError("Index out of range");
      if (f2 < 0)
        throw new RangeError("sourceEnd out of bounds");
      f2 > this.length && (f2 = this.length), e.length - r < f2 - o && (f2 = e.length - r + o);
      let p2 = f2 - o;
      return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o, f2) : Uint8Array.prototype.set.call(e, this.subarray(o, f2), r), p2;
    };
    me.prototype.fill = function(e, r, o, f2) {
      if (typeof e == "string") {
        if (typeof r == "string" ? (f2 = r, r = 0, o = this.length) : typeof o == "string" && (f2 = o, o = this.length), f2 !== undefined && typeof f2 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof f2 == "string" && !me.isEncoding(f2))
          throw new TypeError("Unknown encoding: " + f2);
        if (e.length === 1) {
          let m2 = e.charCodeAt(0);
          (f2 === "utf8" && m2 < 128 || f2 === "latin1") && (e = m2);
        }
      } else
        typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
      if (r < 0 || this.length < r || this.length < o)
        throw new RangeError("Out of range index");
      if (o <= r)
        return this;
      r = r >>> 0, o = o === undefined ? this.length : o >>> 0, e || (e = 0);
      let p2;
      if (typeof e == "number")
        for (p2 = r;p2 < o; ++p2)
          this[p2] = e;
      else {
        let m2 = me.isBuffer(e) ? e : me.from(e, f2), y3 = m2.length;
        if (y3 === 0)
          throw new TypeError('The value "' + e + '" is invalid for argument "value"');
        for (p2 = 0;p2 < o - r; ++p2)
          this[p2 + r] = m2[p2 % y3];
      }
      return this;
    };
    var $n = {};
    function P0(t, e, r) {
      $n[t] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
        }
        get code() {
          return t;
        }
        set code(f2) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f2, writable: true });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    P0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
      return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    P0("ERR_INVALID_ARG_TYPE", function(t, e) {
      return `The "${t}" argument must be of type number. Received type ${typeof e}`;
    }, TypeError);
    P0("ERR_OUT_OF_RANGE", function(t, e, r) {
      let o = `The value of "${t}" is out of range.`, f2 = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f2 = Fd(String(r)) : typeof r == "bigint" && (f2 = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f2 = Fd(f2)), f2 += "n"), o += ` It must be ${e}. Received ${f2}`, o;
    }, RangeError);
    function Fd(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function Kw(t, e, r) {
      Yn(e, "offset"), (t[e] === undefined || t[e + r] === undefined) && Vf(e, t.length - (r + 1));
    }
    function Yd(t, e, r, o, f2, p2) {
      if (t > r || t < e) {
        let m2 = typeof e == "bigint" ? "n" : "", y3;
        throw p2 > 3 ? e === 0 || e === BigInt(0) ? y3 = `>= 0${m2} and < 2${m2} ** ${(p2 + 1) * 8}${m2}` : y3 = `>= -(2${m2} ** ${(p2 + 1) * 8 - 1}${m2}) and < 2 ** ${(p2 + 1) * 8 - 1}${m2}` : y3 = `>= ${e}${m2} and <= ${r}${m2}`, new $n.ERR_OUT_OF_RANGE("value", y3, t);
      }
      Kw(o, f2, p2);
    }
    function Yn(t, e) {
      if (typeof t != "number")
        throw new $n.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function Vf(t, e, r) {
      throw Math.floor(t) !== t ? (Yn(t, r), new $n.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new $n.ERR_BUFFER_OUT_OF_BOUNDS : new $n.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
    }
    var jw = /[^+/0-9A-Za-z-_]/g;
    function Zw(t) {
      if (t = t.split("=")[0], t = t.trim().replace(jw, ""), t.length < 2)
        return "";
      for (;t.length % 4 !== 0; )
        t = t + "=";
      return t;
    }
    function L0(t, e) {
      e = e || 1 / 0;
      let r, o = t.length, f2 = null, p2 = [];
      for (let m2 = 0;m2 < o; ++m2) {
        if (r = t.charCodeAt(m2), r > 55295 && r < 57344) {
          if (!f2) {
            if (r > 56319) {
              (e -= 3) > -1 && p2.push(239, 191, 189);
              continue;
            } else if (m2 + 1 === o) {
              (e -= 3) > -1 && p2.push(239, 191, 189);
              continue;
            }
            f2 = r;
            continue;
          }
          if (r < 56320) {
            (e -= 3) > -1 && p2.push(239, 191, 189), f2 = r;
            continue;
          }
          r = (f2 - 55296 << 10 | r - 56320) + 65536;
        } else
          f2 && (e -= 3) > -1 && p2.push(239, 191, 189);
        if (f2 = null, r < 128) {
          if ((e -= 1) < 0)
            break;
          p2.push(r);
        } else if (r < 2048) {
          if ((e -= 2) < 0)
            break;
          p2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((e -= 3) < 0)
            break;
          p2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((e -= 4) < 0)
            break;
          p2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return p2;
    }
    function Vw(t) {
      let e = [];
      for (let r = 0;r < t.length; ++r)
        e.push(t.charCodeAt(r) & 255);
      return e;
    }
    function $w(t, e) {
      let r, o, f2, p2 = [];
      for (let m2 = 0;m2 < t.length && !((e -= 2) < 0); ++m2)
        r = t.charCodeAt(m2), o = r >> 8, f2 = r % 256, p2.push(f2), p2.push(o);
      return p2;
    }
    function Xd(t) {
      return I0.toByteArray(Zw(t));
    }
    function to(t, e, r, o) {
      let f2;
      for (f2 = 0;f2 < o && !(f2 + r >= e.length || f2 >= t.length); ++f2)
        e[f2 + r] = t[f2];
      return f2;
    }
    function Zr(t, e) {
      return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
    }
    function C0(t) {
      return t !== t;
    }
    var Gw = function() {
      let t = "0123456789abcdef", e = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let o = r * 16;
        for (let f2 = 0;f2 < 16; ++f2)
          e[o + f2] = t[r] + t[f2];
      }
      return e;
    }();
    function Ti(t) {
      return typeof BigInt > "u" ? Yw : t;
    }
    function Yw() {
      throw new Error("BigInt not supported");
    }
  });
  Te = T2((O0, Qd) => {
    var ro = Ut(), Vr = ro.Buffer;
    function Jd(t, e) {
      for (var r in t)
        e[r] = t[r];
    }
    Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? Qd.exports = ro : (Jd(ro, O0), O0.Buffer = an);
    function an(t, e, r) {
      return Vr(t, e, r);
    }
    an.prototype = Object.create(Vr.prototype);
    Jd(Vr, an);
    an.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError("Argument must not be a number");
      return Vr(t, e, r);
    };
    an.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      var o = Vr(t);
      return e !== undefined ? typeof r == "string" ? o.fill(e, r) : o.fill(e) : o.fill(0), o;
    };
    an.allocUnsafe = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return Vr(t);
    };
    an.allocUnsafeSlow = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return ro.SlowBuffer(t);
    };
  });
  on = T2((Gq, U0) => {
    var F0 = 65536, Xw = 4294967295;
    function Jw() {
      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var Qw = Te().Buffer, io = global.crypto || global.msCrypto;
    io && io.getRandomValues ? U0.exports = e6 : U0.exports = Jw;
    function e6(t, e) {
      if (t > Xw)
        throw new RangeError("requested too many random bytes");
      var r = Qw.allocUnsafe(t);
      if (t > 0)
        if (t > F0)
          for (var o = 0;o < t; o += F0)
            io.getRandomValues(r.slice(o, o + F0));
        else
          io.getRandomValues(r);
      return typeof e == "function" ? process.nextTick(function() {
        e(null, r);
      }) : r;
    }
  });
  Ie = T2((Yq, z0) => {
    typeof Object.create == "function" ? z0.exports = function(e, r) {
      r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : z0.exports = function(e, r) {
      if (r) {
        e.super_ = r;
        var o = function() {
        };
        o.prototype = r.prototype, e.prototype = new o, e.prototype.constructor = e;
      }
    };
  });
  ki = T2((Xq, H0) => {
    var Jn = typeof Reflect == "object" ? Reflect : null, ec = Jn && typeof Jn.apply == "function" ? Jn.apply : function(e, r, o) {
      return Function.prototype.apply.call(e, r, o);
    }, no;
    Jn && typeof Jn.ownKeys == "function" ? no = Jn.ownKeys : Object.getOwnPropertySymbols ? no = function(e) {
      return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : no = function(e) {
      return Object.getOwnPropertyNames(e);
    };
    function t6(t) {
      console && console.warn && console.warn(t);
    }
    var rc = Number.isNaN || function(e) {
      return e !== e;
    };
    function Fe() {
      Fe.init.call(this);
    }
    H0.exports = Fe;
    H0.exports.once = f6;
    Fe.EventEmitter = Fe;
    Fe.prototype._events = undefined;
    Fe.prototype._eventsCount = 0;
    Fe.prototype._maxListeners = undefined;
    var tc = 10;
    function fo(t) {
      if (typeof t != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
      return tc;
    }, set: function(t) {
      if (typeof t != "number" || t < 0 || rc(t))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
      tc = t;
    } });
    Fe.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    Fe.prototype.setMaxListeners = function(e) {
      if (typeof e != "number" || e < 0 || rc(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
      return this._maxListeners = e, this;
    };
    function ic(t) {
      return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
    }
    Fe.prototype.getMaxListeners = function() {
      return ic(this);
    };
    Fe.prototype.emit = function(e) {
      for (var r = [], o = 1;o < arguments.length; o++)
        r.push(arguments[o]);
      var f2 = e === "error", p2 = this._events;
      if (p2 !== undefined)
        f2 = f2 && p2.error === undefined;
      else if (!f2)
        return false;
      if (f2) {
        var m2;
        if (r.length > 0 && (m2 = r[0]), m2 instanceof Error)
          throw m2;
        var y3 = new Error("Unhandled error." + (m2 ? " (" + m2.message + ")" : ""));
        throw y3.context = m2, y3;
      }
      var M2 = p2[e];
      if (M2 === undefined)
        return false;
      if (typeof M2 == "function")
        ec(M2, this, r);
      else
        for (var x3 = M2.length, S2 = sc(M2, x3), o = 0;o < x3; ++o)
          ec(S2[o], this, r);
      return true;
    };
    function nc(t, e, r, o) {
      var f2, p2, m2;
      if (fo(r), p2 = t._events, p2 === undefined ? (p2 = t._events = Object.create(null), t._eventsCount = 0) : (p2.newListener !== undefined && (t.emit("newListener", e, r.listener ? r.listener : r), p2 = t._events), m2 = p2[e]), m2 === undefined)
        m2 = p2[e] = r, ++t._eventsCount;
      else if (typeof m2 == "function" ? m2 = p2[e] = o ? [r, m2] : [m2, r] : o ? m2.unshift(r) : m2.push(r), f2 = ic(t), f2 > 0 && m2.length > f2 && !m2.warned) {
        m2.warned = true;
        var y3 = new Error("Possible EventEmitter memory leak detected. " + m2.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        y3.name = "MaxListenersExceededWarning", y3.emitter = t, y3.type = e, y3.count = m2.length, t6(y3);
      }
      return t;
    }
    Fe.prototype.addListener = function(e, r) {
      return nc(this, e, r, false);
    };
    Fe.prototype.on = Fe.prototype.addListener;
    Fe.prototype.prependListener = function(e, r) {
      return nc(this, e, r, true);
    };
    function r6() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function fc(t, e, r) {
      var o = { fired: false, wrapFn: undefined, target: t, type: e, listener: r }, f2 = r6.bind(o);
      return f2.listener = r, o.wrapFn = f2, f2;
    }
    Fe.prototype.once = function(e, r) {
      return fo(r), this.on(e, fc(this, e, r)), this;
    };
    Fe.prototype.prependOnceListener = function(e, r) {
      return fo(r), this.prependListener(e, fc(this, e, r)), this;
    };
    Fe.prototype.removeListener = function(e, r) {
      var o, f2, p2, m2, y3;
      if (fo(r), f2 = this._events, f2 === undefined)
        return this;
      if (o = f2[e], o === undefined)
        return this;
      if (o === r || o.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f2[e], f2.removeListener && this.emit("removeListener", e, o.listener || r));
      else if (typeof o != "function") {
        for (p2 = -1, m2 = o.length - 1;m2 >= 0; m2--)
          if (o[m2] === r || o[m2].listener === r) {
            y3 = o[m2].listener, p2 = m2;
            break;
          }
        if (p2 < 0)
          return this;
        p2 === 0 ? o.shift() : i6(o, p2), o.length === 1 && (f2[e] = o[0]), f2.removeListener !== undefined && this.emit("removeListener", e, y3 || r);
      }
      return this;
    };
    Fe.prototype.off = Fe.prototype.removeListener;
    Fe.prototype.removeAllListeners = function(e) {
      var r, o, f2;
      if (o = this._events, o === undefined)
        return this;
      if (o.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o[e]), this;
      if (arguments.length === 0) {
        var p2 = Object.keys(o), m2;
        for (f2 = 0;f2 < p2.length; ++f2)
          m2 = p2[f2], m2 !== "removeListener" && this.removeAllListeners(m2);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = o[e], typeof r == "function")
        this.removeListener(e, r);
      else if (r !== undefined)
        for (f2 = r.length - 1;f2 >= 0; f2--)
          this.removeListener(e, r[f2]);
      return this;
    };
    function ac(t, e, r) {
      var o = t._events;
      if (o === undefined)
        return [];
      var f2 = o[e];
      return f2 === undefined ? [] : typeof f2 == "function" ? r ? [f2.listener || f2] : [f2] : r ? n6(f2) : sc(f2, f2.length);
    }
    Fe.prototype.listeners = function(e) {
      return ac(this, e, true);
    };
    Fe.prototype.rawListeners = function(e) {
      return ac(this, e, false);
    };
    Fe.listenerCount = function(t, e) {
      return typeof t.listenerCount == "function" ? t.listenerCount(e) : oc.call(t, e);
    };
    Fe.prototype.listenerCount = oc;
    function oc(t) {
      var e = this._events;
      if (e !== undefined) {
        var r = e[t];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    Fe.prototype.eventNames = function() {
      return this._eventsCount > 0 ? no(this._events) : [];
    };
    function sc(t, e) {
      for (var r = new Array(e), o = 0;o < e; ++o)
        r[o] = t[o];
      return r;
    }
    function i6(t, e) {
      for (;e + 1 < t.length; e++)
        t[e] = t[e + 1];
      t.pop();
    }
    function n6(t) {
      for (var e = new Array(t.length), r = 0;r < e.length; ++r)
        e[r] = t[r].listener || t[r];
      return e;
    }
    function f6(t, e) {
      return new Promise(function(r, o) {
        function f2(m2) {
          t.removeListener(e, p2), o(m2);
        }
        function p2() {
          typeof t.removeListener == "function" && t.removeListener("error", f2), r([].slice.call(arguments));
        }
        hc(t, e, p2, { once: true }), e !== "error" && a6(t, f2, { once: true });
      });
    }
    function a6(t, e, r) {
      typeof t.on == "function" && hc(t, "error", e, r);
    }
    function hc(t, e, r, o) {
      if (typeof t.on == "function")
        o.once ? t.once(e, r) : t.on(e, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function f(p2) {
          o.once && t.removeEventListener(e, f), r(p2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
  });
  W0 = T2((Jq, uc) => {
    uc.exports = ki().EventEmitter;
  });
  $f = T2(() => {
  });
  pc = T2((tI, cc) => {
    function lc(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f2) {
          return Object.getOwnPropertyDescriptor(t, f2).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function o6(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lc(Object(r), true).forEach(function(o) {
          s6(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lc(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function s6(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function h6(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dc(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function u6(t, e, r) {
      return e && dc(t.prototype, e), r && dc(t, r), t;
    }
    var l6 = Ut(), ao = l6.Buffer, d6 = $f(), K0 = d6.inspect, c6 = K0 && K0.custom || "inspect";
    function p6(t, e, r) {
      ao.prototype.copy.call(t, e, r);
    }
    cc.exports = function() {
      function t() {
        h6(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return u6(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f2 = "" + o.data;o = o.next; )
          f2 += r + o.data;
        return f2;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ao.alloc(0);
        for (var o = ao.allocUnsafe(r >>> 0), f2 = this.head, p2 = 0;f2; )
          p6(f2.data, o, p2), p2 += f2.data.length, f2 = f2.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f2;
        return r < this.head.data.length ? (f2 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f2 = this.shift() : f2 = o ? this._getString(r) : this._getBuffer(r), f2;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f2 = 1, p2 = o.data;
        for (r -= p2.length;o = o.next; ) {
          var m2 = o.data, y3 = r > m2.length ? m2.length : r;
          if (y3 === m2.length ? p2 += m2 : p2 += m2.slice(0, r), r -= y3, r === 0) {
            y3 === m2.length ? (++f2, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m2.slice(y3));
            break;
          }
          ++f2;
        }
        return this.length -= f2, p2;
      } }, { key: "_getBuffer", value: function(r) {
        var o = ao.allocUnsafe(r), f2 = this.head, p2 = 1;
        for (f2.data.copy(o), r -= f2.data.length;f2 = f2.next; ) {
          var m2 = f2.data, y3 = r > m2.length ? m2.length : r;
          if (m2.copy(o, o.length - r, 0, y3), r -= y3, r === 0) {
            y3 === m2.length ? (++p2, f2.next ? this.head = f2.next : this.head = this.tail = null) : (this.head = f2, f2.data = m2.slice(y3));
            break;
          }
          ++p2;
        }
        return this.length -= p2, o;
      } }, { key: c6, value: function(r, o) {
        return K0(this, o6({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  Z0 = T2((rI, bc) => {
    function v6(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f2 = this._writableState && this._writableState.destroyed;
      return o || f2 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(j0, this, t)) : process.nextTick(j0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p2) {
        !e && p2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(oo, r) : (r._writableState.errorEmitted = true, process.nextTick(vc, r, p2)) : process.nextTick(vc, r, p2) : e ? (process.nextTick(oo, r), e(p2)) : process.nextTick(oo, r);
      }), this);
    }
    function vc(t, e) {
      j0(t, e), oo(t);
    }
    function oo(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function b6() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function j0(t, e) {
      t.emit("error", e);
    }
    function m6(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bc.exports = { destroy: v6, undestroy: b6, errorOrDestroy: m6 };
  });
  sn = T2((iI, yc) => {
    function g6(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gc = {};
    function dr(t, e, r) {
      r || (r = Error);
      function o(p2, m2, y3) {
        return typeof e == "string" ? e : e(p2, m2, y3);
      }
      var f2 = function(p2) {
        g6(m2, p2);
        function m2(y3, M2, x3) {
          return p2.call(this, o(y3, M2, x3)) || this;
        }
        return m2;
      }(r);
      f2.prototype.name = r.name, f2.prototype.code = t, gc[t] = f2;
    }
    function mc(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function y6(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function w6(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function M6(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    dr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    dr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && y6(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f2;
      if (w6(t, " argument"))
        f2 = "The ".concat(t, " ").concat(o, " ").concat(mc(e, "type"));
      else {
        var p2 = M6(t, ".") ? "property" : "argument";
        f2 = 'The "'.concat(t, '" ').concat(p2, " ").concat(o, " ").concat(mc(e, "type"));
      }
      return f2 += ". Received type ".concat(typeof r), f2;
    }, TypeError);
    dr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    dr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    dr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    dr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    dr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    dr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    dr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    dr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    dr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    dr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yc.exports.codes = gc;
  });
  V0 = T2((nI, wc) => {
    var _6 = sn().codes.ERR_INVALID_OPT_VALUE;
    function x6(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function S6(t, e, r, o) {
      var f2 = x6(e, o, r);
      if (f2 != null) {
        if (!(isFinite(f2) && Math.floor(f2) === f2) || f2 < 0) {
          var p2 = o ? r : "highWaterMark";
          throw new _6(p2, f2);
        }
        return Math.floor(f2);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wc.exports = { getHighWaterMark: S6 };
  });
  G0 = T2((fI, Mc) => {
    Mc.exports = E6;
    function E6(t, e) {
      if ($0("noDeprecation"))
        return t;
      var r = false;
      function o() {
        if (!r) {
          if ($0("throwDeprecation"))
            throw new Error(e);
          $0("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
        }
        return t.apply(this, arguments);
      }
      return o;
    }
    function $0(t) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var e = global.localStorage[t];
      return e == null ? false : String(e).toLowerCase() === "true";
    }
  });
  J0 = T2((aI, Rc) => {
    Rc.exports = ht;
    function xc(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        J6(e, t);
      };
    }
    var Qn;
    ht.WritableState = Yf;
    var A6 = { deprecate: G0() }, Sc = W0(), ho = Ut().Buffer, R6 = global.Uint8Array || function() {
    };
    function B6(t) {
      return ho.from(t);
    }
    function q6(t) {
      return ho.isBuffer(t) || t instanceof R6;
    }
    var X0 = Z0(), I6 = V0(), T6 = I6.getHighWaterMark, Li = sn().codes, k6 = Li.ERR_INVALID_ARG_TYPE, L6 = Li.ERR_METHOD_NOT_IMPLEMENTED, N6 = Li.ERR_MULTIPLE_CALLBACK, D6 = Li.ERR_STREAM_CANNOT_PIPE, P6 = Li.ERR_STREAM_DESTROYED, C6 = Li.ERR_STREAM_NULL_VALUES, O6 = Li.ERR_STREAM_WRITE_AFTER_END, F6 = Li.ERR_UNKNOWN_ENCODING, ef = X0.errorOrDestroy;
    Ie()(ht, Sc);
    function U6() {
    }
    function Yf(t, e, r) {
      Qn = Qn || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof Qn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = T6(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f2) {
        V6(e, f2);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new xc(this);
    }
    Yf.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Yf.prototype, "buffer", { get: A6.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var so;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (so = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht, Symbol.hasInstance, { value: function(e) {
      return so.call(this, e) ? true : this !== ht ? false : e && e._writableState instanceof Yf;
    } })) : so = function(e) {
      return e instanceof this;
    };
    function ht(t) {
      Qn = Qn || hn();
      var e = this instanceof Qn;
      if (!e && !so.call(ht, this))
        return new ht(t);
      this._writableState = new Yf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Sc.call(this);
    }
    ht.prototype.pipe = function() {
      ef(this, new D6);
    };
    function z6(t, e) {
      var r = new O6;
      ef(t, r), process.nextTick(e, r);
    }
    function H6(t, e, r, o) {
      var f2;
      return r === null ? f2 = new C6 : typeof r != "string" && !e.objectMode && (f2 = new k6("chunk", ["string", "Buffer"], r)), f2 ? (ef(t, f2), process.nextTick(o, f2), false) : true;
    }
    ht.prototype.write = function(t, e, r) {
      var o = this._writableState, f2 = false, p2 = !o.objectMode && q6(t);
      return p2 && !ho.isBuffer(t) && (t = B6(t)), typeof e == "function" && (r = e, e = null), p2 ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = U6), o.ending ? z6(this, r) : (p2 || H6(this, o, t, r)) && (o.pendingcb++, f2 = K6(this, o, p2, t, e, r)), f2;
    };
    ht.prototype.cork = function() {
      this._writableState.corked++;
    };
    ht.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ec(this, t));
    };
    ht.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new F6(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ht.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function W6(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ho.from(e, r)), e;
    }
    Object.defineProperty(ht.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function K6(t, e, r, o, f2, p2) {
      if (!r) {
        var m2 = W6(e, o, f2);
        o !== m2 && (r = true, f2 = "buffer", o = m2);
      }
      var y3 = e.objectMode ? 1 : o.length;
      e.length += y3;
      var M2 = e.length < e.highWaterMark;
      if (M2 || (e.needDrain = true), e.writing || e.corked) {
        var x3 = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f2, isBuf: r, callback: p2, next: null }, x3 ? x3.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        Y0(t, e, false, y3, o, f2, p2);
      return M2;
    }
    function Y0(t, e, r, o, f2, p2, m2) {
      e.writelen = o, e.writecb = m2, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new P6("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p2, e.onwrite), e.sync = false;
    }
    function j6(t, e, r, o, f2) {
      --e.pendingcb, r ? (process.nextTick(f2, o), process.nextTick(Gf, t, e), t._writableState.errorEmitted = true, ef(t, o)) : (f2(o), t._writableState.errorEmitted = true, ef(t, o), Gf(t, e));
    }
    function Z6(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function V6(t, e) {
      var r = t._writableState, o = r.sync, f2 = r.writecb;
      if (typeof f2 != "function")
        throw new N6;
      if (Z6(r), e)
        j6(t, r, o, e, f2);
      else {
        var p2 = Ac(r) || t.destroyed;
        !p2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ec(t, r), o ? process.nextTick(_c, t, r, p2, f2) : _c(t, r, p2, f2);
      }
    }
    function _c(t, e, r, o) {
      r || $6(t, e), e.pendingcb--, o(), Gf(t, e);
    }
    function $6(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Ec(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f2 = new Array(o), p2 = e.corkedRequestsFree;
        p2.entry = r;
        for (var m2 = 0, y3 = true;r; )
          f2[m2] = r, r.isBuf || (y3 = false), r = r.next, m2 += 1;
        f2.allBuffers = y3, Y0(t, e, true, e.length, f2, "", p2.finish), e.pendingcb++, e.lastBufferedRequest = null, p2.next ? (e.corkedRequestsFree = p2.next, p2.next = null) : e.corkedRequestsFree = new xc(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M2, encoding: x3, callback: S2 } = r, E3 = e.objectMode ? 1 : M2.length;
          if (Y0(t, e, false, E3, M2, x3, S2), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ht.prototype._write = function(t, e, r) {
      r(new L6("_write()"));
    };
    ht.prototype._writev = null;
    ht.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || X6(this, o, r), this;
    };
    Object.defineProperty(ht.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ac(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function G6(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && ef(t, r), e.prefinished = true, t.emit("prefinish"), Gf(t, e);
      });
    }
    function Y6(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(G6, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Gf(t, e) {
      var r = Ac(e);
      if (r && (Y6(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function X6(t, e, r) {
      e.ending = true, Gf(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function J6(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f2 = o.callback;
        e.pendingcb--, f2(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ht.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ht.prototype.destroy = X0.destroy;
    ht.prototype._undestroy = X0.undestroy;
    ht.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  hn = T2((oI, qc) => {
    var Q6 = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    qc.exports = $r;
    var Bc = th(), eh = J0();
    Ie()($r, Bc);
    for (Q0 = Q6(eh.prototype), uo = 0;uo < Q0.length; uo++)
      lo = Q0[uo], $r.prototype[lo] || ($r.prototype[lo] = eh.prototype[lo]);
    var Q0, lo, uo;
    function $r(t) {
      if (!(this instanceof $r))
        return new $r(t);
      Bc.call(this, t), eh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", eM)));
    }
    Object.defineProperty($r.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($r.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($r.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function eM() {
      this._writableState.ended || process.nextTick(tM, this);
    }
    function tM(t) {
      t.end();
    }
    Object.defineProperty($r.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  co = T2((Tc) => {
    var ih = Te().Buffer, Ic = ih.isEncoding || function(t) {
      switch (t = "" + t, t && t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function rM(t) {
      if (!t)
        return "utf8";
      for (var e;; )
        switch (t) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t;
          default:
            if (e)
              return;
            t = ("" + t).toLowerCase(), e = true;
        }
    }
    function iM(t) {
      var e = rM(t);
      if (typeof e != "string" && (ih.isEncoding === Ic || !Ic(t)))
        throw new Error("Unknown encoding: " + t);
      return e || t;
    }
    Tc.StringDecoder = Xf;
    function Xf(t) {
      this.encoding = iM(t);
      var e;
      switch (this.encoding) {
        case "utf16le":
          this.text = hM, this.end = uM, e = 4;
          break;
        case "utf8":
          this.fillLast = aM, e = 4;
          break;
        case "base64":
          this.text = lM, this.end = dM, e = 3;
          break;
        default:
          this.write = cM, this.end = pM;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ih.allocUnsafe(e);
    }
    Xf.prototype.write = function(t) {
      if (t.length === 0)
        return "";
      var e, r;
      if (this.lastNeed) {
        if (e = this.fillLast(t), e === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    Xf.prototype.end = sM;
    Xf.prototype.text = oM;
    Xf.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function rh(t) {
      return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    function nM(t, e, r) {
      var o = e.length - 1;
      if (o < r)
        return 0;
      var f2 = rh(e[o]);
      return f2 >= 0 ? (f2 > 0 && (t.lastNeed = f2 - 1), f2) : --o < r || f2 === -2 ? 0 : (f2 = rh(e[o]), f2 >= 0 ? (f2 > 0 && (t.lastNeed = f2 - 2), f2) : --o < r || f2 === -2 ? 0 : (f2 = rh(e[o]), f2 >= 0 ? (f2 > 0 && (f2 === 2 ? f2 = 0 : t.lastNeed = f2 - 3), f2) : 0));
    }
    function fM(t, e, r) {
      if ((e[0] & 192) !== 128)
        return t.lastNeed = 0, "";
      if (t.lastNeed > 1 && e.length > 1) {
        if ((e[1] & 192) !== 128)
          return t.lastNeed = 1, "";
        if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
          return t.lastNeed = 2, "";
      }
    }
    function aM(t) {
      var e = this.lastTotal - this.lastNeed, r = fM(this, t, e);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    function oM(t, e) {
      var r = nM(this, t, e);
      if (!this.lastNeed)
        return t.toString("utf8", e);
      this.lastTotal = r;
      var o = t.length - (r - this.lastNeed);
      return t.copy(this.lastChar, 0, o), t.toString("utf8", e, o);
    }
    function sM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "" : e;
    }
    function hM(t, e) {
      if ((t.length - e) % 2 === 0) {
        var r = t.toString("utf16le", e);
        if (r) {
          var o = r.charCodeAt(r.length - 1);
          if (o >= 55296 && o <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function uM(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, r);
      }
      return e;
    }
    function lM(t, e) {
      var r = (t.length - e) % 3;
      return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    function dM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function cM(t) {
      return t.toString(this.encoding);
    }
    function pM(t) {
      return t && t.length ? this.write(t) : "";
    }
  });
  Jf = {};
  Ja(Jf, { StringDecoder: () => po.StringDecoder, default: () => po.StringDecoder });
  Qf = R0(() => {
    po = rn(co());
  });
  vo = T2((hI, Nc) => {
    var kc = sn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function vM(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f2 = 0;f2 < r; f2++)
            o[f2] = arguments[f2];
          t.apply(this, o);
        }
      };
    }
    function bM() {
    }
    function mM(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Lc(t, e, r) {
      if (typeof e == "function")
        return Lc(t, null, e);
      e || (e = {}), r = vM(r || bM);
      var o = e.readable || e.readable !== false && t.readable, f2 = e.writable || e.writable !== false && t.writable, p2 = function() {
        t.writable || y3();
      }, m2 = t._writableState && t._writableState.finished, y3 = function() {
        f2 = false, m2 = true, o || r.call(t);
      }, M2 = t._readableState && t._readableState.endEmitted, x3 = function() {
        o = false, M2 = true, f2 || r.call(t);
      }, S2 = function(L3) {
        r.call(t, L3);
      }, E3 = function() {
        var L3;
        if (o && !M2)
          return (!t._readableState || !t._readableState.ended) && (L3 = new kc), r.call(t, L3);
        if (f2 && !m2)
          return (!t._writableState || !t._writableState.ended) && (L3 = new kc), r.call(t, L3);
      }, B3 = function() {
        t.req.on("finish", y3);
      };
      return mM(t) ? (t.on("complete", y3), t.on("abort", E3), t.req ? B3() : t.on("request", B3)) : f2 && !t._writableState && (t.on("end", p2), t.on("close", p2)), t.on("end", x3), t.on("finish", y3), e.error !== false && t.on("error", S2), t.on("close", E3), function() {
        t.removeListener("complete", y3), t.removeListener("abort", E3), t.removeListener("request", B3), t.req && t.req.removeListener("finish", y3), t.removeListener("end", p2), t.removeListener("close", p2), t.removeListener("finish", y3), t.removeListener("end", x3), t.removeListener("error", S2), t.removeListener("close", E3);
      };
    }
    Nc.exports = Lc;
  });
  Pc = T2((uI, Dc) => {
    var bo;
    function Ni(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var gM = vo(), Di = Symbol("lastResolve"), un = Symbol("lastReject"), ea = Symbol("error"), mo = Symbol("ended"), ln = Symbol("lastPromise"), nh = Symbol("handlePromise"), dn = Symbol("stream");
    function Pi(t, e) {
      return { value: t, done: e };
    }
    function yM(t) {
      var e = t[Di];
      if (e !== null) {
        var r = t[dn].read();
        r !== null && (t[ln] = null, t[Di] = null, t[un] = null, e(Pi(r, false)));
      }
    }
    function wM(t) {
      process.nextTick(yM, t);
    }
    function MM(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[mo]) {
            r(Pi(undefined, true));
            return;
          }
          e[nh](r, o);
        }, o);
      };
    }
    var _M = Object.getPrototypeOf(function() {
    }), xM = Object.setPrototypeOf((bo = { get stream() {
      return this[dn];
    }, next: function() {
      var e = this, r = this[ea];
      if (r !== null)
        return Promise.reject(r);
      if (this[mo])
        return Promise.resolve(Pi(undefined, true));
      if (this[dn].destroyed)
        return new Promise(function(m2, y3) {
          process.nextTick(function() {
            e[ea] ? y3(e[ea]) : m2(Pi(undefined, true));
          });
        });
      var o = this[ln], f2;
      if (o)
        f2 = new Promise(MM(o, this));
      else {
        var p2 = this[dn].read();
        if (p2 !== null)
          return Promise.resolve(Pi(p2, false));
        f2 = new Promise(this[nh]);
      }
      return this[ln] = f2, f2;
    } }, Ni(bo, Symbol.asyncIterator, function() {
      return this;
    }), Ni(bo, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[dn].destroy(null, function(f2) {
          if (f2) {
            o(f2);
            return;
          }
          r(Pi(undefined, true));
        });
      });
    }), bo), _M), SM = function(e) {
      var r, o = Object.create(xM, (r = {}, Ni(r, dn, { value: e, writable: true }), Ni(r, Di, { value: null, writable: true }), Ni(r, un, { value: null, writable: true }), Ni(r, ea, { value: null, writable: true }), Ni(r, mo, { value: e._readableState.endEmitted, writable: true }), Ni(r, nh, { value: function(p2, m2) {
        var y3 = o[dn].read();
        y3 ? (o[ln] = null, o[Di] = null, o[un] = null, p2(Pi(y3, false))) : (o[Di] = p2, o[un] = m2);
      }, writable: true }), r));
      return o[ln] = null, gM(e, function(f2) {
        if (f2 && f2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p2 = o[un];
          p2 !== null && (o[ln] = null, o[Di] = null, o[un] = null, p2(f2)), o[ea] = f2;
          return;
        }
        var m2 = o[Di];
        m2 !== null && (o[ln] = null, o[Di] = null, o[un] = null, m2(Pi(undefined, true))), o[mo] = true;
      }), e.on("readable", wM.bind(null, o)), o;
    };
    Dc.exports = SM;
  });
  Oc = T2((lI, Cc) => {
    Cc.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  th = T2((cI, $c) => {
    $c.exports = Ce;
    var tf;
    Ce.ReadableState = Hc;
    var dI = ki().EventEmitter, zc = function(e, r) {
      return e.listeners(r).length;
    }, ra = W0(), go = Ut().Buffer, EM = global.Uint8Array || function() {
    };
    function AM(t) {
      return go.from(t);
    }
    function RM(t) {
      return go.isBuffer(t) || t instanceof EM;
    }
    var fh = $f(), Ne;
    fh && fh.debuglog ? Ne = fh.debuglog("stream") : Ne = function() {
    };
    var BM = pc(), dh = Z0(), qM = V0(), IM = qM.getHighWaterMark, yo = sn().codes, TM = yo.ERR_INVALID_ARG_TYPE, kM = yo.ERR_STREAM_PUSH_AFTER_EOF, LM = yo.ERR_METHOD_NOT_IMPLEMENTED, NM = yo.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, rf, ah, oh;
    Ie()(Ce, ra);
    var ta = dh.errorOrDestroy, sh = ["error", "close", "destroy", "pause", "resume"];
    function DM(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Hc(t, e, r) {
      tf = tf || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof tf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = IM(this, t, "readableHighWaterMark", r), this.buffer = new BM, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (rf || (rf = (Qf(), ur(Jf)).StringDecoder), this.decoder = new rf(t.encoding), this.encoding = t.encoding);
    }
    function Ce(t) {
      if (tf = tf || hn(), !(this instanceof Ce))
        return new Ce(t);
      var e = this instanceof tf;
      this._readableState = new Hc(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ra.call(this);
    }
    Object.defineProperty(Ce.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Ce.prototype.destroy = dh.destroy;
    Ce.prototype._undestroy = dh.undestroy;
    Ce.prototype._destroy = function(t, e) {
      e(t);
    };
    Ce.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = go.from(t, e), e = ""), o = true), Wc(this, t, e, false, o);
    };
    Ce.prototype.unshift = function(t) {
      return Wc(this, t, null, true, false);
    };
    function Wc(t, e, r, o, f2) {
      Ne("readableAddChunk", e);
      var p2 = t._readableState;
      if (e === null)
        p2.reading = false, OM(t, p2);
      else {
        var m2;
        if (f2 || (m2 = PM(p2, e)), m2)
          ta(t, m2);
        else if (p2.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p2.objectMode && Object.getPrototypeOf(e) !== go.prototype && (e = AM(e)), o)
            p2.endEmitted ? ta(t, new NM) : hh(t, p2, e, true);
          else if (p2.ended)
            ta(t, new kM);
          else {
            if (p2.destroyed)
              return false;
            p2.reading = false, p2.decoder && !r ? (e = p2.decoder.write(e), p2.objectMode || e.length !== 0 ? hh(t, p2, e, false) : lh(t, p2)) : hh(t, p2, e, false);
          }
        else
          o || (p2.reading = false, lh(t, p2));
      }
      return !p2.ended && (p2.length < p2.highWaterMark || p2.length === 0);
    }
    function hh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && wo(t)), lh(t, e);
    }
    function PM(t, e) {
      var r;
      return !RM(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new TM("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Ce.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Ce.prototype.setEncoding = function(t) {
      rf || (rf = (Qf(), ur(Jf)).StringDecoder);
      var e = new rf(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Fc = 1073741824;
    function CM(t) {
      return t >= Fc ? t = Fc : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Uc(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = CM(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Ce.prototype.read = function(t) {
      Ne("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Ne("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? uh(this) : wo(this), null;
      if (t = Uc(t, e), t === 0 && e.ended)
        return e.length === 0 && uh(this), null;
      var o = e.needReadable;
      Ne("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Ne("length less than watermark", o)), e.ended || e.reading ? (o = false, Ne("reading or ended", o)) : o && (Ne("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Uc(r, e)));
      var f2;
      return t > 0 ? f2 = Zc(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && uh(this)), f2 !== null && this.emit("data", f2), f2;
    };
    function OM(t, e) {
      if (Ne("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? wo(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, Kc(t)));
      }
    }
    function wo(t) {
      var e = t._readableState;
      Ne("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ne("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(Kc, t));
    }
    function Kc(t) {
      var e = t._readableState;
      Ne("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ch(t);
    }
    function lh(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(FM, t, e));
    }
    function FM(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (Ne("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Ce.prototype._read = function(t) {
      ta(this, new LM("_read()"));
    };
    Ce.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, Ne("pipe count=%d opts=%j", o.pipesCount, e);
      var f2 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p2 = f2 ? y3 : ge;
      o.endEmitted ? process.nextTick(p2) : r.once("end", p2), t.on("unpipe", m2);
      function m2(_e, N3) {
        Ne("onunpipe"), _e === r && N3 && N3.hasUnpiped === false && (N3.hasUnpiped = true, S2());
      }
      function y3() {
        Ne("onend"), t.end();
      }
      var M2 = UM(r);
      t.on("drain", M2);
      var x3 = false;
      function S2() {
        Ne("cleanup"), t.removeListener("close", q2), t.removeListener("finish", L3), t.removeListener("drain", M2), t.removeListener("error", B3), t.removeListener("unpipe", m2), r.removeListener("end", y3), r.removeListener("end", ge), r.removeListener("data", E3), x3 = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M2();
      }
      r.on("data", E3);
      function E3(_e) {
        Ne("ondata");
        var N3 = t.write(_e);
        Ne("dest.write", N3), N3 === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Vc(o.pipes, t) !== -1) && !x3 && (Ne("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B3(_e) {
        Ne("onerror", _e), ge(), t.removeListener("error", B3), zc(t, "error") === 0 && ta(t, _e);
      }
      DM(t, "error", B3);
      function q2() {
        t.removeListener("finish", L3), ge();
      }
      t.once("close", q2);
      function L3() {
        Ne("onfinish"), t.removeListener("close", q2), ge();
      }
      t.once("finish", L3);
      function ge() {
        Ne("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (Ne("pipe resume"), r.resume()), t;
    };
    function UM(t) {
      return function() {
        var r = t._readableState;
        Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zc(t, "data") && (r.flowing = true, ch(t));
      };
    }
    Ce.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f2 } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p2 = 0;p2 < f2; p2++)
          o[p2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m2 = Vc(e.pipes, t);
      return m2 === -1 ? this : (e.pipes.splice(m2, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Ce.prototype.on = function(t, e) {
      var r = ra.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Ne("on readable", o.length, o.reading), o.length ? wo(this) : o.reading || process.nextTick(zM, this)), r;
    };
    Ce.prototype.addListener = Ce.prototype.on;
    Ce.prototype.removeListener = function(t, e) {
      var r = ra.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(jc, this), r;
    };
    Ce.prototype.removeAllListeners = function(t) {
      var e = ra.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(jc, this), e;
    };
    function jc(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function zM(t) {
      Ne("readable nexttick read 0"), t.read(0);
    }
    Ce.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, HM(this, t)), t.paused = false, this;
    };
    function HM(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(WM, t, e));
    }
    function WM(t, e) {
      Ne("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ch(t), e.flowing && !e.reading && t.read(0);
    }
    Ce.prototype.pause = function() {
      return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ch(t) {
      var e = t._readableState;
      for (Ne("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Ce.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (Ne("wrapped end"), r.decoder && !r.ended) {
          var m2 = r.decoder.end();
          m2 && m2.length && e.push(m2);
        }
        e.push(null);
      }), t.on("data", function(m2) {
        if (Ne("wrapped data"), r.decoder && (m2 = r.decoder.write(m2)), !(r.objectMode && m2 == null) && !(!r.objectMode && (!m2 || !m2.length))) {
          var y3 = e.push(m2);
          y3 || (o = true, t.pause());
        }
      });
      for (var f2 in t)
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = function(y3) {
          return function() {
            return t[y3].apply(t, arguments);
          };
        }(f2));
      for (var p2 = 0;p2 < sh.length; p2++)
        t.on(sh[p2], this.emit.bind(this, sh[p2]));
      return this._read = function(m2) {
        Ne("wrapped _read", m2), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Ce.prototype[Symbol.asyncIterator] = function() {
      return ah === undefined && (ah = Pc()), ah(this);
    });
    Object.defineProperty(Ce.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Ce.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Ce.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Ce._fromList = Zc;
    Object.defineProperty(Ce.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Zc(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function uh(t) {
      var e = t._readableState;
      Ne("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(KM, e, t));
    }
    function KM(t, e) {
      if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Ce.from = function(t, e) {
      return oh === undefined && (oh = Oc()), oh(Ce, t, e);
    });
    function Vc(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  ph = T2((pI, Yc) => {
    Yc.exports = di;
    var Mo = sn().codes, jM = Mo.ERR_METHOD_NOT_IMPLEMENTED, ZM = Mo.ERR_MULTIPLE_CALLBACK, VM = Mo.ERR_TRANSFORM_ALREADY_TRANSFORMING, $M = Mo.ERR_TRANSFORM_WITH_LENGTH_0, _o = hn();
    Ie()(di, _o);
    function GM(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new ZM);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f2 = this._readableState;
      f2.reading = false, (f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
    }
    function di(t) {
      if (!(this instanceof di))
        return new di(t);
      _o.call(this, t), this._transformState = { afterTransform: GM.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", YM);
    }
    function YM() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Gc(t, e, r);
      }) : Gc(this, null, null);
    }
    di.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, _o.prototype.push.call(this, t, e);
    };
    di.prototype._transform = function(t, e, r) {
      r(new jM("_transform()"));
    };
    di.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f2 = this._readableState;
        (o.needTransform || f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
      }
    };
    di.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    di.prototype._destroy = function(t, e) {
      _o.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Gc(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new $M;
      if (t._transformState.transforming)
        throw new VM;
      return t.push(null);
    }
  });
  Qc = T2((vI, Jc) => {
    Jc.exports = ia;
    var Xc = ph();
    Ie()(ia, Xc);
    function ia(t) {
      if (!(this instanceof ia))
        return new ia(t);
      Xc.call(this, t);
    }
    ia.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  np = T2((bI, ip) => {
    var vh;
    function XM(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var rp = sn().codes, JM = rp.ERR_MISSING_ARGS, QM = rp.ERR_STREAM_DESTROYED;
    function ep(t) {
      if (t)
        throw t;
    }
    function e4(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function t4(t, e, r, o) {
      o = XM(o);
      var f2 = false;
      t.on("close", function() {
        f2 = true;
      }), vh === undefined && (vh = vo()), vh(t, { readable: e, writable: r }, function(m2) {
        if (m2)
          return o(m2);
        f2 = true, o();
      });
      var p2 = false;
      return function(m2) {
        if (!f2 && !p2) {
          if (p2 = true, e4(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m2 || new QM("pipe"));
        }
      };
    }
    function tp(t) {
      t();
    }
    function r4(t, e) {
      return t.pipe(e);
    }
    function i4(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? ep : t.pop();
    }
    function n4() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = i4(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new JM("streams");
      var f2, p2 = e.map(function(m2, y3) {
        var M2 = y3 < e.length - 1, x3 = y3 > 0;
        return t4(m2, M2, x3, function(S2) {
          f2 || (f2 = S2), S2 && p2.forEach(tp), !M2 && (p2.forEach(tp), o(f2));
        });
      });
      return e.reduce(r4);
    }
    ip.exports = n4;
  });
  ap = T2((cr, fp) => {
    cr = fp.exports = th();
    cr.Stream = cr;
    cr.Readable = cr;
    cr.Writable = J0();
    cr.Duplex = hn();
    cr.Transform = ph();
    cr.PassThrough = Qc();
    cr.finished = vo();
    cr.pipeline = np();
  });
  bh = T2((mI, sp) => {
    var xo = Te().Buffer, op = ap().Transform, f4 = Ie();
    function a4(t, e) {
      if (!xo.isBuffer(t) && typeof t != "string")
        throw new TypeError(e + " must be a string or a buffer");
    }
    function Ci(t) {
      op.call(this), this._block = xo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    f4(Ci, op);
    Ci.prototype._transform = function(t, e, r) {
      var o = null;
      try {
        this.update(t, e);
      } catch (f2) {
        o = f2;
      }
      r(o);
    };
    Ci.prototype._flush = function(t) {
      var e = null;
      try {
        this.push(this.digest());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Ci.prototype.update = function(t, e) {
      if (a4(t, "Data"), this._finalized)
        throw new Error("Digest already called");
      xo.isBuffer(t) || (t = xo.from(t, e));
      for (var r = this._block, o = 0;this._blockOffset + t.length - o >= this._blockSize; ) {
        for (var f2 = this._blockOffset;f2 < this._blockSize; )
          r[f2++] = t[o++];
        this._update(), this._blockOffset = 0;
      }
      for (;o < t.length; )
        r[this._blockOffset++] = t[o++];
      for (var p2 = 0, m2 = t.length * 8;m2 > 0; ++p2)
        this._length[p2] += m2, m2 = this._length[p2] / 4294967296 | 0, m2 > 0 && (this._length[p2] -= 4294967296 * m2);
      return this;
    };
    Ci.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    Ci.prototype.digest = function(t) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var e = this._digest();
      t !== undefined && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var r = 0;r < 4; ++r)
        this._length[r] = 0;
      return e;
    };
    Ci.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    sp.exports = Ci;
  });
  Ao = T2((gI, up) => {
    var o4 = Ie(), hp = bh(), s4 = Te().Buffer, h4 = new Array(16);
    function So() {
      hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    o4(So, hp);
    So.prototype._update = function() {
      for (var t = h4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      var r = this._a, o = this._b, f2 = this._c, p2 = this._d;
      r = jt(r, o, f2, p2, t[0], 3614090360, 7), p2 = jt(p2, r, o, f2, t[1], 3905402710, 12), f2 = jt(f2, p2, r, o, t[2], 606105819, 17), o = jt(o, f2, p2, r, t[3], 3250441966, 22), r = jt(r, o, f2, p2, t[4], 4118548399, 7), p2 = jt(p2, r, o, f2, t[5], 1200080426, 12), f2 = jt(f2, p2, r, o, t[6], 2821735955, 17), o = jt(o, f2, p2, r, t[7], 4249261313, 22), r = jt(r, o, f2, p2, t[8], 1770035416, 7), p2 = jt(p2, r, o, f2, t[9], 2336552879, 12), f2 = jt(f2, p2, r, o, t[10], 4294925233, 17), o = jt(o, f2, p2, r, t[11], 2304563134, 22), r = jt(r, o, f2, p2, t[12], 1804603682, 7), p2 = jt(p2, r, o, f2, t[13], 4254626195, 12), f2 = jt(f2, p2, r, o, t[14], 2792965006, 17), o = jt(o, f2, p2, r, t[15], 1236535329, 22), r = Zt(r, o, f2, p2, t[1], 4129170786, 5), p2 = Zt(p2, r, o, f2, t[6], 3225465664, 9), f2 = Zt(f2, p2, r, o, t[11], 643717713, 14), o = Zt(o, f2, p2, r, t[0], 3921069994, 20), r = Zt(r, o, f2, p2, t[5], 3593408605, 5), p2 = Zt(p2, r, o, f2, t[10], 38016083, 9), f2 = Zt(f2, p2, r, o, t[15], 3634488961, 14), o = Zt(o, f2, p2, r, t[4], 3889429448, 20), r = Zt(r, o, f2, p2, t[9], 568446438, 5), p2 = Zt(p2, r, o, f2, t[14], 3275163606, 9), f2 = Zt(f2, p2, r, o, t[3], 4107603335, 14), o = Zt(o, f2, p2, r, t[8], 1163531501, 20), r = Zt(r, o, f2, p2, t[13], 2850285829, 5), p2 = Zt(p2, r, o, f2, t[2], 4243563512, 9), f2 = Zt(f2, p2, r, o, t[7], 1735328473, 14), o = Zt(o, f2, p2, r, t[12], 2368359562, 20), r = Vt(r, o, f2, p2, t[5], 4294588738, 4), p2 = Vt(p2, r, o, f2, t[8], 2272392833, 11), f2 = Vt(f2, p2, r, o, t[11], 1839030562, 16), o = Vt(o, f2, p2, r, t[14], 4259657740, 23), r = Vt(r, o, f2, p2, t[1], 2763975236, 4), p2 = Vt(p2, r, o, f2, t[4], 1272893353, 11), f2 = Vt(f2, p2, r, o, t[7], 4139469664, 16), o = Vt(o, f2, p2, r, t[10], 3200236656, 23), r = Vt(r, o, f2, p2, t[13], 681279174, 4), p2 = Vt(p2, r, o, f2, t[0], 3936430074, 11), f2 = Vt(f2, p2, r, o, t[3], 3572445317, 16), o = Vt(o, f2, p2, r, t[6], 76029189, 23), r = Vt(r, o, f2, p2, t[9], 3654602809, 4), p2 = Vt(p2, r, o, f2, t[12], 3873151461, 11), f2 = Vt(f2, p2, r, o, t[15], 530742520, 16), o = Vt(o, f2, p2, r, t[2], 3299628645, 23), r = $t(r, o, f2, p2, t[0], 4096336452, 6), p2 = $t(p2, r, o, f2, t[7], 1126891415, 10), f2 = $t(f2, p2, r, o, t[14], 2878612391, 15), o = $t(o, f2, p2, r, t[5], 4237533241, 21), r = $t(r, o, f2, p2, t[12], 1700485571, 6), p2 = $t(p2, r, o, f2, t[3], 2399980690, 10), f2 = $t(f2, p2, r, o, t[10], 4293915773, 15), o = $t(o, f2, p2, r, t[1], 2240044497, 21), r = $t(r, o, f2, p2, t[8], 1873313359, 6), p2 = $t(p2, r, o, f2, t[15], 4264355552, 10), f2 = $t(f2, p2, r, o, t[6], 2734768916, 15), o = $t(o, f2, p2, r, t[13], 1309151649, 21), r = $t(r, o, f2, p2, t[4], 4149444226, 6), p2 = $t(p2, r, o, f2, t[11], 3174756917, 10), f2 = $t(f2, p2, r, o, t[2], 718787259, 15), o = $t(o, f2, p2, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o | 0, this._c = this._c + f2 | 0, this._d = this._d + p2 | 0;
    };
    So.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = s4.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function Eo(t, e) {
      return t << e | t >>> 32 - e;
    }
    function jt(t, e, r, o, f2, p2, m2) {
      return Eo(t + (e & r | ~e & o) + f2 + p2 | 0, m2) + e | 0;
    }
    function Zt(t, e, r, o, f2, p2, m2) {
      return Eo(t + (e & o | r & ~o) + f2 + p2 | 0, m2) + e | 0;
    }
    function Vt(t, e, r, o, f2, p2, m2) {
      return Eo(t + (e ^ r ^ o) + f2 + p2 | 0, m2) + e | 0;
    }
    function $t(t, e, r, o, f2, p2, m2) {
      return Eo(t + (r ^ (e | ~o)) + f2 + p2 | 0, m2) + e | 0;
    }
    up.exports = So;
  });
  Bo = T2((yI, mp) => {
    var mh = Ut().Buffer, u4 = Ie(), bp = bh(), l4 = new Array(16), na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], aa = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], oa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], sa = [0, 1518500249, 1859775393, 2400959708, 2840853838], ha = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function Ro() {
      bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    u4(Ro, bp);
    Ro.prototype._update = function() {
      for (var t = l4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      for (var r = this._a | 0, o = this._b | 0, f2 = this._c | 0, p2 = this._d | 0, m2 = this._e | 0, y3 = this._a | 0, M2 = this._b | 0, x3 = this._c | 0, S2 = this._d | 0, E3 = this._e | 0, B3 = 0;B3 < 80; B3 += 1) {
        var q2, L3;
        B3 < 16 ? (q2 = lp(r, o, f2, p2, m2, t[na[B3]], sa[0], aa[B3]), L3 = vp(y3, M2, x3, S2, E3, t[fa[B3]], ha[0], oa[B3])) : B3 < 32 ? (q2 = dp(r, o, f2, p2, m2, t[na[B3]], sa[1], aa[B3]), L3 = pp(y3, M2, x3, S2, E3, t[fa[B3]], ha[1], oa[B3])) : B3 < 48 ? (q2 = cp(r, o, f2, p2, m2, t[na[B3]], sa[2], aa[B3]), L3 = cp(y3, M2, x3, S2, E3, t[fa[B3]], ha[2], oa[B3])) : B3 < 64 ? (q2 = pp(r, o, f2, p2, m2, t[na[B3]], sa[3], aa[B3]), L3 = dp(y3, M2, x3, S2, E3, t[fa[B3]], ha[3], oa[B3])) : (q2 = vp(r, o, f2, p2, m2, t[na[B3]], sa[4], aa[B3]), L3 = lp(y3, M2, x3, S2, E3, t[fa[B3]], ha[4], oa[B3])), r = m2, m2 = p2, p2 = cn(f2, 10), f2 = o, o = q2, y3 = E3, E3 = S2, S2 = cn(x3, 10), x3 = M2, M2 = L3;
      }
      var ge = this._b + f2 + S2 | 0;
      this._b = this._c + p2 + E3 | 0, this._c = this._d + m2 + y3 | 0, this._d = this._e + r + M2 | 0, this._e = this._a + o + x3 | 0, this._a = ge;
    };
    Ro.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = mh.alloc ? mh.alloc(20) : new mh(20);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function cn(t, e) {
      return t << e | t >>> 32 - e;
    }
    function lp(t, e, r, o, f2, p2, m2, y3) {
      return cn(t + (e ^ r ^ o) + p2 + m2 | 0, y3) + f2 | 0;
    }
    function dp(t, e, r, o, f2, p2, m2, y3) {
      return cn(t + (e & r | ~e & o) + p2 + m2 | 0, y3) + f2 | 0;
    }
    function cp(t, e, r, o, f2, p2, m2, y3) {
      return cn(t + ((e | ~r) ^ o) + p2 + m2 | 0, y3) + f2 | 0;
    }
    function pp(t, e, r, o, f2, p2, m2, y3) {
      return cn(t + (e & o | r & ~o) + p2 + m2 | 0, y3) + f2 | 0;
    }
    function vp(t, e, r, o, f2, p2, m2, y3) {
      return cn(t + (e ^ (r | ~o)) + p2 + m2 | 0, y3) + f2 | 0;
    }
    mp.exports = Ro;
  });
  pn = T2((wI, yp) => {
    var gp = Te().Buffer;
    function qo(t, e) {
      this._block = gp.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }
    qo.prototype.update = function(t, e) {
      typeof t == "string" && (e = e || "utf8", t = gp.from(t, e));
      for (var r = this._block, o = this._blockSize, f2 = t.length, p2 = this._len, m2 = 0;m2 < f2; ) {
        for (var y3 = p2 % o, M2 = Math.min(f2 - m2, o - y3), x3 = 0;x3 < M2; x3++)
          r[y3 + x3] = t[m2 + x3];
        p2 += M2, m2 += M2, p2 % o === 0 && this._update(r);
      }
      return this._len += f2, this;
    };
    qo.prototype.digest = function(t) {
      var e = this._len % this._blockSize;
      this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = this._len * 8;
      if (r <= 4294967295)
        this._block.writeUInt32BE(r, this._blockSize - 4);
      else {
        var o = (r & 4294967295) >>> 0, f2 = (r - o) / 4294967296;
        this._block.writeUInt32BE(f2, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
      }
      this._update(this._block);
      var p2 = this._hash();
      return t ? p2.toString(t) : p2;
    };
    qo.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    yp.exports = qo;
  });
  _p = T2((MI, Mp) => {
    var d4 = Ie(), wp = pn(), c4 = Te().Buffer, p4 = [1518500249, 1859775393, -1894007588, -899497514], v4 = new Array(80);
    function ua() {
      this.init(), this._w = v4, wp.call(this, 64, 56);
    }
    d4(ua, wp);
    ua.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function b4(t) {
      return t << 5 | t >>> 27;
    }
    function m4(t) {
      return t << 30 | t >>> 2;
    }
    function g4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    ua.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f2 = this._c | 0, p2 = this._d | 0, m2 = this._e | 0, y3 = 0;y3 < 16; ++y3)
        e[y3] = t.readInt32BE(y3 * 4);
      for (;y3 < 80; ++y3)
        e[y3] = e[y3 - 3] ^ e[y3 - 8] ^ e[y3 - 14] ^ e[y3 - 16];
      for (var M2 = 0;M2 < 80; ++M2) {
        var x3 = ~~(M2 / 20), S2 = b4(r) + g4(x3, o, f2, p2) + m2 + e[M2] + p4[x3] | 0;
        m2 = p2, p2 = f2, f2 = m4(o), o = r, r = S2;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f2 + this._c | 0, this._d = p2 + this._d | 0, this._e = m2 + this._e | 0;
    };
    ua.prototype._hash = function() {
      var t = c4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Mp.exports = ua;
  });
  Ep = T2((_I, Sp) => {
    var y4 = Ie(), xp = pn(), w4 = Te().Buffer, M4 = [1518500249, 1859775393, -1894007588, -899497514], _4 = new Array(80);
    function la() {
      this.init(), this._w = _4, xp.call(this, 64, 56);
    }
    y4(la, xp);
    la.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function x4(t) {
      return t << 1 | t >>> 31;
    }
    function S4(t) {
      return t << 5 | t >>> 27;
    }
    function E4(t) {
      return t << 30 | t >>> 2;
    }
    function A4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    la.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f2 = this._c | 0, p2 = this._d | 0, m2 = this._e | 0, y3 = 0;y3 < 16; ++y3)
        e[y3] = t.readInt32BE(y3 * 4);
      for (;y3 < 80; ++y3)
        e[y3] = x4(e[y3 - 3] ^ e[y3 - 8] ^ e[y3 - 14] ^ e[y3 - 16]);
      for (var M2 = 0;M2 < 80; ++M2) {
        var x3 = ~~(M2 / 20), S2 = S4(r) + A4(x3, o, f2, p2) + m2 + e[M2] + M4[x3] | 0;
        m2 = p2, p2 = f2, f2 = E4(o), o = r, r = S2;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f2 + this._c | 0, this._d = p2 + this._d | 0, this._e = m2 + this._e | 0;
    };
    la.prototype._hash = function() {
      var t = w4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Sp.exports = la;
  });
  gh = T2((xI, Rp) => {
    var R4 = Ie(), Ap = pn(), B4 = Te().Buffer, q4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], I4 = new Array(64);
    function da() {
      this.init(), this._w = I4, Ap.call(this, 64, 56);
    }
    R4(da, Ap);
    da.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function T4(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function k4(t, e, r) {
      return t & e | r & (t | e);
    }
    function L4(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function N4(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function D4(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function P4(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    da.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f2 = this._c | 0, p2 = this._d | 0, m2 = this._e | 0, y3 = this._f | 0, M2 = this._g | 0, x3 = this._h | 0, S2 = 0;S2 < 16; ++S2)
        e[S2] = t.readInt32BE(S2 * 4);
      for (;S2 < 64; ++S2)
        e[S2] = P4(e[S2 - 2]) + e[S2 - 7] + D4(e[S2 - 15]) + e[S2 - 16] | 0;
      for (var E3 = 0;E3 < 64; ++E3) {
        var B3 = x3 + N4(m2) + T4(m2, y3, M2) + q4[E3] + e[E3] | 0, q2 = L4(r) + k4(r, o, f2) | 0;
        x3 = M2, M2 = y3, y3 = m2, m2 = p2 + B3 | 0, p2 = f2, f2 = o, o = r, r = B3 + q2 | 0;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f2 + this._c | 0, this._d = p2 + this._d | 0, this._e = m2 + this._e | 0, this._f = y3 + this._f | 0, this._g = M2 + this._g | 0, this._h = x3 + this._h | 0;
    };
    da.prototype._hash = function() {
      var t = B4.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    Rp.exports = da;
  });
  qp = T2((SI, Bp) => {
    var C4 = Ie(), O4 = gh(), F4 = pn(), U4 = Te().Buffer, z4 = new Array(64);
    function Io() {
      this.init(), this._w = z4, F4.call(this, 64, 56);
    }
    C4(Io, O4);
    Io.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    Io.prototype._hash = function() {
      var t = U4.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    Bp.exports = Io;
  });
  yh = T2((EI, Pp) => {
    var H4 = Ie(), Dp = pn(), W4 = Te().Buffer, Ip = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], K4 = new Array(160);
    function ca() {
      this.init(), this._w = K4, Dp.call(this, 128, 112);
    }
    H4(ca, Dp);
    ca.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function Tp(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function kp(t, e, r) {
      return t & e | r & (t | e);
    }
    function Lp(t, e) {
      return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
    }
    function Np(t, e) {
      return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
    }
    function j4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
    }
    function Z4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
    }
    function V4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
    }
    function $4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
    }
    function Pt(t, e) {
      return t >>> 0 < e >>> 0 ? 1 : 0;
    }
    ca.prototype._update = function(t) {
      for (var e = this._w, r = this._ah | 0, o = this._bh | 0, f2 = this._ch | 0, p2 = this._dh | 0, m2 = this._eh | 0, y3 = this._fh | 0, M2 = this._gh | 0, x3 = this._hh | 0, S2 = this._al | 0, E3 = this._bl | 0, B3 = this._cl | 0, q2 = this._dl | 0, L3 = this._el | 0, ge = this._fl | 0, _e = this._gl | 0, N3 = this._hl | 0, we = 0;we < 32; we += 2)
        e[we] = t.readInt32BE(we * 4), e[we + 1] = t.readInt32BE(we * 4 + 4);
      for (;we < 160; we += 2) {
        var ye = e[we - 30], xe = e[we - 15 * 2 + 1], Re = j4(ye, xe), Ee = Z4(xe, ye);
        ye = e[we - 2 * 2], xe = e[we - 2 * 2 + 1];
        var Ae = V4(ye, xe), P2 = $4(xe, ye), Se = e[we - 7 * 2], v = e[we - 7 * 2 + 1], i = e[we - 16 * 2], a2 = e[we - 16 * 2 + 1], h3 = Ee + v | 0, s2 = Re + Se + Pt(h3, Ee) | 0;
        h3 = h3 + P2 | 0, s2 = s2 + Ae + Pt(h3, P2) | 0, h3 = h3 + a2 | 0, s2 = s2 + i + Pt(h3, a2) | 0, e[we] = s2, e[we + 1] = h3;
      }
      for (var u3 = 0;u3 < 160; u3 += 2) {
        s2 = e[u3], h3 = e[u3 + 1];
        var c2 = kp(r, o, f2), b2 = kp(S2, E3, B3), l2 = Lp(r, S2), n = Lp(S2, r), d2 = Np(m2, L3), w = Np(L3, m2), g3 = Ip[u3], _3 = Ip[u3 + 1], A2 = Tp(m2, y3, M2), R2 = Tp(L3, ge, _e), I3 = N3 + w | 0, Me = x3 + d2 + Pt(I3, N3) | 0;
        I3 = I3 + R2 | 0, Me = Me + A2 + Pt(I3, R2) | 0, I3 = I3 + _3 | 0, Me = Me + g3 + Pt(I3, _3) | 0, I3 = I3 + h3 | 0, Me = Me + s2 + Pt(I3, h3) | 0;
        var k3 = n + b2 | 0, D2 = l2 + c2 + Pt(k3, n) | 0;
        x3 = M2, N3 = _e, M2 = y3, _e = ge, y3 = m2, ge = L3, L3 = q2 + I3 | 0, m2 = p2 + Me + Pt(L3, q2) | 0, p2 = f2, q2 = B3, f2 = o, B3 = E3, o = r, E3 = S2, S2 = I3 + k3 | 0, r = Me + D2 + Pt(S2, I3) | 0;
      }
      this._al = this._al + S2 | 0, this._bl = this._bl + E3 | 0, this._cl = this._cl + B3 | 0, this._dl = this._dl + q2 | 0, this._el = this._el + L3 | 0, this._fl = this._fl + ge | 0, this._gl = this._gl + _e | 0, this._hl = this._hl + N3 | 0, this._ah = this._ah + r + Pt(this._al, S2) | 0, this._bh = this._bh + o + Pt(this._bl, E3) | 0, this._ch = this._ch + f2 + Pt(this._cl, B3) | 0, this._dh = this._dh + p2 + Pt(this._dl, q2) | 0, this._eh = this._eh + m2 + Pt(this._el, L3) | 0, this._fh = this._fh + y3 + Pt(this._fl, ge) | 0, this._gh = this._gh + M2 + Pt(this._gl, _e) | 0, this._hh = this._hh + x3 + Pt(this._hl, N3) | 0;
    };
    ca.prototype._hash = function() {
      var t = W4.allocUnsafe(64);
      function e(r, o, f2) {
        t.writeInt32BE(r, f2), t.writeInt32BE(o, f2 + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
    };
    Pp.exports = ca;
  });
  Op = T2((AI, Cp) => {
    var G4 = Ie(), Y4 = yh(), X4 = pn(), J4 = Te().Buffer, Q4 = new Array(160);
    function To() {
      this.init(), this._w = Q4, X4.call(this, 128, 112);
    }
    G4(To, Y4);
    To.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    To.prototype._hash = function() {
      var t = J4.allocUnsafe(48);
      function e(r, o, f2) {
        t.writeInt32BE(r, f2), t.writeInt32BE(o, f2 + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
    };
    Cp.exports = To;
  });
  ko = T2((ci, Fp) => {
    var ci = Fp.exports = function(e) {
      e = e.toLowerCase();
      var r = ci[e];
      if (!r)
        throw new Error(e + " is not supported (we accept pull requests)");
      return new r;
    };
    ci.sha = _p();
    ci.sha1 = Ep();
    ci.sha224 = qp();
    ci.sha256 = gh();
    ci.sha384 = Op();
    ci.sha512 = yh();
  });
  Tt = T2((RI, Up) => {
    Up.exports = { ArrayIsArray(t) {
      return Array.isArray(t);
    }, ArrayPrototypeIncludes(t, e) {
      return t.includes(e);
    }, ArrayPrototypeIndexOf(t, e) {
      return t.indexOf(e);
    }, ArrayPrototypeJoin(t, e) {
      return t.join(e);
    }, ArrayPrototypeMap(t, e) {
      return t.map(e);
    }, ArrayPrototypePop(t, e) {
      return t.pop(e);
    }, ArrayPrototypePush(t, e) {
      return t.push(e);
    }, ArrayPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, Error, FunctionPrototypeCall(t, e, ...r) {
      return t.call(e, ...r);
    }, FunctionPrototypeSymbolHasInstance(t, e) {
      return Function.prototype[Symbol.hasInstance].call(t, e);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e) {
      return Object.defineProperties(t, e);
    }, ObjectDefineProperty(t, e, r) {
      return Object.defineProperty(t, e, r);
    }, ObjectGetOwnPropertyDescriptor(t, e) {
      return Object.getOwnPropertyDescriptor(t, e);
    }, ObjectKeys(t) {
      return Object.keys(t);
    }, ObjectSetPrototypeOf(t, e) {
      return Object.setPrototypeOf(t, e);
    }, Promise, PromisePrototypeCatch(t, e) {
      return t.catch(e);
    }, PromisePrototypeThen(t, e, r) {
      return t.then(e, r);
    }, PromiseReject(t) {
      return Promise.reject(t);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e) {
      return t.test(e);
    }, SafeSet: Set, String, StringPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, StringPrototypeToLowerCase(t) {
      return t.toLowerCase();
    }, StringPrototypeToUpperCase(t) {
      return t.toUpperCase();
    }, StringPrototypeTrim(t) {
      return t.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e, r) {
      return t.set(e, r);
    }, Uint8Array };
  });
  Gr = T2((BI, Mh) => {
    var e_ = Ut(), t_ = Object.getPrototypeOf(async function() {
    }).constructor, zp = globalThis.Blob || e_.Blob, r_ = typeof zp < "u" ? function(e) {
      return e instanceof zp;
    } : function(e) {
      return false;
    }, wh = class extends Error {
      constructor(e) {
        if (!Array.isArray(e))
          throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
        let r = "";
        for (let o = 0;o < e.length; o++)
          r += `    ${e[o].stack}
`;
        super(r), this.name = "AggregateError", this.errors = e;
      }
    };
    Mh.exports = { AggregateError: wh, kEmptyObject: Object.freeze({}), once(t) {
      let e = false;
      return function(...r) {
        e || (e = true, t.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let t, e;
      return { promise: new Promise((o, f2) => {
        t = o, e = f2;
      }), resolve: t, reject: e };
    }, promisify(t) {
      return new Promise((e, r) => {
        t((o, ...f2) => o ? r(o) : e(...f2));
      });
    }, debuglog() {
      return function() {
      };
    }, format(t, ...e) {
      return t.replace(/%([sdifj])/g, function(...[r, o]) {
        let f2 = e.shift();
        return o === "f" ? f2.toFixed(6) : o === "j" ? JSON.stringify(f2) : o === "s" && typeof f2 == "object" ? `${f2.constructor !== Object ? f2.constructor.name : ""} {}`.trim() : f2.toString();
      });
    }, inspect(t) {
      switch (typeof t) {
        case "string":
          if (t.includes("'"))
            if (t.includes('"')) {
              if (!t.includes("`") && !t.includes("${"))
                return `\`${t}\``;
            } else
              return `"${t}"`;
          return `'${t}'`;
        case "number":
          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
        case "bigint":
          return `${String(t)}n`;
        case "boolean":
        case "undefined":
          return String(t);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(t) {
      return t instanceof t_;
    }, isArrayBufferView(t) {
      return ArrayBuffer.isView(t);
    } }, isBlob: r_ };
    Mh.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  No = T2((qI, Lo) => {
    var { AbortController: Hp, AbortSignal: i_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Lo.exports = Hp;
    Lo.exports.AbortSignal = i_;
    Lo.exports.default = Hp;
  });
  Jt = T2((II, jp) => {
    var { format: n_, inspect: Do, AggregateError: f_ } = Gr(), a_ = globalThis.AggregateError || f_, o_ = Symbol("kIsNodeError"), s_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], h_ = /^([A-Z][a-z0-9]*)+$/, u_ = "__node_internal_", Po = {};
    function vn(t, e) {
      if (!t)
        throw new Po.ERR_INTERNAL_ASSERTION(e);
    }
    function Wp(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function l_(t, e, r) {
      if (typeof e == "function")
        return vn(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), e(...r);
      let o = (e.match(/%[dfijoOs]/g) || []).length;
      return vn(o === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o}).`), r.length === 0 ? e : n_(e, ...r);
    }
    function zt(t, e, r) {
      r || (r = Error);

      class o extends r {
        constructor(...p2) {
          super(l_(t, e, p2));
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      }
      Object.defineProperties(o.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${t}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), o.prototype.code = t, o.prototype[o_] = true, Po[t] = o;
    }
    function Kp(t) {
      let e = u_ + t.name;
      return Object.defineProperty(t, "name", { value: e }), t;
    }
    function d_(t, e) {
      if (t && e && t !== e) {
        if (Array.isArray(e.errors))
          return e.errors.push(t), e;
        let r = new a_([e, t], e.message);
        return r.code = e.code, r;
      }
      return t || e;
    }
    var _h = class extends Error {
      constructor(e = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new Po.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    zt("ERR_ASSERTION", "%s", Error);
    zt("ERR_INVALID_ARG_TYPE", (t, e, r) => {
      vn(typeof t == "string", "'name' must be a string"), Array.isArray(e) || (e = [e]);
      let o = "The ";
      t.endsWith(" argument") ? o += `${t} ` : o += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o += "must be ";
      let f2 = [], p2 = [], m2 = [];
      for (let M2 of e)
        vn(typeof M2 == "string", "All expected entries have to be of type string"), s_.includes(M2) ? f2.push(M2.toLowerCase()) : h_.test(M2) ? p2.push(M2) : (vn(M2 !== "object", 'The value "object" should be written as "Object"'), m2.push(M2));
      if (p2.length > 0) {
        let M2 = f2.indexOf("object");
        M2 !== -1 && (f2.splice(f2, M2, 1), p2.push("Object"));
      }
      if (f2.length > 0) {
        switch (f2.length) {
          case 1:
            o += `of type ${f2[0]}`;
            break;
          case 2:
            o += `one of type ${f2[0]} or ${f2[1]}`;
            break;
          default: {
            let M2 = f2.pop();
            o += `one of type ${f2.join(", ")}, or ${M2}`;
          }
        }
        (p2.length > 0 || m2.length > 0) && (o += " or ");
      }
      if (p2.length > 0) {
        switch (p2.length) {
          case 1:
            o += `an instance of ${p2[0]}`;
            break;
          case 2:
            o += `an instance of ${p2[0]} or ${p2[1]}`;
            break;
          default: {
            let M2 = p2.pop();
            o += `an instance of ${p2.join(", ")}, or ${M2}`;
          }
        }
        m2.length > 0 && (o += " or ");
      }
      switch (m2.length) {
        case 0:
          break;
        case 1:
          m2[0].toLowerCase() !== m2[0] && (o += "an "), o += `${m2[0]}`;
          break;
        case 2:
          o += `one of ${m2[0]} or ${m2[1]}`;
          break;
        default: {
          let M2 = m2.pop();
          o += `one of ${m2.join(", ")}, or ${M2}`;
        }
      }
      if (r == null)
        o += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        o += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var y3;
        (y3 = r.constructor) !== null && y3 !== undefined && y3.name ? o += `. Received an instance of ${r.constructor.name}` : o += `. Received ${Do(r, { depth: -1 })}`;
      } else {
        let M2 = Do(r, { colors: false });
        M2.length > 25 && (M2 = `${M2.slice(0, 25)}...`), o += `. Received type ${typeof r} (${M2})`;
      }
      return o;
    }, TypeError);
    zt("ERR_INVALID_ARG_VALUE", (t, e, r = "is invalid") => {
      let o = Do(e);
      return o.length > 128 && (o = o.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o}`;
    }, TypeError);
    zt("ERR_INVALID_RETURN_VALUE", (t, e, r) => {
      var o;
      let f2 = r != null && (o = r.constructor) !== null && o !== undefined && o.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${t} to be returned from the "${e}" function but got ${f2}.`;
    }, TypeError);
    zt("ERR_MISSING_ARGS", (...t) => {
      vn(t.length > 0, "At least one arg needs to be specified");
      let e, r = t.length;
      switch (t = (Array.isArray(t) ? t : [t]).map((o) => `"${o}"`).join(" or "), r) {
        case 1:
          e += `The ${t[0]} argument`;
          break;
        case 2:
          e += `The ${t[0]} and ${t[1]} arguments`;
          break;
        default:
          {
            let o = t.pop();
            e += `The ${t.join(", ")}, and ${o} arguments`;
          }
          break;
      }
      return `${e} must be specified`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", (t, e, r) => {
      vn(e, 'Missing "range" argument');
      let o;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = Wp(String(r)) : typeof r == "bigint" ? (o = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o = Wp(o)), o += "n") : o = Do(r), `The value of "${t}" is out of range. It must be ${e}. Received ${o}`;
    }, RangeError);
    zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    jp.exports = { AbortError: _h, aggregateTwoErrors: Kp(d_), hideStackFrames: Kp, codes: Po };
  });
  pa = T2((TI, Qp) => {
    var { ArrayIsArray: $p, ArrayPrototypeIncludes: Gp, ArrayPrototypeJoin: Yp, ArrayPrototypeMap: c_, NumberIsInteger: Sh, NumberIsNaN: p_, NumberMAX_SAFE_INTEGER: v_, NumberMIN_SAFE_INTEGER: b_, NumberParseInt: m_, ObjectPrototypeHasOwnProperty: g_, RegExpPrototypeExec: y_, String: w_, StringPrototypeToUpperCase: M_, StringPrototypeTrim: __ } = Tt(), { hideStackFrames: Ir, codes: { ERR_SOCKET_BAD_PORT: x_, ERR_INVALID_ARG_TYPE: tr, ERR_INVALID_ARG_VALUE: Co, ERR_OUT_OF_RANGE: bn, ERR_UNKNOWN_SIGNAL: Zp } } = Jt(), { normalizeEncoding: S_ } = Gr(), { isAsyncFunction: E_, isArrayBufferView: A_ } = Gr().types, Vp = {};
    function R_(t) {
      return t === (t | 0);
    }
    function B_(t) {
      return t === t >>> 0;
    }
    var q_ = /^[0-7]+$/, I_ = "must be a 32-bit unsigned integer or an octal string";
    function T_(t, e, r) {
      if (typeof t > "u" && (t = r), typeof t == "string") {
        if (y_(q_, t) === null)
          throw new Co(e, t, I_);
        t = m_(t, 8);
      }
      return Xp(t, e), t;
    }
    var k_ = Ir((t, e, r = b_, o = v_) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o)
        throw new bn(e, `>= ${r} && <= ${o}`, t);
    }), L_ = Ir((t, e, r = -2147483648, o = 2147483647) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o)
        throw new bn(e, `>= ${r} && <= ${o}`, t);
    }), Xp = Ir((t, e, r = false) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      let o = r ? 1 : 0, f2 = 4294967295;
      if (t < o || t > f2)
        throw new bn(e, `>= ${o} && <= ${f2}`, t);
    });
    function Jp(t, e) {
      if (typeof t != "string")
        throw new tr(e, "string", t);
    }
    function N_(t, e, r = undefined, o) {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (r != null && t < r || o != null && t > o || (r != null || o != null) && p_(t))
        throw new bn(e, `${r != null ? `>= ${r}` : ""}${r != null && o != null ? " && " : ""}${o != null ? `<= ${o}` : ""}`, t);
    }
    var D_ = Ir((t, e, r) => {
      if (!Gp(r, t)) {
        let o = Yp(c_(r, (p2) => typeof p2 == "string" ? `'${p2}'` : w_(p2)), ", "), f2 = "must be one of: " + o;
        throw new Co(e, t, f2);
      }
    });
    function P_(t, e) {
      if (typeof t != "boolean")
        throw new tr(e, "boolean", t);
    }
    function xh(t, e, r) {
      return t == null || !g_(t, e) ? r : t[e];
    }
    var C_ = Ir((t, e, r = null) => {
      let o = xh(r, "allowArray", false), f2 = xh(r, "allowFunction", false);
      if (!xh(r, "nullable", false) && t === null || !o && $p(t) || typeof t != "object" && (!f2 || typeof t != "function"))
        throw new tr(e, "Object", t);
    }), O_ = Ir((t, e, r = 0) => {
      if (!$p(t))
        throw new tr(e, "Array", t);
      if (t.length < r) {
        let o = `must be longer than ${r}`;
        throw new Co(e, t, o);
      }
    });
    function F_(t, e = "signal") {
      if (Jp(t, e), Vp[t] === undefined)
        throw Vp[M_(t)] !== undefined ? new Zp(t + " (signals must use all capital letters)") : new Zp(t);
    }
    var U_ = Ir((t, e = "buffer") => {
      if (!A_(t))
        throw new tr(e, ["Buffer", "TypedArray", "DataView"], t);
    });
    function z_(t, e) {
      let r = S_(e), o = t.length;
      if (r === "hex" && o % 2 !== 0)
        throw new Co("encoding", e, `is invalid for data of length ${o}`);
    }
    function H_(t, e = "Port", r = true) {
      if (typeof t != "number" && typeof t != "string" || typeof t == "string" && __(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
        throw new x_(e, t, r);
      return t | 0;
    }
    var W_ = Ir((t, e) => {
      if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
        throw new tr(e, "AbortSignal", t);
    }), K_ = Ir((t, e) => {
      if (typeof t != "function")
        throw new tr(e, "Function", t);
    }), j_ = Ir((t, e) => {
      if (typeof t != "function" || E_(t))
        throw new tr(e, "Function", t);
    }), Z_ = Ir((t, e) => {
      if (t !== undefined)
        throw new tr(e, "undefined", t);
    });
    function V_(t, e, r) {
      if (!Gp(r, t))
        throw new tr(e, `('${Yp(r, "|")}')`, t);
    }
    Qp.exports = { isInt32: R_, isUint32: B_, parseFileMode: T_, validateArray: O_, validateBoolean: P_, validateBuffer: U_, validateEncoding: z_, validateFunction: K_, validateInt32: L_, validateInteger: k_, validateNumber: N_, validateObject: C_, validateOneOf: D_, validatePlainFunction: j_, validatePort: H_, validateSignalName: F_, validateString: Jp, validateUint32: Xp, validateUndefined: Z_, validateUnion: V_, validateAbortSignal: W_ };
  });
  Rh = T2((kI, i1) => {
    var dt = i1.exports = {}, Yr, Xr;
    function Eh() {
      throw new Error("setTimeout has not been defined");
    }
    function Ah() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Yr = setTimeout : Yr = Eh;
      } catch {
        Yr = Eh;
      }
      try {
        typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Ah;
      } catch {
        Xr = Ah;
      }
    })();
    function e1(t) {
      if (Yr === setTimeout)
        return setTimeout(t, 0);
      if ((Yr === Eh || !Yr) && setTimeout)
        return Yr = setTimeout, setTimeout(t, 0);
      try {
        return Yr(t, 0);
      } catch {
        try {
          return Yr.call(null, t, 0);
        } catch {
          return Yr.call(this, t, 0);
        }
      }
    }
    function $_(t) {
      if (Xr === clearTimeout)
        return clearTimeout(t);
      if ((Xr === Ah || !Xr) && clearTimeout)
        return Xr = clearTimeout, clearTimeout(t);
      try {
        return Xr(t);
      } catch {
        try {
          return Xr.call(null, t);
        } catch {
          return Xr.call(this, t);
        }
      }
    }
    var pi = [], nf = false, mn, Oo = -1;
    function G_() {
      !nf || !mn || (nf = false, mn.length ? pi = mn.concat(pi) : Oo = -1, pi.length && t1());
    }
    function t1() {
      if (!nf) {
        var t = e1(G_);
        nf = true;
        for (var e = pi.length;e; ) {
          for (mn = pi, pi = [];++Oo < e; )
            mn && mn[Oo].run();
          Oo = -1, e = pi.length;
        }
        mn = null, nf = false, $_(t);
      }
    }
    dt.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          e[r - 1] = arguments[r];
      pi.push(new r1(t, e)), pi.length === 1 && !nf && e1(t1);
    };
    function r1(t, e) {
      this.fun = t, this.array = e;
    }
    r1.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    dt.title = "browser";
    dt.browser = true;
    dt.env = {};
    dt.argv = [];
    dt.version = "";
    dt.versions = {};
    function vi() {
    }
    dt.on = vi;
    dt.addListener = vi;
    dt.once = vi;
    dt.off = vi;
    dt.removeListener = vi;
    dt.removeAllListeners = vi;
    dt.emit = vi;
    dt.prependListener = vi;
    dt.prependOnceListener = vi;
    dt.listeners = function(t) {
      return [];
    };
    dt.binding = function(t) {
      throw new Error("process.binding is not supported");
    };
    dt.cwd = function() {
      return "/";
    };
    dt.chdir = function(t) {
      throw new Error("process.chdir is not supported");
    };
    dt.umask = function() {
      return 0;
    };
  });
  pr = {};
  Ja(pr, { default: () => Y_ });
  Oi = R0(() => {
    ot(pr, rn(Rh()));
    Y_ = rn(Rh());
  });
  Fi = T2((NI, v1) => {
    var { Symbol: Fo, SymbolAsyncIterator: n1, SymbolIterator: f1 } = Tt(), a1 = Fo("kDestroyed"), o1 = Fo("kIsErrored"), Bh = Fo("kIsReadable"), s1 = Fo("kIsDisturbed");
    function Uo(t, e = false) {
      var r;
      return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
    }
    function zo(t) {
      var e;
      return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e = t._writableState) === null || e === undefined ? undefined : e.writable) !== false));
    }
    function X_(t) {
      return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
    }
    function gn(t) {
      return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
    }
    function J_(t, e) {
      return t == null ? false : e === true ? typeof t[n1] == "function" : e === false ? typeof t[f1] == "function" : typeof t[n1] == "function" || typeof t[f1] == "function";
    }
    function Ho(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !!(t.destroyed || t[a1] || o != null && o.destroyed);
    }
    function h1(t) {
      if (!zo(t))
        return null;
      if (t.writableEnded === true)
        return true;
      let e = t._writableState;
      return e != null && e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function Q_(t, e) {
      if (!zo(t))
        return null;
      if (t.writableFinished === true)
        return true;
      let r = t._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e === false && r.ended === true && r.length === 0);
    }
    function e8(t) {
      if (!Uo(t))
        return null;
      if (t.readableEnded === true)
        return true;
      let e = t._readableState;
      return !e || e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function u1(t, e) {
      if (!Uo(t))
        return null;
      let r = t._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e === false && r.ended === true && r.length === 0);
    }
    function l1(t) {
      return t && t[Bh] != null ? t[Bh] : typeof t?.readable != "boolean" ? null : Ho(t) ? false : Uo(t) && t.readable && !u1(t);
    }
    function d1(t) {
      return typeof t?.writable != "boolean" ? null : Ho(t) ? false : zo(t) && t.writable && !h1(t);
    }
    function t8(t, e) {
      return gn(t) ? Ho(t) ? true : !(e?.readable !== false && l1(t) || e?.writable !== false && d1(t)) : null;
    }
    function r8(t) {
      var e, r;
      return gn(t) ? t.writableErrored ? t.writableErrored : (e = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function i8(t) {
      var e, r;
      return gn(t) ? t.readableErrored ? t.readableErrored : (e = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function n8(t) {
      if (!gn(t))
        return null;
      if (typeof t.closed == "boolean")
        return t.closed;
      let { _writableState: e, _readableState: r } = t;
      return typeof e?.closed == "boolean" || typeof r?.closed == "boolean" ? e?.closed || r?.closed : typeof t._closed == "boolean" && c1(t) ? t._closed : null;
    }
    function c1(t) {
      return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
    }
    function p1(t) {
      return typeof t._sent100 == "boolean" && c1(t);
    }
    function f8(t) {
      var e;
      return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e = t.req) === null || e === undefined ? undefined : e.upgradeOrConnect) === undefined;
    }
    function a8(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !o && p1(t) || !!(o && o.autoDestroy && o.emitClose && o.closed === false);
    }
    function o8(t) {
      var e;
      return !!(t && ((e = t[s1]) !== null && e !== undefined ? e : t.readableDidRead || t.readableAborted));
    }
    function s8(t) {
      var e, r, o, f2, p2, m2, y3, M2, x3, S2;
      return !!(t && ((e = (r = (o = (f2 = (p2 = (m2 = t[o1]) !== null && m2 !== undefined ? m2 : t.readableErrored) !== null && p2 !== undefined ? p2 : t.writableErrored) !== null && f2 !== undefined ? f2 : (y3 = t._readableState) === null || y3 === undefined ? undefined : y3.errorEmitted) !== null && o !== undefined ? o : (M2 = t._writableState) === null || M2 === undefined ? undefined : M2.errorEmitted) !== null && r !== undefined ? r : (x3 = t._readableState) === null || x3 === undefined ? undefined : x3.errored) !== null && e !== undefined ? e : (S2 = t._writableState) === null || S2 === undefined ? undefined : S2.errored));
    }
    v1.exports = { kDestroyed: a1, isDisturbed: o8, kIsDisturbed: s1, isErrored: s8, kIsErrored: o1, isReadable: l1, kIsReadable: Bh, isClosed: n8, isDestroyed: Ho, isDuplexNodeStream: X_, isFinished: t8, isIterable: J_, isReadableNodeStream: Uo, isReadableEnded: e8, isReadableFinished: u1, isReadableErrored: i8, isNodeStream: gn, isWritable: d1, isWritableNodeStream: zo, isWritableEnded: h1, isWritableFinished: Q_, isWritableErrored: r8, isServerRequest: f8, isServerResponse: p1, willEmitClose: a8 };
  });
  Ui = T2((DI, Ih) => {
    var ff = (Oi(), ur(pr)), { AbortError: h8, codes: u8 } = Jt(), { ERR_INVALID_ARG_TYPE: l8, ERR_STREAM_PREMATURE_CLOSE: b1 } = u8, { kEmptyObject: m1, once: g1 } = Gr(), { validateAbortSignal: d8, validateFunction: c8, validateObject: p8 } = pa(), { Promise: v8 } = Tt(), { isClosed: b8, isReadable: y1, isReadableNodeStream: qh, isReadableFinished: w1, isReadableErrored: m8, isWritable: M1, isWritableNodeStream: _1, isWritableFinished: x1, isWritableErrored: g8, isNodeStream: y8, willEmitClose: w8 } = Fi();
    function M8(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    var _8 = () => {
    };
    function S1(t, e, r) {
      var o, f2;
      arguments.length === 2 ? (r = e, e = m1) : e == null ? e = m1 : p8(e, "options"), c8(r, "callback"), d8(e.signal, "options.signal"), r = g1(r);
      let p2 = (o = e.readable) !== null && o !== undefined ? o : qh(t), m2 = (f2 = e.writable) !== null && f2 !== undefined ? f2 : _1(t);
      if (!y8(t))
        throw new l8("stream", "Stream", t);
      let { _writableState: y3, _readableState: M2 } = t, x3 = () => {
        t.writable || B3();
      }, S2 = w8(t) && qh(t) === p2 && _1(t) === m2, E3 = x1(t, false), B3 = () => {
        E3 = true, t.destroyed && (S2 = false), !(S2 && (!t.readable || p2)) && (!p2 || q2) && r.call(t);
      }, q2 = w1(t, false), L3 = () => {
        q2 = true, t.destroyed && (S2 = false), !(S2 && (!t.writable || m2)) && (!m2 || E3) && r.call(t);
      }, ge = (xe) => {
        r.call(t, xe);
      }, _e = b8(t), N3 = () => {
        _e = true;
        let xe = g8(t) || m8(t);
        if (xe && typeof xe != "boolean")
          return r.call(t, xe);
        if (p2 && !q2 && qh(t, true) && !w1(t, false))
          return r.call(t, new b1);
        if (m2 && !E3 && !x1(t, false))
          return r.call(t, new b1);
        r.call(t);
      }, we = () => {
        t.req.on("finish", B3);
      };
      M8(t) ? (t.on("complete", B3), S2 || t.on("abort", N3), t.req ? we() : t.on("request", we)) : m2 && !y3 && (t.on("end", x3), t.on("close", x3)), !S2 && typeof t.aborted == "boolean" && t.on("aborted", N3), t.on("end", L3), t.on("finish", B3), e.error !== false && t.on("error", ge), t.on("close", N3), _e ? ff.nextTick(N3) : y3 != null && y3.errorEmitted || M2 != null && M2.errorEmitted ? S2 || ff.nextTick(N3) : (!p2 && (!S2 || y1(t)) && (E3 || M1(t) === false) || !m2 && (!S2 || M1(t)) && (q2 || y1(t) === false) || M2 && t.req && t.aborted) && ff.nextTick(N3);
      let ye = () => {
        r = _8, t.removeListener("aborted", N3), t.removeListener("complete", B3), t.removeListener("abort", N3), t.removeListener("request", we), t.req && t.req.removeListener("finish", B3), t.removeListener("end", x3), t.removeListener("close", x3), t.removeListener("finish", B3), t.removeListener("end", L3), t.removeListener("error", ge), t.removeListener("close", N3);
      };
      if (e.signal && !_e) {
        let xe = () => {
          let Re = r;
          ye(), Re.call(t, new h8(undefined, { cause: e.signal.reason }));
        };
        if (e.signal.aborted)
          ff.nextTick(xe);
        else {
          let Re = r;
          r = g1((...Ee) => {
            e.signal.removeEventListener("abort", xe), Re.apply(t, Ee);
          }), e.signal.addEventListener("abort", xe);
        }
      }
      return ye;
    }
    function x8(t, e) {
      return new v8((r, o) => {
        S1(t, e, (f2) => {
          f2 ? o(f2) : r();
        });
      });
    }
    Ih.exports = S1;
    Ih.exports.finished = x8;
  });
  k1 = T2((PI, Lh) => {
    var B1 = globalThis.AbortController || No().AbortController, { codes: { ERR_INVALID_ARG_TYPE: va, ERR_MISSING_ARGS: S8, ERR_OUT_OF_RANGE: E8 }, AbortError: Jr } = Jt(), { validateAbortSignal: af, validateInteger: A8, validateObject: of } = pa(), R8 = Tt().Symbol("kWeak"), { finished: B8 } = Ui(), { ArrayPrototypePush: q8, MathFloor: I8, Number: T8, NumberIsNaN: k8, Promise: E1, PromiseReject: A1, PromisePrototypeThen: L8, Symbol: q1 } = Tt(), Wo = q1("kEmpty"), R1 = q1("kEof");
    function Ko(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal");
      let r = 1;
      return e?.concurrency != null && (r = I8(e.concurrency)), A8(r, "concurrency", 1), async function* () {
        var f2, p2;
        let m2 = new B1, y3 = this, M2 = [], x3 = m2.signal, S2 = { signal: x3 }, E3 = () => m2.abort();
        e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted && E3(), e == null || (p2 = e.signal) === null || p2 === undefined || p2.addEventListener("abort", E3);
        let B3, q2, L3 = false;
        function ge() {
          L3 = true;
        }
        async function _e() {
          try {
            for await (let ye of y3) {
              var N3;
              if (L3)
                return;
              if (x3.aborted)
                throw new Jr;
              try {
                ye = t(ye, S2);
              } catch (xe) {
                ye = A1(xe);
              }
              ye !== Wo && (typeof ((N3 = ye) === null || N3 === undefined ? undefined : N3.catch) == "function" && ye.catch(ge), M2.push(ye), B3 && (B3(), B3 = null), !L3 && M2.length && M2.length >= r && await new E1((xe) => {
                q2 = xe;
              }));
            }
            M2.push(R1);
          } catch (ye) {
            let xe = A1(ye);
            L8(xe, undefined, ge), M2.push(xe);
          } finally {
            var we;
            L3 = true, B3 && (B3(), B3 = null), e == null || (we = e.signal) === null || we === undefined || we.removeEventListener("abort", E3);
          }
        }
        _e();
        try {
          for (;; ) {
            for (;M2.length > 0; ) {
              let N3 = await M2[0];
              if (N3 === R1)
                return;
              if (x3.aborted)
                throw new Jr;
              N3 !== Wo && (yield N3), M2.shift(), q2 && (q2(), q2 = null);
            }
            await new E1((N3) => {
              B3 = N3;
            });
          }
        } finally {
          m2.abort(), L3 = true, q2 && (q2(), q2 = null);
        }
      }.call(this);
    }
    function N8(t = undefined) {
      return t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let f2 of this) {
          var o;
          if (t != null && (o = t.signal) !== null && o !== undefined && o.aborted)
            throw new Jr({ cause: t.signal.reason });
          yield [r++, f2];
        }
      }.call(this);
    }
    async function I1(t, e = undefined) {
      for await (let r of kh.call(this, t, e))
        return true;
      return false;
    }
    async function D8(t, e = undefined) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      return !await I1.call(this, async (...r) => !await t(...r), e);
    }
    async function P8(t, e) {
      for await (let r of kh.call(this, t, e))
        return r;
    }
    async function C8(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f2) {
        return await t(o, f2), Wo;
      }
      for await (let o of Ko.call(this, r, e))
        ;
    }
    function kh(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f2) {
        return await t(o, f2) ? o : Wo;
      }
      return Ko.call(this, r, e);
    }
    var Th = class extends S8 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function O8(t, e, r) {
      var o;
      if (typeof t != "function")
        throw new va("reducer", ["Function", "AsyncFunction"], t);
      r != null && of(r, "options"), r?.signal != null && af(r.signal, "options.signal");
      let f2 = arguments.length > 1;
      if (r != null && (o = r.signal) !== null && o !== undefined && o.aborted) {
        let x3 = new Jr(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await B8(this.destroy(x3)), x3;
      }
      let p2 = new B1, m2 = p2.signal;
      if (r != null && r.signal) {
        let x3 = { once: true, [R8]: this };
        r.signal.addEventListener("abort", () => p2.abort(), x3);
      }
      let y3 = false;
      try {
        for await (let x3 of this) {
          var M2;
          if (y3 = true, r != null && (M2 = r.signal) !== null && M2 !== undefined && M2.aborted)
            throw new Jr;
          f2 ? e = await t(e, x3, { signal: m2 }) : (e = x3, f2 = true);
        }
        if (!y3 && !f2)
          throw new Th;
      } finally {
        p2.abort();
      }
      return e;
    }
    async function F8(t) {
      t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal");
      let e = [];
      for await (let o of this) {
        var r;
        if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
          throw new Jr(undefined, { cause: t.signal.reason });
        q8(e, o);
      }
      return e;
    }
    function U8(t, e) {
      let r = Ko.call(this, t, e);
      return async function* () {
        for await (let f2 of r)
          yield* f2;
      }.call(this);
    }
    function T1(t) {
      if (t = T8(t), k8(t))
        return 0;
      if (t < 0)
        throw new E8("number", ">= 0", t);
      return t;
    }
    function z8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p2 of this) {
          var f2;
          if (e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted)
            throw new Jr;
          t-- <= 0 && (yield p2);
        }
      }.call(this);
    }
    function H8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p2 of this) {
          var f2;
          if (e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted)
            throw new Jr;
          if (t-- > 0)
            yield p2;
          else
            return;
        }
      }.call(this);
    }
    Lh.exports.streamReturningOperators = { asIndexedPairs: N8, drop: z8, filter: kh, flatMap: U8, map: Ko, take: H8 };
    Lh.exports.promiseReturningOperators = { every: D8, forEach: C8, reduce: O8, toArray: F8, some: I1, find: P8 };
  });
  yn = T2((CI, U1) => {
    var zi = (Oi(), ur(pr)), { aggregateTwoErrors: W8, codes: { ERR_MULTIPLE_CALLBACK: K8 }, AbortError: j8 } = Jt(), { Symbol: D1 } = Tt(), { kDestroyed: Z8, isDestroyed: V8, isFinished: $8, isServerRequest: G8 } = Fi(), P1 = D1("kDestroy"), Nh = D1("kConstruct");
    function C1(t, e, r) {
      t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
    }
    function Y8(t, e) {
      let r = this._readableState, o = this._writableState, f2 = o || r;
      return o && o.destroyed || r && r.destroyed ? (typeof e == "function" && e(), this) : (C1(t, o, r), o && (o.destroyed = true), r && (r.destroyed = true), f2.constructed ? L1(this, t, e) : this.once(P1, function(p2) {
        L1(this, W8(p2, t), e);
      }), this);
    }
    function L1(t, e, r) {
      let o = false;
      function f2(p2) {
        if (o)
          return;
        o = true;
        let { _readableState: m2, _writableState: y3 } = t;
        C1(p2, y3, m2), y3 && (y3.closed = true), m2 && (m2.closed = true), typeof r == "function" && r(p2), p2 ? zi.nextTick(X8, t, p2) : zi.nextTick(O1, t);
      }
      try {
        t._destroy(e || null, f2);
      } catch (p2) {
        f2(p2);
      }
    }
    function X8(t, e) {
      Dh(t, e), O1(t);
    }
    function O1(t) {
      let { _readableState: e, _writableState: r } = t;
      r && (r.closeEmitted = true), e && (e.closeEmitted = true), (r && r.emitClose || e && e.emitClose) && t.emit("close");
    }
    function Dh(t, e) {
      let { _readableState: r, _writableState: o } = t;
      o && o.errorEmitted || r && r.errorEmitted || (o && (o.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e));
    }
    function J8() {
      let t = this._readableState, e = this._writableState;
      t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e && (e.constructed = true, e.destroyed = false, e.closed = false, e.closeEmitted = false, e.errored = null, e.errorEmitted = false, e.finalCalled = false, e.prefinished = false, e.ended = e.writable === false, e.ending = e.writable === false, e.finished = e.writable === false);
    }
    function Ph(t, e, r) {
      let { _readableState: o, _writableState: f2 } = t;
      if (f2 && f2.destroyed || o && o.destroyed)
        return this;
      o && o.autoDestroy || f2 && f2.autoDestroy ? t.destroy(e) : e && (e.stack, f2 && !f2.errored && (f2.errored = e), o && !o.errored && (o.errored = e), r ? zi.nextTick(Dh, t, e) : Dh(t, e));
    }
    function Q8(t, e) {
      if (typeof t._construct != "function")
        return;
      let { _readableState: r, _writableState: o } = t;
      r && (r.constructed = false), o && (o.constructed = false), t.once(Nh, e), !(t.listenerCount(Nh) > 1) && zi.nextTick(e5, t);
    }
    function e5(t) {
      let e = false;
      function r(o) {
        if (e) {
          Ph(t, o ?? new K8);
          return;
        }
        e = true;
        let { _readableState: f2, _writableState: p2 } = t, m2 = p2 || f2;
        f2 && (f2.constructed = true), p2 && (p2.constructed = true), m2.destroyed ? t.emit(P1, o) : o ? Ph(t, o, true) : zi.nextTick(t5, t);
      }
      try {
        t._construct(r);
      } catch (o) {
        r(o);
      }
    }
    function t5(t) {
      t.emit(Nh);
    }
    function N1(t) {
      return t && t.setHeader && typeof t.abort == "function";
    }
    function F1(t) {
      t.emit("close");
    }
    function r5(t, e) {
      t.emit("error", e), zi.nextTick(F1, t);
    }
    function i5(t, e) {
      !t || V8(t) || (!e && !$8(t) && (e = new j8), G8(t) ? (t.socket = null, t.destroy(e)) : N1(t) ? t.abort() : N1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e) : typeof t.close == "function" ? t.close() : e ? zi.nextTick(r5, t, e) : zi.nextTick(F1, t), t.destroyed || (t[Z8] = true));
    }
    U1.exports = { construct: Q8, destroyer: i5, destroy: Y8, undestroy: J8, errorOrDestroy: Ph };
  });
  Vo = T2((OI, H1) => {
    var { ArrayIsArray: n5, ObjectSetPrototypeOf: z1 } = Tt(), { EventEmitter: jo } = ki();
    function Zo(t) {
      jo.call(this, t);
    }
    z1(Zo.prototype, jo.prototype);
    z1(Zo, jo);
    Zo.prototype.pipe = function(t, e) {
      let r = this;
      function o(S2) {
        t.writable && t.write(S2) === false && r.pause && r.pause();
      }
      r.on("data", o);
      function f2() {
        r.readable && r.resume && r.resume();
      }
      t.on("drain", f2), !t._isStdio && (!e || e.end !== false) && (r.on("end", m2), r.on("close", y3));
      let p2 = false;
      function m2() {
        p2 || (p2 = true, t.end());
      }
      function y3() {
        p2 || (p2 = true, typeof t.destroy == "function" && t.destroy());
      }
      function M2(S2) {
        x3(), jo.listenerCount(this, "error") === 0 && this.emit("error", S2);
      }
      Ch(r, "error", M2), Ch(t, "error", M2);
      function x3() {
        r.removeListener("data", o), t.removeListener("drain", f2), r.removeListener("end", m2), r.removeListener("close", y3), r.removeListener("error", M2), t.removeListener("error", M2), r.removeListener("end", x3), r.removeListener("close", x3), t.removeListener("close", x3);
      }
      return r.on("end", x3), r.on("close", x3), t.on("close", x3), t.emit("pipe", r), t;
    };
    function Ch(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : n5(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    H1.exports = { Stream: Zo, prependListener: Ch };
  });
  Go = T2((FI, $o) => {
    var { AbortError: f5, codes: a5 } = Jt(), o5 = Ui(), { ERR_INVALID_ARG_TYPE: W1 } = a5, s5 = (t, e) => {
      if (typeof t != "object" || !("aborted" in t))
        throw new W1(e, "AbortSignal", t);
    };
    function h5(t) {
      return !!(t && typeof t.pipe == "function");
    }
    $o.exports.addAbortSignal = function(e, r) {
      if (s5(e, "signal"), !h5(r))
        throw new W1("stream", "stream.Stream", r);
      return $o.exports.addAbortSignalNoValidate(e, r);
    };
    $o.exports.addAbortSignalNoValidate = function(t, e) {
      if (typeof t != "object" || !("aborted" in t))
        return e;
      let r = () => {
        e.destroy(new f5(undefined, { cause: t.reason }));
      };
      return t.aborted ? r() : (t.addEventListener("abort", r), o5(e, () => t.removeEventListener("abort", r))), e;
    };
  });
  Z1 = T2((zI, j1) => {
    var { StringPrototypeSlice: K1, SymbolIterator: u5, TypedArrayPrototypeSet: Yo, Uint8Array: l5 } = Tt(), { Buffer: Oh } = Ut(), { inspect: d5 } = Gr();
    j1.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e) {
        let r = { data: e, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(e) {
        let r = { data: e, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let e = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e) {
        if (this.length === 0)
          return "";
        let r = this.head, o = "" + r.data;
        for (;(r = r.next) !== null; )
          o += e + r.data;
        return o;
      }
      concat(e) {
        if (this.length === 0)
          return Oh.alloc(0);
        let r = Oh.allocUnsafe(e >>> 0), o = this.head, f2 = 0;
        for (;o; )
          Yo(r, o.data, f2), f2 += o.data.length, o = o.next;
        return r;
      }
      consume(e, r) {
        let o = this.head.data;
        if (e < o.length) {
          let f2 = o.slice(0, e);
          return this.head.data = o.slice(e), f2;
        }
        return e === o.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
      }
      first() {
        return this.head.data;
      }
      *[u5]() {
        for (let e = this.head;e; e = e.next)
          yield e.data;
      }
      _getString(e) {
        let r = "", o = this.head, f2 = 0;
        do {
          let p2 = o.data;
          if (e > p2.length)
            r += p2, e -= p2.length;
          else {
            e === p2.length ? (r += p2, ++f2, o.next ? this.head = o.next : this.head = this.tail = null) : (r += K1(p2, 0, e), this.head = o, o.data = K1(p2, e));
            break;
          }
          ++f2;
        } while ((o = o.next) !== null);
        return this.length -= f2, r;
      }
      _getBuffer(e) {
        let r = Oh.allocUnsafe(e), o = e, f2 = this.head, p2 = 0;
        do {
          let m2 = f2.data;
          if (e > m2.length)
            Yo(r, m2, o - e), e -= m2.length;
          else {
            e === m2.length ? (Yo(r, m2, o - e), ++p2, f2.next ? this.head = f2.next : this.head = this.tail = null) : (Yo(r, new l5(m2.buffer, m2.byteOffset, e), o - e), this.head = f2, f2.data = m2.slice(e));
            break;
          }
          ++p2;
        } while ((f2 = f2.next) !== null);
        return this.length -= p2, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e, r) {
        return d5(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Xo = T2((HI, $1) => {
    var { MathFloor: c5, NumberIsInteger: p5 } = Tt(), { ERR_INVALID_ARG_VALUE: v5 } = Jt().codes;
    function b5(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function V1(t) {
      return t ? 16 : 16 * 1024;
    }
    function m5(t, e, r, o) {
      let f2 = b5(e, o, r);
      if (f2 != null) {
        if (!p5(f2) || f2 < 0) {
          let p2 = o ? `options.${r}` : "options.highWaterMark";
          throw new v5(p2, f2);
        }
        return c5(f2);
      }
      return V1(t.objectMode);
    }
    $1.exports = { getHighWaterMark: m5, getDefaultHighWaterMark: V1 };
  });
  Fh = T2((WI, J1) => {
    var G1 = (Oi(), ur(pr)), { PromisePrototypeThen: g5, SymbolAsyncIterator: Y1, SymbolIterator: X1 } = Tt(), { Buffer: y5 } = Ut(), { ERR_INVALID_ARG_TYPE: w5, ERR_STREAM_NULL_VALUES: M5 } = Jt().codes;
    function _5(t, e, r) {
      let o;
      if (typeof e == "string" || e instanceof y5)
        return new t({ objectMode: true, ...r, read() {
          this.push(e), this.push(null);
        } });
      let f2;
      if (e && e[Y1])
        f2 = true, o = e[Y1]();
      else if (e && e[X1])
        f2 = false, o = e[X1]();
      else
        throw new w5("iterable", ["Iterable"], e);
      let p2 = new t({ objectMode: true, highWaterMark: 1, ...r }), m2 = false;
      p2._read = function() {
        m2 || (m2 = true, M2());
      }, p2._destroy = function(x3, S2) {
        g5(y3(x3), () => G1.nextTick(S2, x3), (E3) => G1.nextTick(S2, E3 || x3));
      };
      async function y3(x3) {
        let S2 = x3 != null, E3 = typeof o.throw == "function";
        if (S2 && E3) {
          let { value: B3, done: q2 } = await o.throw(x3);
          if (await B3, q2)
            return;
        }
        if (typeof o.return == "function") {
          let { value: B3 } = await o.return();
          await B3;
        }
      }
      async function M2() {
        for (;; ) {
          try {
            let { value: x3, done: S2 } = f2 ? await o.next() : o.next();
            if (S2)
              p2.push(null);
            else {
              let E3 = x3 && typeof x3.then == "function" ? await x3 : x3;
              if (E3 === null)
                throw m2 = false, new M5;
              if (p2.push(E3))
                continue;
              m2 = false;
            }
          } catch (x3) {
            p2.destroy(x3);
          }
          break;
        }
      }
      return p2;
    }
    J1.exports = _5;
  });
  ba = T2((KI, lv) => {
    var Tr = (Oi(), ur(pr)), { ArrayPrototypeIndexOf: x5, NumberIsInteger: S5, NumberIsNaN: E5, NumberParseInt: A5, ObjectDefineProperties: tv, ObjectKeys: R5, ObjectSetPrototypeOf: rv, Promise: B5, SafeSet: q5, SymbolAsyncIterator: I5, Symbol: T5 } = Tt();
    lv.exports = Le;
    Le.ReadableState = jh;
    var { EventEmitter: k5 } = ki(), { Stream: Hi, prependListener: L5 } = Vo(), { Buffer: Uh } = Ut(), { addAbortSignal: N5 } = Go(), D5 = Ui(), Pe = Gr().debuglog("stream", (t) => {
      Pe = t;
    }), P5 = Z1(), hf = yn(), { getHighWaterMark: C5, getDefaultHighWaterMark: O5 } = Xo(), { aggregateTwoErrors: Q1, codes: { ERR_INVALID_ARG_TYPE: F5, ERR_METHOD_NOT_IMPLEMENTED: U5, ERR_OUT_OF_RANGE: z5, ERR_STREAM_PUSH_AFTER_EOF: H5, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W5 } } = Jt(), { validateObject: K5 } = pa(), wn = T5("kPaused"), { StringDecoder: iv } = co(), j5 = Fh();
    rv(Le.prototype, Hi.prototype);
    rv(Le, Hi);
    var zh = () => {
    }, { errorOrDestroy: sf } = hf;
    function jh(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? C5(this, t, "readableHighWaterMark", r) : O5(false), this.buffer = new P5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[wn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new iv(t.encoding), this.encoding = t.encoding);
    }
    function Le(t) {
      if (!(this instanceof Le))
        return new Le(t);
      let e = this instanceof Qr();
      this._readableState = new jh(t, this, e), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e && N5(t.signal, this)), Hi.call(this, t), hf.construct(this, () => {
        this._readableState.needReadable && Jo(this, this._readableState);
      });
    }
    Le.prototype.destroy = hf.destroy;
    Le.prototype._undestroy = hf.undestroy;
    Le.prototype._destroy = function(t, e) {
      e(t);
    };
    Le.prototype[k5.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    Le.prototype.push = function(t, e) {
      return nv(this, t, e, false);
    };
    Le.prototype.unshift = function(t, e) {
      return nv(this, t, e, true);
    };
    function nv(t, e, r, o) {
      Pe("readableAddChunk", e);
      let f2 = t._readableState, p2;
      if (f2.objectMode || (typeof e == "string" ? (r = r || f2.defaultEncoding, f2.encoding !== r && (o && f2.encoding ? e = Uh.from(e, r).toString(f2.encoding) : (e = Uh.from(e, r), r = ""))) : e instanceof Uh ? r = "" : Hi._isUint8Array(e) ? (e = Hi._uint8ArrayToBuffer(e), r = "") : e != null && (p2 = new F5("chunk", ["string", "Buffer", "Uint8Array"], e))), p2)
        sf(t, p2);
      else if (e === null)
        f2.reading = false, $5(t, f2);
      else if (f2.objectMode || e && e.length > 0)
        if (o)
          if (f2.endEmitted)
            sf(t, new W5);
          else {
            if (f2.destroyed || f2.errored)
              return false;
            Hh(t, f2, e, true);
          }
        else if (f2.ended)
          sf(t, new H5);
        else {
          if (f2.destroyed || f2.errored)
            return false;
          f2.reading = false, f2.decoder && !r ? (e = f2.decoder.write(e), f2.objectMode || e.length !== 0 ? Hh(t, f2, e, false) : Jo(t, f2)) : Hh(t, f2, e, false);
        }
      else
        o || (f2.reading = false, Jo(t, f2));
      return !f2.ended && (f2.length < f2.highWaterMark || f2.length === 0);
    }
    function Hh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, e.dataEmitted = true, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Qo(t)), Jo(t, e);
    }
    Le.prototype.isPaused = function() {
      let t = this._readableState;
      return t[wn] === true || t.flowing === false;
    };
    Le.prototype.setEncoding = function(t) {
      let e = new iv(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, o = "";
      for (let f2 of r)
        o += e.write(f2);
      return r.clear(), o !== "" && r.push(o), this._readableState.length = o.length, this;
    };
    var Z5 = 1073741824;
    function V5(t) {
      if (t > Z5)
        throw new z5("size", "<= 1GiB", t);
      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
    }
    function ev(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : E5(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
    }
    Le.prototype.read = function(t) {
      Pe("read", t), t === undefined ? t = NaN : S5(t) || (t = A5(t, 10));
      let e = this._readableState, r = t;
      if (t > e.highWaterMark && (e.highWaterMark = V5(t)), t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Pe("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Wh(this) : Qo(this), null;
      if (t = ev(t, e), t === 0 && e.ended)
        return e.length === 0 && Wh(this), null;
      let o = e.needReadable;
      if (Pe("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Pe("length less than watermark", o)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed)
        o = false, Pe("reading, ended or constructing", o);
      else if (o) {
        Pe("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true);
        try {
          this._read(e.highWaterMark);
        } catch (p2) {
          sf(this, p2);
        }
        e.sync = false, e.reading || (t = ev(r, e));
      }
      let f2;
      return t > 0 ? f2 = hv(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Wh(this)), f2 !== null && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = true, this.emit("data", f2)), f2;
    };
    function $5(t, e) {
      if (Pe("onEofChunk"), !e.ended) {
        if (e.decoder) {
          let r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Qo(t) : (e.needReadable = false, e.emittedReadable = true, fv(t));
      }
    }
    function Qo(t) {
      let e = t._readableState;
      Pe("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Pe("emitReadable", e.flowing), e.emittedReadable = true, Tr.nextTick(fv, t));
    }
    function fv(t) {
      let e = t._readableState;
      Pe("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ov(t);
    }
    function Jo(t, e) {
      !e.readingMore && e.constructed && (e.readingMore = true, Tr.nextTick(G5, t, e));
    }
    function G5(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        let r = e.length;
        if (Pe("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Le.prototype._read = function(t) {
      throw new U5("_read()");
    };
    Le.prototype.pipe = function(t, e) {
      let r = this, o = this._readableState;
      o.pipes.length === 1 && (o.multiAwaitDrain || (o.multiAwaitDrain = true, o.awaitDrainWriters = new q5(o.awaitDrainWriters ? [o.awaitDrainWriters] : []))), o.pipes.push(t), Pe("pipe count=%d opts=%j", o.pipes.length, e);
      let p2 = (!e || e.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y3 : _e;
      o.endEmitted ? Tr.nextTick(p2) : r.once("end", p2), t.on("unpipe", m2);
      function m2(N3, we) {
        Pe("onunpipe"), N3 === r && we && we.hasUnpiped === false && (we.hasUnpiped = true, S2());
      }
      function y3() {
        Pe("onend"), t.end();
      }
      let M2, x3 = false;
      function S2() {
        Pe("cleanup"), t.removeListener("close", L3), t.removeListener("finish", ge), M2 && t.removeListener("drain", M2), t.removeListener("error", q2), t.removeListener("unpipe", m2), r.removeListener("end", y3), r.removeListener("end", _e), r.removeListener("data", B3), x3 = true, M2 && o.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M2();
      }
      function E3() {
        x3 || (o.pipes.length === 1 && o.pipes[0] === t ? (Pe("false write response, pause", 0), o.awaitDrainWriters = t, o.multiAwaitDrain = false) : o.pipes.length > 1 && o.pipes.includes(t) && (Pe("false write response, pause", o.awaitDrainWriters.size), o.awaitDrainWriters.add(t)), r.pause()), M2 || (M2 = Y5(r, t), t.on("drain", M2));
      }
      r.on("data", B3);
      function B3(N3) {
        Pe("ondata");
        let we = t.write(N3);
        Pe("dest.write", we), we === false && E3();
      }
      function q2(N3) {
        if (Pe("onerror", N3), _e(), t.removeListener("error", q2), t.listenerCount("error") === 0) {
          let we = t._writableState || t._readableState;
          we && !we.errorEmitted ? sf(t, N3) : t.emit("error", N3);
        }
      }
      L5(t, "error", q2);
      function L3() {
        t.removeListener("finish", ge), _e();
      }
      t.once("close", L3);
      function ge() {
        Pe("onfinish"), t.removeListener("close", L3), _e();
      }
      t.once("finish", ge);
      function _e() {
        Pe("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), t.writableNeedDrain === true ? o.flowing && E3() : o.flowing || (Pe("pipe resume"), r.resume()), t;
    };
    function Y5(t, e) {
      return function() {
        let o = t._readableState;
        o.awaitDrainWriters === e ? (Pe("pipeOnDrain", 1), o.awaitDrainWriters = null) : o.multiAwaitDrain && (Pe("pipeOnDrain", o.awaitDrainWriters.size), o.awaitDrainWriters.delete(e)), (!o.awaitDrainWriters || o.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
      };
    }
    Le.prototype.unpipe = function(t) {
      let e = this._readableState, r = { hasUnpiped: false };
      if (e.pipes.length === 0)
        return this;
      if (!t) {
        let f2 = e.pipes;
        e.pipes = [], this.pause();
        for (let p2 = 0;p2 < f2.length; p2++)
          f2[p2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let o = x5(e.pipes, t);
      return o === -1 ? this : (e.pipes.splice(o, 1), e.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
    };
    Le.prototype.on = function(t, e) {
      let r = Hi.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Pe("on readable", o.length, o.reading), o.length ? Qo(this) : o.reading || Tr.nextTick(X5, this)), r;
    };
    Le.prototype.addListener = Le.prototype.on;
    Le.prototype.removeListener = function(t, e) {
      let r = Hi.prototype.removeListener.call(this, t, e);
      return t === "readable" && Tr.nextTick(av, this), r;
    };
    Le.prototype.off = Le.prototype.removeListener;
    Le.prototype.removeAllListeners = function(t) {
      let e = Hi.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && Tr.nextTick(av, this), e;
    };
    function av(t) {
      let e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && e[wn] === false ? e.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
    }
    function X5(t) {
      Pe("readable nexttick read 0"), t.read(0);
    }
    Le.prototype.resume = function() {
      let t = this._readableState;
      return t.flowing || (Pe("resume"), t.flowing = !t.readableListening, J5(this, t)), t[wn] = false, this;
    };
    function J5(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, Tr.nextTick(Q5, t, e));
    }
    function Q5(t, e) {
      Pe("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ov(t), e.flowing && !e.reading && t.read(0);
    }
    Le.prototype.pause = function() {
      return Pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[wn] = true, this;
    };
    function ov(t) {
      let e = t._readableState;
      for (Pe("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Le.prototype.wrap = function(t) {
      let e = false;
      t.on("data", (o) => {
        !this.push(o) && t.pause && (e = true, t.pause());
      }), t.on("end", () => {
        this.push(null);
      }), t.on("error", (o) => {
        sf(this, o);
      }), t.on("close", () => {
        this.destroy();
      }), t.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        e && t.resume && (e = false, t.resume());
      };
      let r = R5(t);
      for (let o = 1;o < r.length; o++) {
        let f2 = r[o];
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = t[f2].bind(t));
      }
      return this;
    };
    Le.prototype[I5] = function() {
      return sv(this);
    };
    Le.prototype.iterator = function(t) {
      return t !== undefined && K5(t, "options"), sv(this, t);
    };
    function sv(t, e) {
      typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
      let r = ex(t, e);
      return r.stream = t, r;
    }
    async function* ex(t, e) {
      let r = zh;
      function o(m2) {
        this === t ? (r(), r = zh) : r = m2;
      }
      t.on("readable", o);
      let f2, p2 = D5(t, { writable: false }, (m2) => {
        f2 = m2 ? Q1(f2, m2) : null, r(), r = zh;
      });
      try {
        for (;; ) {
          let m2 = t.destroyed ? null : t.read();
          if (m2 !== null)
            yield m2;
          else {
            if (f2)
              throw f2;
            if (f2 === null)
              return;
            await new B5(o);
          }
        }
      } catch (m2) {
        throw f2 = Q1(f2, m2), f2;
      } finally {
        (f2 || e?.destroyOnReturn !== false) && (f2 === undefined || t._readableState.autoDestroy) ? hf.destroyer(t, null) : (t.off("readable", o), p2());
      }
    }
    tv(Le.prototype, { readable: { __proto__: null, get() {
      let t = this._readableState;
      return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
    }, set(t) {
      this._readableState && (this._readableState.readable = !!t);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    tv(jh.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[wn] !== false;
    }, set(t) {
      this[wn] = !!t;
    } } });
    Le._fromList = hv;
    function hv(t, e) {
      if (e.length === 0)
        return null;
      let r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Wh(t) {
      let e = t._readableState;
      Pe("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, Tr.nextTick(tx, e, t));
    }
    function tx(t, e) {
      if (Pe("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
        if (t.endEmitted = true, e.emit("end"), e.writable && e.allowHalfOpen === false)
          Tr.nextTick(rx, e);
        else if (t.autoDestroy) {
          let r = e._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && e.destroy();
        }
      }
    }
    function rx(t) {
      t.writable && !t.writableEnded && !t.destroyed && t.end();
    }
    Le.from = function(t, e) {
      return j5(Le, t, e);
    };
    var Kh;
    function uv() {
      return Kh === undefined && (Kh = {}), Kh;
    }
    Le.fromWeb = function(t, e) {
      return uv().newStreamReadableFromReadableStream(t, e);
    };
    Le.toWeb = function(t, e) {
      return uv().newReadableStreamFromStreamReadable(t, e);
    };
    Le.wrap = function(t, e) {
      var r, o;
      return new Le({ objectMode: (r = (o = t.readableObjectMode) !== null && o !== undefined ? o : t.objectMode) !== null && r !== undefined ? r : true, ...e, destroy(f2, p2) {
        hf.destroyer(t, f2), p2(f2);
      } }).wrap(t);
    };
  });
  Jh = T2((jI, xv) => {
    var Mn = (Oi(), ur(pr)), { ArrayPrototypeSlice: pv, Error: ix, FunctionPrototypeSymbolHasInstance: vv, ObjectDefineProperty: bv, ObjectDefineProperties: nx, ObjectSetPrototypeOf: mv, StringPrototypeToLowerCase: fx, Symbol: ax, SymbolHasInstance: ox } = Tt();
    xv.exports = st;
    st.WritableState = ya;
    var { EventEmitter: sx } = ki(), ma = Vo().Stream, { Buffer: es } = Ut(), is = yn(), { addAbortSignal: hx } = Go(), { getHighWaterMark: ux, getDefaultHighWaterMark: lx } = Xo(), { ERR_INVALID_ARG_TYPE: dx, ERR_METHOD_NOT_IMPLEMENTED: cx, ERR_MULTIPLE_CALLBACK: gv, ERR_STREAM_CANNOT_PIPE: px, ERR_STREAM_DESTROYED: ga, ERR_STREAM_ALREADY_FINISHED: vx, ERR_STREAM_NULL_VALUES: bx, ERR_STREAM_WRITE_AFTER_END: mx, ERR_UNKNOWN_ENCODING: yv } = Jt().codes, { errorOrDestroy: uf } = is;
    mv(st.prototype, ma.prototype);
    mv(st, ma);
    function $h() {
    }
    var lf = ax("kOnFinished");
    function ya(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? ux(this, t, "writableHighWaterMark", r) : lx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let o = !!(t && t.decodeStrings === false);
      this.decodeStrings = !o, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yx.bind(undefined, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, rs(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[lf] = [];
    }
    function rs(t) {
      t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
    }
    ya.prototype.getBuffer = function() {
      return pv(this.buffered, this.bufferedIndex);
    };
    bv(ya.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function st(t) {
      let e = this instanceof Qr();
      if (!e && !vv(st, this))
        return new st(t);
      this._writableState = new ya(t, this, e), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && hx(t.signal, this)), ma.call(this, t), is.construct(this, () => {
        let r = this._writableState;
        r.writing || Yh(this, r), Xh(this, r);
      });
    }
    bv(st, ox, { __proto__: null, value: function(t) {
      return vv(this, t) ? true : this !== st ? false : t && t._writableState instanceof ya;
    } });
    st.prototype.pipe = function() {
      uf(this, new px);
    };
    function wv(t, e, r, o) {
      let f2 = t._writableState;
      if (typeof r == "function")
        o = r, r = f2.defaultEncoding;
      else {
        if (!r)
          r = f2.defaultEncoding;
        else if (r !== "buffer" && !es.isEncoding(r))
          throw new yv(r);
        typeof o != "function" && (o = $h);
      }
      if (e === null)
        throw new bx;
      if (!f2.objectMode)
        if (typeof e == "string")
          f2.decodeStrings !== false && (e = es.from(e, r), r = "buffer");
        else if (e instanceof es)
          r = "buffer";
        else if (ma._isUint8Array(e))
          e = ma._uint8ArrayToBuffer(e), r = "buffer";
        else
          throw new dx("chunk", ["string", "Buffer", "Uint8Array"], e);
      let p2;
      return f2.ending ? p2 = new mx : f2.destroyed && (p2 = new ga("write")), p2 ? (Mn.nextTick(o, p2), uf(t, p2, true), p2) : (f2.pendingcb++, gx(t, f2, e, r, o));
    }
    st.prototype.write = function(t, e, r) {
      return wv(this, t, e, r) === true;
    };
    st.prototype.cork = function() {
      this._writableState.corked++;
    };
    st.prototype.uncork = function() {
      let t = this._writableState;
      t.corked && (t.corked--, t.writing || Yh(this, t));
    };
    st.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = fx(e)), !es.isEncoding(e))
        throw new yv(e);
      return this._writableState.defaultEncoding = e, this;
    };
    function gx(t, e, r, o, f2) {
      let p2 = e.objectMode ? 1 : r.length;
      e.length += p2;
      let m2 = e.length < e.highWaterMark;
      return m2 || (e.needDrain = true), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({ chunk: r, encoding: o, callback: f2 }), e.allBuffers && o !== "buffer" && (e.allBuffers = false), e.allNoop && f2 !== $h && (e.allNoop = false)) : (e.writelen = p2, e.writecb = f2, e.writing = true, e.sync = true, t._write(r, o, e.onwrite), e.sync = false), m2 && !e.errored && !e.destroyed;
    }
    function dv(t, e, r, o, f2, p2, m2) {
      e.writelen = o, e.writecb = m2, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ga("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p2, e.onwrite), e.sync = false;
    }
    function cv(t, e, r, o) {
      --e.pendingcb, o(r), Gh(e), uf(t, r);
    }
    function yx(t, e) {
      let r = t._writableState, o = r.sync, f2 = r.writecb;
      if (typeof f2 != "function") {
        uf(t, new gv);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), o ? Mn.nextTick(cv, t, r, e, f2) : cv(t, r, e, f2)) : (r.buffered.length > r.bufferedIndex && Yh(t, r), o ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f2 ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f2, stream: t, state: r }, Mn.nextTick(wx, r.afterWriteTickInfo)) : Mv(t, r, 1, f2));
    }
    function wx({ stream: t, state: e, count: r, cb: o }) {
      return e.afterWriteTickInfo = null, Mv(t, e, r, o);
    }
    function Mv(t, e, r, o) {
      for (!e.ending && !t.destroyed && e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));r-- > 0; )
        e.pendingcb--, o();
      e.destroyed && Gh(e), Xh(t, e);
    }
    function Gh(t) {
      if (t.writing)
        return;
      for (let f2 = t.bufferedIndex;f2 < t.buffered.length; ++f2) {
        var e;
        let { chunk: p2, callback: m2 } = t.buffered[f2], y3 = t.objectMode ? 1 : p2.length;
        t.length -= y3, m2((e = t.errored) !== null && e !== undefined ? e : new ga("write"));
      }
      let r = t[lf].splice(0);
      for (let f2 = 0;f2 < r.length; f2++) {
        var o;
        r[f2]((o = t.errored) !== null && o !== undefined ? o : new ga("end"));
      }
      rs(t);
    }
    function Yh(t, e) {
      if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed)
        return;
      let { buffered: r, bufferedIndex: o, objectMode: f2 } = e, p2 = r.length - o;
      if (!p2)
        return;
      let m2 = o;
      if (e.bufferProcessing = true, p2 > 1 && t._writev) {
        e.pendingcb -= p2 - 1;
        let y3 = e.allNoop ? $h : (x3) => {
          for (let S2 = m2;S2 < r.length; ++S2)
            r[S2].callback(x3);
        }, M2 = e.allNoop && m2 === 0 ? r : pv(r, m2);
        M2.allBuffers = e.allBuffers, dv(t, e, true, e.length, M2, "", y3), rs(e);
      } else {
        do {
          let { chunk: y3, encoding: M2, callback: x3 } = r[m2];
          r[m2++] = null;
          let S2 = f2 ? 1 : y3.length;
          dv(t, e, false, S2, y3, M2, x3);
        } while (m2 < r.length && !e.writing);
        m2 === r.length ? rs(e) : m2 > 256 ? (r.splice(0, m2), e.bufferedIndex = 0) : e.bufferedIndex = m2;
      }
      e.bufferProcessing = false;
    }
    st.prototype._write = function(t, e, r) {
      if (this._writev)
        this._writev([{ chunk: t, encoding: e }], r);
      else
        throw new cx("_write()");
    };
    st.prototype._writev = null;
    st.prototype.end = function(t, e, r) {
      let o = this._writableState;
      typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null);
      let f2;
      if (t != null) {
        let p2 = wv(this, t, e);
        p2 instanceof ix && (f2 = p2);
      }
      return o.corked && (o.corked = 1, this.uncork()), f2 || (!o.errored && !o.ending ? (o.ending = true, Xh(this, o, true), o.ended = true) : o.finished ? f2 = new vx("end") : o.destroyed && (f2 = new ga("end"))), typeof r == "function" && (f2 || o.finished ? Mn.nextTick(r, f2) : o[lf].push(r)), this;
    };
    function ts(t) {
      return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
    }
    function Mx(t, e) {
      let r = false;
      function o(f2) {
        if (r) {
          uf(t, f2 ?? gv());
          return;
        }
        if (r = true, e.pendingcb--, f2) {
          let p2 = e[lf].splice(0);
          for (let m2 = 0;m2 < p2.length; m2++)
            p2[m2](f2);
          uf(t, f2, e.sync);
        } else
          ts(e) && (e.prefinished = true, t.emit("prefinish"), e.pendingcb++, Mn.nextTick(Vh, t, e));
      }
      e.sync = true, e.pendingcb++;
      try {
        t._final(o);
      } catch (f2) {
        o(f2);
      }
      e.sync = false;
    }
    function _x(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.finalCalled = true, Mx(t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Xh(t, e, r) {
      ts(e) && (_x(t, e), e.pendingcb === 0 && (r ? (e.pendingcb++, Mn.nextTick((o, f2) => {
        ts(f2) ? Vh(o, f2) : f2.pendingcb--;
      }, t, e)) : ts(e) && (e.pendingcb++, Vh(t, e))));
    }
    function Vh(t, e) {
      e.pendingcb--, e.finished = true;
      let r = e[lf].splice(0);
      for (let o = 0;o < r.length; o++)
        r[o]();
      if (t.emit("finish"), e.autoDestroy) {
        let o = t._readableState;
        (!o || o.autoDestroy && (o.endEmitted || o.readable === false)) && t.destroy();
      }
    }
    nx(st.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(t) {
      this._writableState && (this._writableState.destroyed = t);
    } }, writable: { __proto__: null, get() {
      let t = this._writableState;
      return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
    }, set(t) {
      this._writableState && (this._writableState.writable = !!t);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let t = this._writableState;
      return t ? !t.destroyed && !t.ending && t.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var xx = is.destroy;
    st.prototype.destroy = function(t, e) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[lf].length) && Mn.nextTick(Gh, r), xx.call(this, t, e), this;
    };
    st.prototype._undestroy = is.undestroy;
    st.prototype._destroy = function(t, e) {
      e(t);
    };
    st.prototype[sx.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    var Zh;
    function _v() {
      return Zh === undefined && (Zh = {}), Zh;
    }
    st.fromWeb = function(t, e) {
      return _v().newStreamWritableFromWritableStream(t, e);
    };
    st.toWeb = function(t) {
      return _v().newWritableStreamFromStreamWritable(t);
    };
  });
  Dv = T2((ZI, Nv) => {
    var Qh = (Oi(), ur(pr)), Sx = Ut(), { isReadable: Ex, isWritable: Ax, isIterable: Sv, isNodeStream: Rx, isReadableNodeStream: Ev, isWritableNodeStream: Av, isDuplexNodeStream: Bx } = Fi(), Rv = Ui(), { AbortError: Lv, codes: { ERR_INVALID_ARG_TYPE: qx, ERR_INVALID_RETURN_VALUE: Bv } } = Jt(), { destroyer: df } = yn(), Ix = Qr(), Tx = ba(), { createDeferredPromise: qv } = Gr(), Iv = Fh(), Tv = globalThis.Blob || Sx.Blob, kx = typeof Tv < "u" ? function(e) {
      return e instanceof Tv;
    } : function(e) {
      return false;
    }, Lx = globalThis.AbortController || No().AbortController, { FunctionPrototypeCall: kv } = Tt(), _n = class extends Ix {
      constructor(e) {
        super(e), e?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Nv.exports = function t(e, r) {
      if (Bx(e))
        return e;
      if (Ev(e))
        return ns({ readable: e });
      if (Av(e))
        return ns({ writable: e });
      if (Rx(e))
        return ns({ writable: false, readable: false });
      if (typeof e == "function") {
        let { value: f2, write: p2, final: m2, destroy: y3 } = Nx(e);
        if (Sv(f2))
          return Iv(_n, f2, { objectMode: true, write: p2, final: m2, destroy: y3 });
        let M2 = f2?.then;
        if (typeof M2 == "function") {
          let x3, S2 = kv(M2, f2, (E3) => {
            if (E3 != null)
              throw new Bv("nully", "body", E3);
          }, (E3) => {
            df(x3, E3);
          });
          return x3 = new _n({ objectMode: true, readable: false, write: p2, final(E3) {
            m2(async () => {
              try {
                await S2, Qh.nextTick(E3, null);
              } catch (B3) {
                Qh.nextTick(E3, B3);
              }
            });
          }, destroy: y3 });
        }
        throw new Bv("Iterable, AsyncIterable or AsyncFunction", r, f2);
      }
      if (kx(e))
        return t(e.arrayBuffer());
      if (Sv(e))
        return Iv(_n, e, { objectMode: true, writable: false });
      if (typeof e?.writable == "object" || typeof e?.readable == "object") {
        let f2 = e != null && e.readable ? Ev(e?.readable) ? e?.readable : t(e.readable) : undefined, p2 = e != null && e.writable ? Av(e?.writable) ? e?.writable : t(e.writable) : undefined;
        return ns({ readable: f2, writable: p2 });
      }
      let o = e?.then;
      if (typeof o == "function") {
        let f2;
        return kv(o, e, (p2) => {
          p2 != null && f2.push(p2), f2.push(null);
        }, (p2) => {
          df(f2, p2);
        }), f2 = new _n({ objectMode: true, writable: false, read() {
        } });
      }
      throw new qx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e);
    };
    function Nx(t) {
      let { promise: e, resolve: r } = qv(), o = new Lx, f2 = o.signal;
      return { value: t(async function* () {
        for (;; ) {
          let m2 = e;
          e = null;
          let { chunk: y3, done: M2, cb: x3 } = await m2;
          if (Qh.nextTick(x3), M2)
            return;
          if (f2.aborted)
            throw new Lv(undefined, { cause: f2.reason });
          ({ promise: e, resolve: r } = qv()), yield y3;
        }
      }(), { signal: f2 }), write(m2, y3, M2) {
        let x3 = r;
        r = null, x3({ chunk: m2, done: false, cb: M2 });
      }, final(m2) {
        let y3 = r;
        r = null, y3({ done: true, cb: m2 });
      }, destroy(m2, y3) {
        o.abort(), y3(m2);
      } };
    }
    function ns(t) {
      let e = t.readable && typeof t.readable.read != "function" ? Tx.wrap(t.readable) : t.readable, r = t.writable, o = !!Ex(e), f2 = !!Ax(r), p2, m2, y3, M2, x3;
      function S2(E3) {
        let B3 = M2;
        M2 = null, B3 ? B3(E3) : E3 ? x3.destroy(E3) : !o && !f2 && x3.destroy();
      }
      return x3 = new _n({ readableObjectMode: !!(e != null && e.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o, writable: f2 }), f2 && (Rv(r, (E3) => {
        f2 = false, E3 && df(e, E3), S2(E3);
      }), x3._write = function(E3, B3, q2) {
        r.write(E3, B3) ? q2() : p2 = q2;
      }, x3._final = function(E3) {
        r.end(), m2 = E3;
      }, r.on("drain", function() {
        if (p2) {
          let E3 = p2;
          p2 = null, E3();
        }
      }), r.on("finish", function() {
        if (m2) {
          let E3 = m2;
          m2 = null, E3();
        }
      })), o && (Rv(e, (E3) => {
        o = false, E3 && df(e, E3), S2(E3);
      }), e.on("readable", function() {
        if (y3) {
          let E3 = y3;
          y3 = null, E3();
        }
      }), e.on("end", function() {
        x3.push(null);
      }), x3._read = function() {
        for (;; ) {
          let E3 = e.read();
          if (E3 === null) {
            y3 = x3._read;
            return;
          }
          if (!x3.push(E3))
            return;
        }
      }), x3._destroy = function(E3, B3) {
        !E3 && M2 !== null && (E3 = new Lv), y3 = null, p2 = null, m2 = null, M2 === null ? B3(E3) : (M2 = B3, df(r, E3), df(e, E3));
      }, x3;
    }
  });
  Qr = T2((VI, Ov) => {
    var { ObjectDefineProperties: Dx, ObjectGetOwnPropertyDescriptor: bi, ObjectKeys: Px, ObjectSetPrototypeOf: Pv } = Tt();
    Ov.exports = kr;
    var ru = ba(), vr = Jh();
    Pv(kr.prototype, ru.prototype);
    Pv(kr, ru);
    {
      let t = Px(vr.prototype);
      for (let e = 0;e < t.length; e++) {
        let r = t[e];
        kr.prototype[r] || (kr.prototype[r] = vr.prototype[r]);
      }
    }
    function kr(t) {
      if (!(this instanceof kr))
        return new kr(t);
      ru.call(this, t), vr.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    Dx(kr.prototype, { writable: { __proto__: null, ...bi(vr.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...bi(vr.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...bi(vr.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...bi(vr.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...bi(vr.prototype, "writableLength") }, writableFinished: { __proto__: null, ...bi(vr.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...bi(vr.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...bi(vr.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...bi(vr.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(t) {
      this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } } });
    var eu;
    function Cv() {
      return eu === undefined && (eu = {}), eu;
    }
    kr.fromWeb = function(t, e) {
      return Cv().newStreamDuplexFromReadableWritablePair(t, e);
    };
    kr.toWeb = function(t) {
      return Cv().newReadableWritablePairFromDuplex(t);
    };
    var tu;
    kr.from = function(t) {
      return tu || (tu = Dv()), tu(t, "body");
    };
  });
  fu = T2(($I, Uv) => {
    var { ObjectSetPrototypeOf: Fv, Symbol: Cx } = Tt();
    Uv.exports = mi;
    var { ERR_METHOD_NOT_IMPLEMENTED: Ox } = Jt().codes, nu = Qr(), { getHighWaterMark: Fx } = Xo();
    Fv(mi.prototype, nu.prototype);
    Fv(mi, nu);
    var wa = Cx("kCallback");
    function mi(t) {
      if (!(this instanceof mi))
        return new mi(t);
      let e = t ? Fx(this, t, "readableHighWaterMark", true) : null;
      e === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e, writableHighWaterMark: t.writableHighWaterMark || 0 }), nu.call(this, t), this._readableState.sync = false, this[wa] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Ux);
    }
    function iu(t) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((e, r) => {
        if (e) {
          t ? t(e) : this.destroy(e);
          return;
        }
        r != null && this.push(r), this.push(null), t && t();
      }) : (this.push(null), t && t());
    }
    function Ux() {
      this._final !== iu && iu.call(this);
    }
    mi.prototype._final = iu;
    mi.prototype._transform = function(t, e, r) {
      throw new Ox("_transform()");
    };
    mi.prototype._write = function(t, e, r) {
      let o = this._readableState, f2 = this._writableState, p2 = o.length;
      this._transform(t, e, (m2, y3) => {
        if (m2) {
          r(m2);
          return;
        }
        y3 != null && this.push(y3), f2.ended || p2 === o.length || o.length < o.highWaterMark ? r() : this[wa] = r;
      });
    };
    mi.prototype._read = function() {
      if (this[wa]) {
        let t = this[wa];
        this[wa] = null, t();
      }
    };
  });
  ou = T2((GI, Hv) => {
    var { ObjectSetPrototypeOf: zv } = Tt();
    Hv.exports = cf;
    var au = fu();
    zv(cf.prototype, au.prototype);
    zv(cf, au);
    function cf(t) {
      if (!(this instanceof cf))
        return new cf(t);
      au.call(this, t);
    }
    cf.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  os = T2((YI, Gv) => {
    var fs = (Oi(), ur(pr)), { ArrayIsArray: zx, Promise: Hx, SymbolAsyncIterator: Wx } = Tt(), as = Ui(), { once: Kx } = Gr(), jx = yn(), Wv = Qr(), { aggregateTwoErrors: Zx, codes: { ERR_INVALID_ARG_TYPE: Vv, ERR_INVALID_RETURN_VALUE: su, ERR_MISSING_ARGS: Vx, ERR_STREAM_DESTROYED: $x, ERR_STREAM_PREMATURE_CLOSE: Gx }, AbortError: Yx } = Jt(), { validateFunction: Xx, validateAbortSignal: Jx } = pa(), { isIterable: pf, isReadable: hu, isReadableNodeStream: du, isNodeStream: Kv } = Fi(), Qx = globalThis.AbortController || No().AbortController, uu, lu;
    function jv(t, e, r) {
      let o = false;
      t.on("close", () => {
        o = true;
      });
      let f2 = as(t, { readable: e, writable: r }, (p2) => {
        o = !p2;
      });
      return { destroy: (p2) => {
        o || (o = true, jx.destroyer(t, p2 || new $x("pipe")));
      }, cleanup: f2 };
    }
    function e7(t) {
      return Xx(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
    }
    function t7(t) {
      if (pf(t))
        return t;
      if (du(t))
        return r7(t);
      throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], t);
    }
    async function* r7(t) {
      lu || (lu = ba()), yield* lu.prototype[Wx].call(t);
    }
    async function Zv(t, e, r, { end: o }) {
      let f2, p2 = null, m2 = (x3) => {
        if (x3 && (f2 = x3), p2) {
          let S2 = p2;
          p2 = null, S2();
        }
      }, y3 = () => new Hx((x3, S2) => {
        f2 ? S2(f2) : p2 = () => {
          f2 ? S2(f2) : x3();
        };
      });
      e.on("drain", m2);
      let M2 = as(e, { readable: false }, m2);
      try {
        e.writableNeedDrain && await y3();
        for await (let x3 of t)
          e.write(x3) || await y3();
        o && e.end(), await y3(), r();
      } catch (x3) {
        r(f2 !== x3 ? Zx(f2, x3) : x3);
      } finally {
        M2(), e.off("drain", m2);
      }
    }
    function i7(...t) {
      return $v(t, Kx(e7(t)));
    }
    function $v(t, e, r) {
      if (t.length === 1 && zx(t[0]) && (t = t[0]), t.length < 2)
        throw new Vx("streams");
      let o = new Qx, f2 = o.signal, p2 = r?.signal, m2 = [];
      Jx(p2, "options.signal");
      function y3() {
        q2(new Yx);
      }
      p2?.addEventListener("abort", y3);
      let M2, x3, S2 = [], E3 = 0;
      function B3(N3) {
        q2(N3, --E3 === 0);
      }
      function q2(N3, we) {
        if (N3 && (!M2 || M2.code === "ERR_STREAM_PREMATURE_CLOSE") && (M2 = N3), !(!M2 && !we)) {
          for (;S2.length; )
            S2.shift()(M2);
          p2?.removeEventListener("abort", y3), o.abort(), we && (M2 || m2.forEach((ye) => ye()), fs.nextTick(e, M2, x3));
        }
      }
      let L3;
      for (let N3 = 0;N3 < t.length; N3++) {
        let we = t[N3], ye = N3 < t.length - 1, xe = N3 > 0, Re = ye || r?.end !== false, Ee = N3 === t.length - 1;
        if (Kv(we)) {
          let Ae = function(P2) {
            P2 && P2.name !== "AbortError" && P2.code !== "ERR_STREAM_PREMATURE_CLOSE" && B3(P2);
          };
          var _e = Ae;
          if (Re) {
            let { destroy: P2, cleanup: Se } = jv(we, ye, xe);
            S2.push(P2), hu(we) && Ee && m2.push(Se);
          }
          we.on("error", Ae), hu(we) && Ee && m2.push(() => {
            we.removeListener("error", Ae);
          });
        }
        if (N3 === 0)
          if (typeof we == "function") {
            if (L3 = we({ signal: f2 }), !pf(L3))
              throw new su("Iterable, AsyncIterable or Stream", "source", L3);
          } else
            pf(we) || du(we) ? L3 = we : L3 = Wv.from(we);
        else if (typeof we == "function")
          if (L3 = t7(L3), L3 = we(L3, { signal: f2 }), ye) {
            if (!pf(L3, true))
              throw new su("AsyncIterable", `transform[${N3 - 1}]`, L3);
          } else {
            var ge;
            uu || (uu = ou());
            let Ae = new uu({ objectMode: true }), P2 = (ge = L3) === null || ge === undefined ? undefined : ge.then;
            if (typeof P2 == "function")
              E3++, P2.call(L3, (i) => {
                x3 = i, i != null && Ae.write(i), Re && Ae.end(), fs.nextTick(B3);
              }, (i) => {
                Ae.destroy(i), fs.nextTick(B3, i);
              });
            else if (pf(L3, true))
              E3++, Zv(L3, Ae, B3, { end: Re });
            else
              throw new su("AsyncIterable or Promise", "destination", L3);
            L3 = Ae;
            let { destroy: Se, cleanup: v } = jv(L3, false, true);
            S2.push(Se), Ee && m2.push(v);
          }
        else if (Kv(we)) {
          if (du(L3)) {
            E3 += 2;
            let Ae = n7(L3, we, B3, { end: Re });
            hu(we) && Ee && m2.push(Ae);
          } else if (pf(L3))
            E3++, Zv(L3, we, B3, { end: Re });
          else
            throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], L3);
          L3 = we;
        } else
          L3 = Wv.from(we);
      }
      return (f2 != null && f2.aborted || p2 != null && p2.aborted) && fs.nextTick(y3), L3;
    }
    function n7(t, e, r, { end: o }) {
      let f2 = false;
      return e.on("close", () => {
        f2 || r(new Gx);
      }), t.pipe(e, { end: o }), o ? t.once("end", () => {
        f2 = true, e.end();
      }) : r(), as(t, { readable: true, writable: false }, (p2) => {
        let m2 = t._readableState;
        p2 && p2.code === "ERR_STREAM_PREMATURE_CLOSE" && m2 && m2.ended && !m2.errored && !m2.errorEmitted ? t.once("end", r).once("error", r) : r(p2);
      }), as(e, { readable: false, writable: true }, r);
    }
    Gv.exports = { pipelineImpl: $v, pipeline: i7 };
  });
  eb = T2((XI, Qv) => {
    var { pipeline: f7 } = os(), ss = Qr(), { destroyer: a7 } = yn(), { isNodeStream: o7, isReadable: Yv, isWritable: Xv } = Fi(), { AbortError: s7, codes: { ERR_INVALID_ARG_VALUE: Jv, ERR_MISSING_ARGS: h7 } } = Jt();
    Qv.exports = function(...e) {
      if (e.length === 0)
        throw new h7("streams");
      if (e.length === 1)
        return ss.from(e[0]);
      let r = [...e];
      if (typeof e[0] == "function" && (e[0] = ss.from(e[0])), typeof e[e.length - 1] == "function") {
        let q2 = e.length - 1;
        e[q2] = ss.from(e[q2]);
      }
      for (let q2 = 0;q2 < e.length; ++q2)
        if (!!o7(e[q2])) {
          if (q2 < e.length - 1 && !Yv(e[q2]))
            throw new Jv(`streams[${q2}]`, r[q2], "must be readable");
          if (q2 > 0 && !Xv(e[q2]))
            throw new Jv(`streams[${q2}]`, r[q2], "must be writable");
        }
      let o, f2, p2, m2, y3;
      function M2(q2) {
        let L3 = m2;
        m2 = null, L3 ? L3(q2) : q2 ? y3.destroy(q2) : !B3 && !E3 && y3.destroy();
      }
      let x3 = e[0], S2 = f7(e, M2), E3 = !!Xv(x3), B3 = !!Yv(S2);
      return y3 = new ss({ writableObjectMode: !!(x3 != null && x3.writableObjectMode), readableObjectMode: !!(S2 != null && S2.writableObjectMode), writable: E3, readable: B3 }), E3 && (y3._write = function(q2, L3, ge) {
        x3.write(q2, L3) ? ge() : o = ge;
      }, y3._final = function(q2) {
        x3.end(), f2 = q2;
      }, x3.on("drain", function() {
        if (o) {
          let q2 = o;
          o = null, q2();
        }
      }), S2.on("finish", function() {
        if (f2) {
          let q2 = f2;
          f2 = null, q2();
        }
      })), B3 && (S2.on("readable", function() {
        if (p2) {
          let q2 = p2;
          p2 = null, q2();
        }
      }), S2.on("end", function() {
        y3.push(null);
      }), y3._read = function() {
        for (;; ) {
          let q2 = S2.read();
          if (q2 === null) {
            p2 = y3._read;
            return;
          }
          if (!y3.push(q2))
            return;
        }
      }), y3._destroy = function(q2, L3) {
        !q2 && m2 !== null && (q2 = new s7), p2 = null, o = null, f2 = null, m2 === null ? L3(q2) : (m2 = L3, a7(S2, q2));
      }, y3;
    };
  });
  cu = T2((JI, tb) => {
    var { ArrayPrototypePop: u7, Promise: l7 } = Tt(), { isIterable: d7, isNodeStream: c7 } = Fi(), { pipelineImpl: p7 } = os(), { finished: v7 } = Ui();
    function b7(...t) {
      return new l7((e, r) => {
        let o, f2, p2 = t[t.length - 1];
        if (p2 && typeof p2 == "object" && !c7(p2) && !d7(p2)) {
          let m2 = u7(t);
          o = m2.signal, f2 = m2.end;
        }
        p7(t, (m2, y3) => {
          m2 ? r(m2) : e(y3);
        }, { signal: o, end: f2 });
      });
    }
    tb.exports = { finished: v7, pipeline: b7 };
  });
  lb = T2((QI, ub) => {
    var { Buffer: m7 } = Ut(), { ObjectDefineProperty: gi, ObjectKeys: nb, ReflectApply: fb } = Tt(), { promisify: { custom: ab } } = Gr(), { streamReturningOperators: rb, promiseReturningOperators: ib } = k1(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ob } } = Jt(), g7 = eb(), { pipeline: sb } = os(), { destroyer: y7 } = yn(), hb = Ui(), pu = cu(), vu = Fi(), ct = ub.exports = Vo().Stream;
    ct.isDisturbed = vu.isDisturbed;
    ct.isErrored = vu.isErrored;
    ct.isReadable = vu.isReadable;
    ct.Readable = ba();
    for (let t of nb(rb)) {
      let r = function(...o) {
        if (new.target)
          throw ob();
        return ct.Readable.from(fb(e, this, o));
      };
      M7 = r;
      let e = rb[t];
      gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    for (let t of nb(ib)) {
      let r = function(...f2) {
        if (new.target)
          throw ob();
        return fb(e, this, f2);
      };
      M7 = r;
      let e = ib[t];
      gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    ct.Writable = Jh();
    ct.Duplex = Qr();
    ct.Transform = fu();
    ct.PassThrough = ou();
    ct.pipeline = sb;
    var { addAbortSignal: w7 } = Go();
    ct.addAbortSignal = w7;
    ct.finished = hb;
    ct.destroy = y7;
    ct.compose = g7;
    gi(ct, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return pu;
    } });
    gi(sb, ab, { __proto__: null, enumerable: true, get() {
      return pu.pipeline;
    } });
    gi(hb, ab, { __proto__: null, enumerable: true, get() {
      return pu.finished;
    } });
    ct.Stream = ct;
    ct._isUint8Array = function(e) {
      return e instanceof Uint8Array;
    };
    ct._uint8ArrayToBuffer = function(e) {
      return m7.from(e.buffer, e.byteOffset, e.byteLength);
    };
  });
  bu = T2((eT, pt) => {
    var Lt = lb(), _7 = cu(), x7 = Lt.Readable.destroy;
    pt.exports = Lt.Readable;
    pt.exports._uint8ArrayToBuffer = Lt._uint8ArrayToBuffer;
    pt.exports._isUint8Array = Lt._isUint8Array;
    pt.exports.isDisturbed = Lt.isDisturbed;
    pt.exports.isErrored = Lt.isErrored;
    pt.exports.isReadable = Lt.isReadable;
    pt.exports.Readable = Lt.Readable;
    pt.exports.Writable = Lt.Writable;
    pt.exports.Duplex = Lt.Duplex;
    pt.exports.Transform = Lt.Transform;
    pt.exports.PassThrough = Lt.PassThrough;
    pt.exports.addAbortSignal = Lt.addAbortSignal;
    pt.exports.finished = Lt.finished;
    pt.exports.destroy = Lt.destroy;
    pt.exports.destroy = x7;
    pt.exports.pipeline = Lt.pipeline;
    pt.exports.compose = Lt.compose;
    Object.defineProperty(Lt, "promises", { configurable: true, enumerable: true, get() {
      return _7;
    } });
    pt.exports.Stream = Lt.Stream;
    pt.exports.default = pt.exports;
  });
  vf = {};
  Ja(vf, { default: () => S7 });
  db = R0(() => {
    ot(vf, rn(bu()));
    S7 = rn(bu());
  });
  yi = T2((rT, vb) => {
    var cb = Te().Buffer, pb = (db(), ur(vf)).Transform, E7 = co().StringDecoder, A7 = Ie();
    function Lr(t) {
      pb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A7(Lr, pb);
    Lr.prototype.update = function(t, e, r) {
      typeof t == "string" && (t = cb.from(t, e));
      var o = this._update(t);
      return this.hashMode ? this : (r && (o = this._toString(o, r)), o);
    };
    Lr.prototype.setAutoPadding = function() {
    };
    Lr.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    Lr.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    Lr.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    Lr.prototype._transform = function(t, e, r) {
      var o;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t));
      } catch (f2) {
        o = f2;
      } finally {
        r(o);
      }
    };
    Lr.prototype._flush = function(t) {
      var e;
      try {
        this.push(this.__final());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Lr.prototype._finalOrDigest = function(t) {
      var e = this.__final() || cb.alloc(0);
      return t && (e = this._toString(e, t, true)), e;
    };
    Lr.prototype._toString = function(t, e, r) {
      if (this._decoder || (this._decoder = new E7(e), this._encoding = e), this._encoding !== e)
        throw new Error("can't switch encodings");
      var o = this._decoder.write(t);
      return r && (o += this._decoder.end()), o;
    };
    vb.exports = Lr;
  });
  bf = T2((iT, mb) => {
    var R7 = Ie(), B7 = Ao(), q7 = Bo(), I7 = ko(), bb = yi();
    function hs(t) {
      bb.call(this, "digest"), this._hash = t;
    }
    R7(hs, bb);
    hs.prototype._update = function(t) {
      this._hash.update(t);
    };
    hs.prototype._final = function() {
      return this._hash.digest();
    };
    mb.exports = function(e) {
      return e = e.toLowerCase(), e === "md5" ? new B7 : e === "rmd160" || e === "ripemd160" ? new q7 : new hs(I7(e));
    };
  });
  wb = T2((nT, yb) => {
    var T7 = Ie(), xn = Te().Buffer, gb = yi(), k7 = xn.alloc(128), mf = 64;
    function us(t, e) {
      gb.call(this, "digest"), typeof e == "string" && (e = xn.from(e)), this._alg = t, this._key = e, e.length > mf ? e = t(e) : e.length < mf && (e = xn.concat([e, k7], mf));
      for (var r = this._ipad = xn.allocUnsafe(mf), o = this._opad = xn.allocUnsafe(mf), f2 = 0;f2 < mf; f2++)
        r[f2] = e[f2] ^ 54, o[f2] = e[f2] ^ 92;
      this._hash = [r];
    }
    T7(us, gb);
    us.prototype._update = function(t) {
      this._hash.push(t);
    };
    us.prototype._final = function() {
      var t = this._alg(xn.concat(this._hash));
      return this._alg(xn.concat([this._opad, t]));
    };
    yb.exports = us;
  });
  mu = T2((fT, Mb) => {
    var L7 = Ao();
    Mb.exports = function(t) {
      return new L7().update(t).digest();
    };
  });
  wu = T2((aT, xb) => {
    var N7 = Ie(), D7 = wb(), _b = yi(), Ma = Te().Buffer, P7 = mu(), gu = Bo(), yu = ko(), C7 = Ma.alloc(128);
    function _a(t, e) {
      _b.call(this, "digest"), typeof e == "string" && (e = Ma.from(e));
      var r = t === "sha512" || t === "sha384" ? 128 : 64;
      if (this._alg = t, this._key = e, e.length > r) {
        var o = t === "rmd160" ? new gu : yu(t);
        e = o.update(e).digest();
      } else
        e.length < r && (e = Ma.concat([e, C7], r));
      for (var f2 = this._ipad = Ma.allocUnsafe(r), p2 = this._opad = Ma.allocUnsafe(r), m2 = 0;m2 < r; m2++)
        f2[m2] = e[m2] ^ 54, p2[m2] = e[m2] ^ 92;
      this._hash = t === "rmd160" ? new gu : yu(t), this._hash.update(f2);
    }
    N7(_a, _b);
    _a.prototype._update = function(t) {
      this._hash.update(t);
    };
    _a.prototype._final = function() {
      var t = this._hash.digest(), e = this._alg === "rmd160" ? new gu : yu(this._alg);
      return e.update(this._opad).update(t).digest();
    };
    xb.exports = function(e, r) {
      return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new _a("rmd160", r) : e === "md5" ? new D7(P7, r) : new _a(e, r);
    };
  });
  Mu = T2((oT, O7) => {
    O7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  Eb = T2((sT, Sb) => {
    Sb.exports = Mu();
  });
  _u = T2((hT, Ab) => {
    var F7 = Math.pow(2, 30) - 1;
    Ab.exports = function(t, e) {
      if (typeof t != "number")
        throw new TypeError("Iterations not a number");
      if (t < 0)
        throw new TypeError("Bad iterations");
      if (typeof e != "number")
        throw new TypeError("Key length not a number");
      if (e < 0 || e > F7 || e !== e)
        throw new TypeError("Bad key length");
    };
  });
  xu = T2((uT, Bb) => {
    var ls;
    global.process && global.process.browser ? ls = "utf-8" : global.process && global.process.version ? (Rb = parseInt(process.version.split(".")[0].slice(1), 10), ls = Rb >= 6 ? "utf-8" : "binary") : ls = "utf-8";
    var Rb;
    Bb.exports = ls;
  });
  Eu = T2((lT, qb) => {
    var Su = Te().Buffer;
    qb.exports = function(t, e, r) {
      if (Su.isBuffer(t))
        return t;
      if (typeof t == "string")
        return Su.from(t, e);
      if (ArrayBuffer.isView(t))
        return Su.from(t.buffer);
      throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  Au = T2((dT, Lb) => {
    var U7 = mu(), z7 = Bo(), H7 = ko(), Sn = Te().Buffer, W7 = _u(), Ib = xu(), Tb = Eu(), K7 = Sn.alloc(128), ds = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
    function kb(t, e, r) {
      var o = j7(t), f2 = t === "sha512" || t === "sha384" ? 128 : 64;
      e.length > f2 ? e = o(e) : e.length < f2 && (e = Sn.concat([e, K7], f2));
      for (var p2 = Sn.allocUnsafe(f2 + ds[t]), m2 = Sn.allocUnsafe(f2 + ds[t]), y3 = 0;y3 < f2; y3++)
        p2[y3] = e[y3] ^ 54, m2[y3] = e[y3] ^ 92;
      var M2 = Sn.allocUnsafe(f2 + r + 4);
      p2.copy(M2, 0, 0, f2), this.ipad1 = M2, this.ipad2 = p2, this.opad = m2, this.alg = t, this.blocksize = f2, this.hash = o, this.size = ds[t];
    }
    kb.prototype.run = function(t, e) {
      t.copy(e, this.blocksize);
      var r = this.hash(e);
      return r.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function j7(t) {
      function e(o) {
        return H7(t).update(o).digest();
      }
      function r(o) {
        return new z7().update(o).digest();
      }
      return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? U7 : e;
    }
    function Z7(t, e, r, o, f2) {
      W7(r, o), t = Tb(t, Ib, "Password"), e = Tb(e, Ib, "Salt"), f2 = f2 || "sha1";
      var p2 = new kb(f2, t, e.length), m2 = Sn.allocUnsafe(o), y3 = Sn.allocUnsafe(e.length + 4);
      e.copy(y3, 0, 0, e.length);
      for (var M2 = 0, x3 = ds[f2], S2 = Math.ceil(o / x3), E3 = 1;E3 <= S2; E3++) {
        y3.writeUInt32BE(E3, e.length);
        for (var B3 = p2.run(y3, p2.ipad1), q2 = B3, L3 = 1;L3 < r; L3++) {
          q2 = p2.run(q2, p2.ipad2);
          for (var ge = 0;ge < x3; ge++)
            B3[ge] ^= q2[ge];
        }
        B3.copy(m2, M2), M2 += x3;
      }
      return m2;
    }
    Lb.exports = Z7;
  });
  Ub = T2((cT, Fb) => {
    var Cb = Te().Buffer, V7 = _u(), Nb = xu(), Db = Au(), Pb = Eu(), cs, xa = global.crypto && global.crypto.subtle, $7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ru = [];
    function G7(t) {
      if (global.process && !global.process.browser || !xa || !xa.importKey || !xa.deriveBits)
        return Promise.resolve(false);
      if (Ru[t] !== undefined)
        return Ru[t];
      cs = cs || Cb.alloc(8);
      var e = Ob(cs, cs, 10, 128, t).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return Ru[t] = e, e;
    }
    var En;
    function Bu() {
      return En || (global.process && global.process.nextTick ? En = global.process.nextTick : global.queueMicrotask ? En = global.queueMicrotask : global.setImmediate ? En = global.setImmediate : En = global.setTimeout, En);
    }
    function Ob(t, e, r, o, f2) {
      return xa.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p2) {
        return xa.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: f2 } }, p2, o << 3);
      }).then(function(p2) {
        return Cb.from(p2);
      });
    }
    function Y7(t, e) {
      t.then(function(r) {
        Bu()(function() {
          e(null, r);
        });
      }, function(r) {
        Bu()(function() {
          e(r);
        });
      });
    }
    Fb.exports = function(t, e, r, o, f2, p2) {
      typeof f2 == "function" && (p2 = f2, f2 = undefined), f2 = f2 || "sha1";
      var m2 = $7[f2.toLowerCase()];
      if (!m2 || typeof global.Promise != "function") {
        Bu()(function() {
          var y3;
          try {
            y3 = Db(t, e, r, o, f2);
          } catch (M2) {
            return p2(M2);
          }
          p2(null, y3);
        });
        return;
      }
      if (V7(r, o), t = Pb(t, Nb, "Password"), e = Pb(e, Nb, "Salt"), typeof p2 != "function")
        throw new Error("No callback provided to pbkdf2");
      Y7(G7(m2).then(function(y3) {
        return y3 ? Ob(t, e, r, o, m2) : Db(t, e, r, o, f2);
      }), p2);
    };
  });
  Iu = T2((qu) => {
    qu.pbkdf2 = Ub();
    qu.pbkdf2Sync = Au();
  });
  Tu = T2((br) => {
    br.readUInt32BE = function(e, r) {
      var o = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
      return o >>> 0;
    };
    br.writeUInt32BE = function(e, r, o) {
      e[0 + o] = r >>> 24, e[1 + o] = r >>> 16 & 255, e[2 + o] = r >>> 8 & 255, e[3 + o] = r & 255;
    };
    br.ip = function(e, r, o, f2) {
      for (var p2 = 0, m2 = 0, y3 = 6;y3 >= 0; y3 -= 2) {
        for (var M2 = 0;M2 <= 24; M2 += 8)
          p2 <<= 1, p2 |= r >>> M2 + y3 & 1;
        for (var M2 = 0;M2 <= 24; M2 += 8)
          p2 <<= 1, p2 |= e >>> M2 + y3 & 1;
      }
      for (var y3 = 6;y3 >= 0; y3 -= 2) {
        for (var M2 = 1;M2 <= 25; M2 += 8)
          m2 <<= 1, m2 |= r >>> M2 + y3 & 1;
        for (var M2 = 1;M2 <= 25; M2 += 8)
          m2 <<= 1, m2 |= e >>> M2 + y3 & 1;
      }
      o[f2 + 0] = p2 >>> 0, o[f2 + 1] = m2 >>> 0;
    };
    br.rip = function(e, r, o, f2) {
      for (var p2 = 0, m2 = 0, y3 = 0;y3 < 4; y3++)
        for (var M2 = 24;M2 >= 0; M2 -= 8)
          p2 <<= 1, p2 |= r >>> M2 + y3 & 1, p2 <<= 1, p2 |= e >>> M2 + y3 & 1;
      for (var y3 = 4;y3 < 8; y3++)
        for (var M2 = 24;M2 >= 0; M2 -= 8)
          m2 <<= 1, m2 |= r >>> M2 + y3 & 1, m2 <<= 1, m2 |= e >>> M2 + y3 & 1;
      o[f2 + 0] = p2 >>> 0, o[f2 + 1] = m2 >>> 0;
    };
    br.pc1 = function(e, r, o, f2) {
      for (var p2 = 0, m2 = 0, y3 = 7;y3 >= 5; y3--) {
        for (var M2 = 0;M2 <= 24; M2 += 8)
          p2 <<= 1, p2 |= r >> M2 + y3 & 1;
        for (var M2 = 0;M2 <= 24; M2 += 8)
          p2 <<= 1, p2 |= e >> M2 + y3 & 1;
      }
      for (var M2 = 0;M2 <= 24; M2 += 8)
        p2 <<= 1, p2 |= r >> M2 + y3 & 1;
      for (var y3 = 1;y3 <= 3; y3++) {
        for (var M2 = 0;M2 <= 24; M2 += 8)
          m2 <<= 1, m2 |= r >> M2 + y3 & 1;
        for (var M2 = 0;M2 <= 24; M2 += 8)
          m2 <<= 1, m2 |= e >> M2 + y3 & 1;
      }
      for (var M2 = 0;M2 <= 24; M2 += 8)
        m2 <<= 1, m2 |= e >> M2 + y3 & 1;
      o[f2 + 0] = p2 >>> 0, o[f2 + 1] = m2 >>> 0;
    };
    br.r28shl = function(e, r) {
      return e << r & 268435455 | e >>> 28 - r;
    };
    var ps = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    br.pc2 = function(e, r, o, f2) {
      for (var p2 = 0, m2 = 0, y3 = ps.length >>> 1, M2 = 0;M2 < y3; M2++)
        p2 <<= 1, p2 |= e >>> ps[M2] & 1;
      for (var M2 = y3;M2 < ps.length; M2++)
        m2 <<= 1, m2 |= r >>> ps[M2] & 1;
      o[f2 + 0] = p2 >>> 0, o[f2 + 1] = m2 >>> 0;
    };
    br.expand = function(e, r, o) {
      var f2 = 0, p2 = 0;
      f2 = (e & 1) << 5 | e >>> 27;
      for (var m2 = 23;m2 >= 15; m2 -= 4)
        f2 <<= 6, f2 |= e >>> m2 & 63;
      for (var m2 = 11;m2 >= 3; m2 -= 4)
        p2 |= e >>> m2 & 63, p2 <<= 6;
      p2 |= (e & 31) << 1 | e >>> 31, r[o + 0] = f2 >>> 0, r[o + 1] = p2 >>> 0;
    };
    var zb = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    br.substitute = function(e, r) {
      for (var o = 0, f2 = 0;f2 < 4; f2++) {
        var p2 = e >>> 18 - f2 * 6 & 63, m2 = zb[f2 * 64 + p2];
        o <<= 4, o |= m2;
      }
      for (var f2 = 0;f2 < 4; f2++) {
        var p2 = r >>> 18 - f2 * 6 & 63, m2 = zb[4 * 64 + f2 * 64 + p2];
        o <<= 4, o |= m2;
      }
      return o >>> 0;
    };
    var Hb = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    br.permute = function(e) {
      for (var r = 0, o = 0;o < Hb.length; o++)
        r <<= 1, r |= e >>> Hb[o] & 1;
      return r >>> 0;
    };
    br.padSplit = function(e, r, o) {
      for (var f2 = e.toString(2);f2.length < r; )
        f2 = "0" + f2;
      for (var p2 = [], m2 = 0;m2 < r; m2 += o)
        p2.push(f2.slice(m2, m2 + o));
      return p2.join(" ");
    };
  });
  ar = T2((bT, Kb) => {
    Kb.exports = Wb;
    function Wb(t, e) {
      if (!t)
        throw new Error(e || "Assertion failed");
    }
    Wb.equal = function(e, r, o) {
      if (e != r)
        throw new Error(o || "Assertion failed: " + e + " != " + r);
    };
  });
  vs = T2((mT, jb) => {
    var X7 = ar();
    function mr(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    jb.exports = mr;
    mr.prototype._init = function() {
    };
    mr.prototype.update = function(e) {
      return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
    };
    mr.prototype._buffer = function(e, r) {
      for (var o = Math.min(this.buffer.length - this.bufferOff, e.length - r), f2 = 0;f2 < o; f2++)
        this.buffer[this.bufferOff + f2] = e[r + f2];
      return this.bufferOff += o, o;
    };
    mr.prototype._flushBuffer = function(e, r) {
      return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
    };
    mr.prototype._updateEncrypt = function(e) {
      var r = 0, o = 0, f2 = (this.bufferOff + e.length) / this.blockSize | 0, p2 = new Array(f2 * this.blockSize);
      this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (o += this._flushBuffer(p2, o)));
      for (var m2 = e.length - (e.length - r) % this.blockSize;r < m2; r += this.blockSize)
        this._update(e, r, p2, o), o += this.blockSize;
      for (;r < e.length; r++, this.bufferOff++)
        this.buffer[this.bufferOff] = e[r];
      return p2;
    };
    mr.prototype._updateDecrypt = function(e) {
      for (var r = 0, o = 0, f2 = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, p2 = new Array(f2 * this.blockSize);f2 > 0; f2--)
        r += this._buffer(e, r), o += this._flushBuffer(p2, o);
      return r += this._buffer(e, r), p2;
    };
    mr.prototype.final = function(e) {
      var r;
      e && (r = this.update(e));
      var o;
      return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), r ? r.concat(o) : o;
    };
    mr.prototype._pad = function(e, r) {
      if (r === 0)
        return false;
      for (;r < e.length; )
        e[r++] = 0;
      return true;
    };
    mr.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var e = new Array(this.blockSize);
      return this._update(this.buffer, 0, e, 0), e;
    };
    mr.prototype._unpad = function(e) {
      return e;
    };
    mr.prototype._finalDecrypt = function() {
      X7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var e = new Array(this.blockSize);
      return this._flushBuffer(e, 0), this._unpad(e);
    };
  });
  ku = T2((gT, $b) => {
    var Zb = ar(), J7 = Ie(), Nt = Tu(), Vb = vs();
    function Q7() {
      this.tmp = new Array(2), this.keys = null;
    }
    function ei(t) {
      Vb.call(this, t);
      var e = new Q7;
      this._desState = e, this.deriveKeys(e, t.key);
    }
    J7(ei, Vb);
    $b.exports = ei;
    ei.create = function(e) {
      return new ei(e);
    };
    var e9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    ei.prototype.deriveKeys = function(e, r) {
      e.keys = new Array(16 * 2), Zb.equal(r.length, this.blockSize, "Invalid key length");
      var o = Nt.readUInt32BE(r, 0), f2 = Nt.readUInt32BE(r, 4);
      Nt.pc1(o, f2, e.tmp, 0), o = e.tmp[0], f2 = e.tmp[1];
      for (var p2 = 0;p2 < e.keys.length; p2 += 2) {
        var m2 = e9[p2 >>> 1];
        o = Nt.r28shl(o, m2), f2 = Nt.r28shl(f2, m2), Nt.pc2(o, f2, e.keys, p2);
      }
    };
    ei.prototype._update = function(e, r, o, f2) {
      var p2 = this._desState, m2 = Nt.readUInt32BE(e, r), y3 = Nt.readUInt32BE(e, r + 4);
      Nt.ip(m2, y3, p2.tmp, 0), m2 = p2.tmp[0], y3 = p2.tmp[1], this.type === "encrypt" ? this._encrypt(p2, m2, y3, p2.tmp, 0) : this._decrypt(p2, m2, y3, p2.tmp, 0), m2 = p2.tmp[0], y3 = p2.tmp[1], Nt.writeUInt32BE(o, m2, f2), Nt.writeUInt32BE(o, y3, f2 + 4);
    };
    ei.prototype._pad = function(e, r) {
      for (var o = e.length - r, f2 = r;f2 < e.length; f2++)
        e[f2] = o;
      return true;
    };
    ei.prototype._unpad = function(e) {
      for (var r = e[e.length - 1], o = e.length - r;o < e.length; o++)
        Zb.equal(e[o], r);
      return e.slice(0, e.length - r);
    };
    ei.prototype._encrypt = function(e, r, o, f2, p2) {
      for (var m2 = r, y3 = o, M2 = 0;M2 < e.keys.length; M2 += 2) {
        var x3 = e.keys[M2], S2 = e.keys[M2 + 1];
        Nt.expand(y3, e.tmp, 0), x3 ^= e.tmp[0], S2 ^= e.tmp[1];
        var E3 = Nt.substitute(x3, S2), B3 = Nt.permute(E3), q2 = y3;
        y3 = (m2 ^ B3) >>> 0, m2 = q2;
      }
      Nt.rip(y3, m2, f2, p2);
    };
    ei.prototype._decrypt = function(e, r, o, f2, p2) {
      for (var m2 = o, y3 = r, M2 = e.keys.length - 2;M2 >= 0; M2 -= 2) {
        var x3 = e.keys[M2], S2 = e.keys[M2 + 1];
        Nt.expand(m2, e.tmp, 0), x3 ^= e.tmp[0], S2 ^= e.tmp[1];
        var E3 = Nt.substitute(x3, S2), B3 = Nt.permute(E3), q2 = m2;
        m2 = (y3 ^ B3) >>> 0, y3 = q2;
      }
      Nt.rip(m2, y3, f2, p2);
    };
  });
  Yb = T2((Gb) => {
    var t9 = ar(), r9 = Ie(), bs = {};
    function i9(t) {
      t9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e = 0;e < this.iv.length; e++)
        this.iv[e] = t[e];
    }
    function n9(t) {
      function e(p2) {
        t.call(this, p2), this._cbcInit();
      }
      r9(e, t);
      for (var r = Object.keys(bs), o = 0;o < r.length; o++) {
        var f2 = r[o];
        e.prototype[f2] = bs[f2];
      }
      return e.create = function(m2) {
        return new e(m2);
      }, e;
    }
    Gb.instantiate = n9;
    bs._cbcInit = function() {
      var e = new i9(this.options.iv);
      this._cbcState = e;
    };
    bs._update = function(e, r, o, f2) {
      var p2 = this._cbcState, m2 = this.constructor.super_.prototype, y3 = p2.iv;
      if (this.type === "encrypt") {
        for (var M2 = 0;M2 < this.blockSize; M2++)
          y3[M2] ^= e[r + M2];
        m2._update.call(this, y3, 0, o, f2);
        for (var M2 = 0;M2 < this.blockSize; M2++)
          y3[M2] = o[f2 + M2];
      } else {
        m2._update.call(this, e, r, o, f2);
        for (var M2 = 0;M2 < this.blockSize; M2++)
          o[f2 + M2] ^= y3[M2];
        for (var M2 = 0;M2 < this.blockSize; M2++)
          y3[M2] = e[r + M2];
      }
    };
  });
  Qb = T2((wT, Jb) => {
    var f9 = ar(), a9 = Ie(), Xb = vs(), Wi = ku();
    function o9(t, e) {
      f9.equal(e.length, 24, "Invalid key length");
      var r = e.slice(0, 8), o = e.slice(8, 16), f2 = e.slice(16, 24);
      t === "encrypt" ? this.ciphers = [Wi.create({ type: "encrypt", key: r }), Wi.create({ type: "decrypt", key: o }), Wi.create({ type: "encrypt", key: f2 })] : this.ciphers = [Wi.create({ type: "decrypt", key: f2 }), Wi.create({ type: "encrypt", key: o }), Wi.create({ type: "decrypt", key: r })];
    }
    function An(t) {
      Xb.call(this, t);
      var e = new o9(this.type, this.options.key);
      this._edeState = e;
    }
    a9(An, Xb);
    Jb.exports = An;
    An.create = function(e) {
      return new An(e);
    };
    An.prototype._update = function(e, r, o, f2) {
      var p2 = this._edeState;
      p2.ciphers[0]._update(e, r, o, f2), p2.ciphers[1]._update(o, f2, o, f2), p2.ciphers[2]._update(o, f2, o, f2);
    };
    An.prototype._pad = Wi.prototype._pad;
    An.prototype._unpad = Wi.prototype._unpad;
  });
  em = T2((gf) => {
    gf.utils = Tu();
    gf.Cipher = vs();
    gf.DES = ku();
    gf.CBC = Yb();
    gf.EDE = Qb();
  });
  im = T2((_T, rm) => {
    var tm = yi(), wi = em(), s9 = Ie(), Rn = Te().Buffer, Sa = { "des-ede3-cbc": wi.CBC.instantiate(wi.EDE), "des-ede3": wi.EDE, "des-ede-cbc": wi.CBC.instantiate(wi.EDE), "des-ede": wi.EDE, "des-cbc": wi.CBC.instantiate(wi.DES), "des-ecb": wi.DES };
    Sa.des = Sa["des-cbc"];
    Sa.des3 = Sa["des-ede3-cbc"];
    rm.exports = ms;
    s9(ms, tm);
    function ms(t) {
      tm.call(this);
      var e = t.mode.toLowerCase(), r = Sa[e], o;
      t.decrypt ? o = "decrypt" : o = "encrypt";
      var f2 = t.key;
      Rn.isBuffer(f2) || (f2 = Rn.from(f2)), (e === "des-ede" || e === "des-ede-cbc") && (f2 = Rn.concat([f2, f2.slice(0, 8)]));
      var p2 = t.iv;
      Rn.isBuffer(p2) || (p2 = Rn.from(p2)), this._des = r.create({ key: f2, iv: p2, type: o });
    }
    ms.prototype._update = function(t) {
      return Rn.from(this._des.update(t));
    };
    ms.prototype._final = function() {
      return Rn.from(this._des.final());
    };
  });
  nm = T2((Lu) => {
    Lu.encrypt = function(t, e) {
      return t._cipher.encryptBlock(e);
    };
    Lu.decrypt = function(t, e) {
      return t._cipher.decryptBlock(e);
    };
  });
  yf = T2((ST, fm) => {
    fm.exports = function(e, r) {
      for (var o = Math.min(e.length, r.length), f2 = new Buffer(o), p2 = 0;p2 < o; ++p2)
        f2[p2] = e[p2] ^ r[p2];
      return f2;
    };
  });
  om = T2((Nu) => {
    var am = yf();
    Nu.encrypt = function(t, e) {
      var r = am(e, t._prev);
      return t._prev = t._cipher.encryptBlock(r), t._prev;
    };
    Nu.decrypt = function(t, e) {
      var r = t._prev;
      t._prev = e;
      var o = t._cipher.decryptBlock(e);
      return am(o, r);
    };
  });
  um = T2((hm) => {
    var Ea = Te().Buffer, h9 = yf();
    function sm(t, e, r) {
      var o = e.length, f2 = h9(e, t._cache);
      return t._cache = t._cache.slice(o), t._prev = Ea.concat([t._prev, r ? e : f2]), f2;
    }
    hm.encrypt = function(t, e, r) {
      for (var o = Ea.allocUnsafe(0), f2;e.length; )
        if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ea.allocUnsafe(0)), t._cache.length <= e.length)
          f2 = t._cache.length, o = Ea.concat([o, sm(t, e.slice(0, f2), r)]), e = e.slice(f2);
        else {
          o = Ea.concat([o, sm(t, e, r)]);
          break;
        }
      return o;
    };
  });
  dm = T2((lm) => {
    var Du = Te().Buffer;
    function u9(t, e, r) {
      var o = t._cipher.encryptBlock(t._prev), f2 = o[0] ^ e;
      return t._prev = Du.concat([t._prev.slice(1), Du.from([r ? e : f2])]), f2;
    }
    lm.encrypt = function(t, e, r) {
      for (var o = e.length, f2 = Du.allocUnsafe(o), p2 = -1;++p2 < o; )
        f2[p2] = u9(t, e[p2], r);
      return f2;
    };
  });
  pm = T2((cm) => {
    var gs = Te().Buffer;
    function l9(t, e, r) {
      for (var o, f2 = -1, p2 = 8, m2 = 0, y3, M2;++f2 < p2; )
        o = t._cipher.encryptBlock(t._prev), y3 = e & 1 << 7 - f2 ? 128 : 0, M2 = o[0] ^ y3, m2 += (M2 & 128) >> f2 % 8, t._prev = d9(t._prev, r ? y3 : M2);
      return m2;
    }
    function d9(t, e) {
      var r = t.length, o = -1, f2 = gs.allocUnsafe(t.length);
      for (t = gs.concat([t, gs.from([e])]);++o < r; )
        f2[o] = t[o] << 1 | t[o + 1] >> 7;
      return f2;
    }
    cm.encrypt = function(t, e, r) {
      for (var o = e.length, f2 = gs.allocUnsafe(o), p2 = -1;++p2 < o; )
        f2[p2] = l9(t, e[p2], r);
      return f2;
    };
  });
  bm = T2((vm) => {
    var c9 = yf();
    function p9(t) {
      return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
    }
    vm.encrypt = function(t, e) {
      for (;t._cache.length < e.length; )
        t._cache = Buffer.concat([t._cache, p9(t)]);
      var r = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), c9(e, r);
    };
  });
  Pu = T2((IT, mm) => {
    function v9(t) {
      for (var e = t.length, r;e--; )
        if (r = t.readUInt8(e), r === 255)
          t.writeUInt8(0, e);
        else {
          r++, t.writeUInt8(r, e);
          break;
        }
    }
    mm.exports = v9;
  });
  Ou = T2((ym) => {
    var b9 = yf(), gm = Te().Buffer, m9 = Pu();
    function g9(t) {
      var e = t._cipher.encryptBlockRaw(t._prev);
      return m9(t._prev), e;
    }
    var Cu = 16;
    ym.encrypt = function(t, e) {
      var r = Math.ceil(e.length / Cu), o = t._cache.length;
      t._cache = gm.concat([t._cache, gm.allocUnsafe(r * Cu)]);
      for (var f2 = 0;f2 < r; f2++) {
        var p2 = g9(t), m2 = o + f2 * Cu;
        t._cache.writeUInt32BE(p2[0], m2 + 0), t._cache.writeUInt32BE(p2[1], m2 + 4), t._cache.writeUInt32BE(p2[2], m2 + 8), t._cache.writeUInt32BE(p2[3], m2 + 12);
      }
      var y3 = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), b9(e, y3);
    };
  });
  Fu = T2((kT, y9) => {
    y9.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
  });
  ws = T2((LT, wm) => {
    var w9 = { ECB: nm(), CBC: om(), CFB: um(), CFB8: dm(), CFB1: pm(), OFB: bm(), CTR: Ou(), GCM: Ou() }, ys = Fu();
    for (Uu in ys)
      ys[Uu].module = w9[ys[Uu].mode];
    var Uu;
    wm.exports = ys;
  });
  Aa = T2((NT, _m) => {
    var Ms = Te().Buffer;
    function Hu(t) {
      Ms.isBuffer(t) || (t = Ms.from(t));
      for (var e = t.length / 4 | 0, r = new Array(e), o = 0;o < e; o++)
        r[o] = t.readUInt32BE(o * 4);
      return r;
    }
    function zu(t) {
      for (var e = 0;e < t.length; t++)
        t[e] = 0;
    }
    function Mm(t, e, r, o, f2) {
      for (var p2 = r[0], m2 = r[1], y3 = r[2], M2 = r[3], x3 = t[0] ^ e[0], S2 = t[1] ^ e[1], E3 = t[2] ^ e[2], B3 = t[3] ^ e[3], q2, L3, ge, _e, N3 = 4, we = 1;we < f2; we++)
        q2 = p2[x3 >>> 24] ^ m2[S2 >>> 16 & 255] ^ y3[E3 >>> 8 & 255] ^ M2[B3 & 255] ^ e[N3++], L3 = p2[S2 >>> 24] ^ m2[E3 >>> 16 & 255] ^ y3[B3 >>> 8 & 255] ^ M2[x3 & 255] ^ e[N3++], ge = p2[E3 >>> 24] ^ m2[B3 >>> 16 & 255] ^ y3[x3 >>> 8 & 255] ^ M2[S2 & 255] ^ e[N3++], _e = p2[B3 >>> 24] ^ m2[x3 >>> 16 & 255] ^ y3[S2 >>> 8 & 255] ^ M2[E3 & 255] ^ e[N3++], x3 = q2, S2 = L3, E3 = ge, B3 = _e;
      return q2 = (o[x3 >>> 24] << 24 | o[S2 >>> 16 & 255] << 16 | o[E3 >>> 8 & 255] << 8 | o[B3 & 255]) ^ e[N3++], L3 = (o[S2 >>> 24] << 24 | o[E3 >>> 16 & 255] << 16 | o[B3 >>> 8 & 255] << 8 | o[x3 & 255]) ^ e[N3++], ge = (o[E3 >>> 24] << 24 | o[B3 >>> 16 & 255] << 16 | o[x3 >>> 8 & 255] << 8 | o[S2 & 255]) ^ e[N3++], _e = (o[B3 >>> 24] << 24 | o[x3 >>> 16 & 255] << 16 | o[S2 >>> 8 & 255] << 8 | o[E3 & 255]) ^ e[N3++], q2 = q2 >>> 0, L3 = L3 >>> 0, ge = ge >>> 0, _e = _e >>> 0, [q2, L3, ge, _e];
    }
    var M9 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt = function() {
      for (var t = new Array(256), e = 0;e < 256; e++)
        e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
      for (var r = [], o = [], f2 = [[], [], [], []], p2 = [[], [], [], []], m2 = 0, y3 = 0, M2 = 0;M2 < 256; ++M2) {
        var x3 = y3 ^ y3 << 1 ^ y3 << 2 ^ y3 << 3 ^ y3 << 4;
        x3 = x3 >>> 8 ^ x3 & 255 ^ 99, r[m2] = x3, o[x3] = m2;
        var S2 = t[m2], E3 = t[S2], B3 = t[E3], q2 = t[x3] * 257 ^ x3 * 16843008;
        f2[0][m2] = q2 << 24 | q2 >>> 8, f2[1][m2] = q2 << 16 | q2 >>> 16, f2[2][m2] = q2 << 8 | q2 >>> 24, f2[3][m2] = q2, q2 = B3 * 16843009 ^ E3 * 65537 ^ S2 * 257 ^ m2 * 16843008, p2[0][x3] = q2 << 24 | q2 >>> 8, p2[1][x3] = q2 << 16 | q2 >>> 16, p2[2][x3] = q2 << 8 | q2 >>> 24, p2[3][x3] = q2, m2 === 0 ? m2 = y3 = 1 : (m2 = S2 ^ t[t[t[B3 ^ S2]]], y3 ^= t[t[y3]]);
      }
      return { SBOX: r, INV_SBOX: o, SUB_MIX: f2, INV_SUB_MIX: p2 };
    }();
    function gr(t) {
      this._key = Hu(t), this._reset();
    }
    gr.blockSize = 4 * 4;
    gr.keySize = 256 / 8;
    gr.prototype.blockSize = gr.blockSize;
    gr.prototype.keySize = gr.keySize;
    gr.prototype._reset = function() {
      for (var t = this._key, e = t.length, r = e + 6, o = (r + 1) * 4, f2 = [], p2 = 0;p2 < e; p2++)
        f2[p2] = t[p2];
      for (p2 = e;p2 < o; p2++) {
        var m2 = f2[p2 - 1];
        p2 % e === 0 ? (m2 = m2 << 8 | m2 >>> 24, m2 = kt.SBOX[m2 >>> 24] << 24 | kt.SBOX[m2 >>> 16 & 255] << 16 | kt.SBOX[m2 >>> 8 & 255] << 8 | kt.SBOX[m2 & 255], m2 ^= M9[p2 / e | 0] << 24) : e > 6 && p2 % e === 4 && (m2 = kt.SBOX[m2 >>> 24] << 24 | kt.SBOX[m2 >>> 16 & 255] << 16 | kt.SBOX[m2 >>> 8 & 255] << 8 | kt.SBOX[m2 & 255]), f2[p2] = f2[p2 - e] ^ m2;
      }
      for (var y3 = [], M2 = 0;M2 < o; M2++) {
        var x3 = o - M2, S2 = f2[x3 - (M2 % 4 ? 0 : 4)];
        M2 < 4 || x3 <= 4 ? y3[M2] = S2 : y3[M2] = kt.INV_SUB_MIX[0][kt.SBOX[S2 >>> 24]] ^ kt.INV_SUB_MIX[1][kt.SBOX[S2 >>> 16 & 255]] ^ kt.INV_SUB_MIX[2][kt.SBOX[S2 >>> 8 & 255]] ^ kt.INV_SUB_MIX[3][kt.SBOX[S2 & 255]];
      }
      this._nRounds = r, this._keySchedule = f2, this._invKeySchedule = y3;
    };
    gr.prototype.encryptBlockRaw = function(t) {
      return t = Hu(t), Mm(t, this._keySchedule, kt.SUB_MIX, kt.SBOX, this._nRounds);
    };
    gr.prototype.encryptBlock = function(t) {
      var e = this.encryptBlockRaw(t), r = Ms.allocUnsafe(16);
      return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
    };
    gr.prototype.decryptBlock = function(t) {
      t = Hu(t);
      var e = t[1];
      t[1] = t[3], t[3] = e;
      var r = Mm(t, this._invKeySchedule, kt.INV_SUB_MIX, kt.INV_SBOX, this._nRounds), o = Ms.allocUnsafe(16);
      return o.writeUInt32BE(r[0], 0), o.writeUInt32BE(r[3], 4), o.writeUInt32BE(r[2], 8), o.writeUInt32BE(r[1], 12), o;
    };
    gr.prototype.scrub = function() {
      zu(this._keySchedule), zu(this._invKeySchedule), zu(this._key);
    };
    _m.exports.AES = gr;
  });
  Em = T2((DT, Sm) => {
    var wf = Te().Buffer, _9 = wf.alloc(16, 0);
    function x9(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
    }
    function xm(t) {
      var e = wf.allocUnsafe(16);
      return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
    }
    function Ra(t) {
      this.h = t, this.state = wf.alloc(16, 0), this.cache = wf.allocUnsafe(0);
    }
    Ra.prototype.ghash = function(t) {
      for (var e = -1;++e < t.length; )
        this.state[e] ^= t[e];
      this._multiply();
    };
    Ra.prototype._multiply = function() {
      for (var t = x9(this.h), e = [0, 0, 0, 0], r, o, f2, p2 = -1;++p2 < 128; ) {
        for (o = (this.state[~~(p2 / 8)] & 1 << 7 - p2 % 8) !== 0, o && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), f2 = (t[3] & 1) !== 0, r = 3;r > 0; r--)
          t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, f2 && (t[0] = t[0] ^ 225 << 24);
      }
      this.state = xm(e);
    };
    Ra.prototype.update = function(t) {
      this.cache = wf.concat([this.cache, t]);
      for (var e;this.cache.length >= 16; )
        e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
    };
    Ra.prototype.final = function(t, e) {
      return this.cache.length && this.ghash(wf.concat([this.cache, _9], 16)), this.ghash(xm([0, t, 0, e])), this.state;
    };
    Sm.exports = Ra;
  });
  Wu = T2((PT, Bm) => {
    var S9 = Aa(), rr = Te().Buffer, Am = yi(), E9 = Ie(), Rm = Em(), A9 = yf(), R9 = Pu();
    function B9(t, e) {
      var r = 0;
      t.length !== e.length && r++;
      for (var o = Math.min(t.length, e.length), f2 = 0;f2 < o; ++f2)
        r += t[f2] ^ e[f2];
      return r;
    }
    function q9(t, e, r) {
      if (e.length === 12)
        return t._finID = rr.concat([e, rr.from([0, 0, 0, 1])]), rr.concat([e, rr.from([0, 0, 0, 2])]);
      var o = new Rm(r), f2 = e.length, p2 = f2 % 16;
      o.update(e), p2 && (p2 = 16 - p2, o.update(rr.alloc(p2, 0))), o.update(rr.alloc(8, 0));
      var m2 = f2 * 8, y3 = rr.alloc(8);
      y3.writeUIntBE(m2, 0, 8), o.update(y3), t._finID = o.state;
      var M2 = rr.from(t._finID);
      return R9(M2), M2;
    }
    function Bn(t, e, r, o) {
      Am.call(this);
      var f2 = rr.alloc(4, 0);
      this._cipher = new S9.AES(e);
      var p2 = this._cipher.encryptBlock(f2);
      this._ghash = new Rm(p2), r = q9(this, r, p2), this._prev = rr.from(r), this._cache = rr.allocUnsafe(0), this._secCache = rr.allocUnsafe(0), this._decrypt = o, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
    }
    E9(Bn, Am);
    Bn.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var e = 16 - this._alen % 16;
        e < 16 && (e = rr.alloc(e, 0), this._ghash.update(e));
      }
      this._called = true;
      var r = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
    };
    Bn.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var t = A9(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && B9(t, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub();
    };
    Bn.prototype.getAuthTag = function() {
      if (this._decrypt || !rr.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    Bn.prototype.setAuthTag = function(e) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = e;
    };
    Bn.prototype.setAAD = function(e) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(e), this._alen += e.length;
    };
    Bm.exports = Bn;
  });
  ju = T2((CT, Im) => {
    var I9 = Aa(), Ku = Te().Buffer, qm = yi(), T9 = Ie();
    function _s(t, e, r, o) {
      qm.call(this), this._cipher = new I9.AES(e), this._prev = Ku.from(r), this._cache = Ku.allocUnsafe(0), this._secCache = Ku.allocUnsafe(0), this._decrypt = o, this._mode = t;
    }
    T9(_s, qm);
    _s.prototype._update = function(t) {
      return this._mode.encrypt(this, t, this._decrypt);
    };
    _s.prototype._final = function() {
      this._cipher.scrub();
    };
    Im.exports = _s;
  });
  Ba = T2((OT, Tm) => {
    var qn = Te().Buffer, k9 = Ao();
    function L9(t, e, r, o) {
      if (qn.isBuffer(t) || (t = qn.from(t, "binary")), e && (qn.isBuffer(e) || (e = qn.from(e, "binary")), e.length !== 8))
        throw new RangeError("salt should be Buffer with 8 byte length");
      for (var f2 = r / 8, p2 = qn.alloc(f2), m2 = qn.alloc(o || 0), y3 = qn.alloc(0);f2 > 0 || o > 0; ) {
        var M2 = new k9;
        M2.update(y3), M2.update(t), e && M2.update(e), y3 = M2.digest();
        var x3 = 0;
        if (f2 > 0) {
          var S2 = p2.length - f2;
          x3 = Math.min(f2, y3.length), y3.copy(p2, S2, 0, x3), f2 -= x3;
        }
        if (x3 < y3.length && o > 0) {
          var E3 = m2.length - o, B3 = Math.min(o, y3.length - x3);
          y3.copy(m2, E3, x3, x3 + B3), o -= B3;
        }
      }
      return y3.fill(0), { key: p2, iv: m2 };
    }
    Tm.exports = L9;
  });
  Dm = T2((Zu) => {
    var km = ws(), N9 = Wu(), Mi = Te().Buffer, D9 = ju(), Lm = yi(), P9 = Aa(), C9 = Ba(), O9 = Ie();
    function qa(t, e, r) {
      Lm.call(this), this._cache = new xs, this._cipher = new P9.AES(e), this._prev = Mi.from(r), this._mode = t, this._autopadding = true;
    }
    O9(qa, Lm);
    qa.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(); )
        r = this._mode.encrypt(this, e), o.push(r);
      return Mi.concat(o);
    };
    var F9 = Mi.alloc(16, 16);
    qa.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
      if (!t.equals(F9))
        throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    qa.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function xs() {
      this.cache = Mi.allocUnsafe(0);
    }
    xs.prototype.add = function(t) {
      this.cache = Mi.concat([this.cache, t]);
    };
    xs.prototype.get = function() {
      if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t;
      }
      return null;
    };
    xs.prototype.flush = function() {
      for (var t = 16 - this.cache.length, e = Mi.allocUnsafe(t), r = -1;++r < t; )
        e.writeUInt8(t, r);
      return Mi.concat([this.cache, e]);
    };
    function Nm(t, e, r) {
      var o = km[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof e == "string" && (e = Mi.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      if (typeof r == "string" && (r = Mi.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      return o.type === "stream" ? new D9(o.module, e, r) : o.type === "auth" ? new N9(o.module, e, r) : new qa(o.module, e, r);
    }
    function U9(t, e) {
      var r = km[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = C9(e, false, r.key, r.iv);
      return Nm(t, o.key, o.iv);
    }
    Zu.createCipheriv = Nm;
    Zu.createCipher = U9;
  });
  Fm = T2((Vu) => {
    var z9 = Wu(), Mf = Te().Buffer, Pm = ws(), H9 = ju(), Cm = yi(), W9 = Aa(), K9 = Ba(), j9 = Ie();
    function Ia(t, e, r) {
      Cm.call(this), this._cache = new Ss, this._last = undefined, this._cipher = new W9.AES(e), this._prev = Mf.from(r), this._mode = t, this._autopadding = true;
    }
    j9(Ia, Cm);
    Ia.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(this._autopadding); )
        r = this._mode.decrypt(this, e), o.push(r);
      return Mf.concat(o);
    };
    Ia.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return Z9(this._mode.decrypt(this, t));
      if (t)
        throw new Error("data not multiple of block length");
    };
    Ia.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function Ss() {
      this.cache = Mf.allocUnsafe(0);
    }
    Ss.prototype.add = function(t) {
      this.cache = Mf.concat([this.cache, t]);
    };
    Ss.prototype.get = function(t) {
      var e;
      if (t) {
        if (this.cache.length > 16)
          return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      } else if (this.cache.length >= 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      return null;
    };
    Ss.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function Z9(t) {
      var e = t[15];
      if (e < 1 || e > 16)
        throw new Error("unable to decrypt data");
      for (var r = -1;++r < e; )
        if (t[r + (16 - e)] !== e)
          throw new Error("unable to decrypt data");
      if (e !== 16)
        return t.slice(0, 16 - e);
    }
    function Om(t, e, r) {
      var o = Pm[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof r == "string" && (r = Mf.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      if (typeof e == "string" && (e = Mf.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      return o.type === "stream" ? new H9(o.module, e, r, true) : o.type === "auth" ? new z9(o.module, e, r, true) : new Ia(o.module, e, r);
    }
    function V9(t, e) {
      var r = Pm[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = K9(e, false, r.key, r.iv);
      return Om(t, o.key, o.iv);
    }
    Vu.createDecipher = V9;
    Vu.createDecipheriv = Om;
  });
  Es = T2((Nr) => {
    var Um = Dm(), zm = Fm(), $9 = Fu();
    function G9() {
      return Object.keys($9);
    }
    Nr.createCipher = Nr.Cipher = Um.createCipher;
    Nr.createCipheriv = Nr.Cipheriv = Um.createCipheriv;
    Nr.createDecipher = Nr.Decipher = zm.createDecipher;
    Nr.createDecipheriv = Nr.Decipheriv = zm.createDecipheriv;
    Nr.listCiphers = Nr.getCiphers = G9;
  });
  Hm = T2((_i) => {
    _i["des-ecb"] = { key: 8, iv: 0 };
    _i["des-cbc"] = _i.des = { key: 8, iv: 8 };
    _i["des-ede3-cbc"] = _i.des3 = { key: 24, iv: 8 };
    _i["des-ede3"] = { key: 24, iv: 0 };
    _i["des-ede-cbc"] = { key: 16, iv: 8 };
    _i["des-ede"] = { key: 16, iv: 0 };
  });
  Vm = T2((Dr) => {
    var Wm = im(), $u = Es(), Ki = ws(), xi = Hm(), Km = Ba();
    function Y9(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f2 = Km(e, false, r, o);
      return jm(t, f2.key, f2.iv);
    }
    function X9(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f2 = Km(e, false, r, o);
      return Zm(t, f2.key, f2.iv);
    }
    function jm(t, e, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createCipheriv(t, e, r);
      if (xi[t])
        return new Wm({ key: e, iv: r, mode: t });
      throw new TypeError("invalid suite type");
    }
    function Zm(t, e, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createDecipheriv(t, e, r);
      if (xi[t])
        return new Wm({ key: e, iv: r, mode: t, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function J9() {
      return Object.keys(xi).concat($u.getCiphers());
    }
    Dr.createCipher = Dr.Cipher = Y9;
    Dr.createCipheriv = Dr.Cipheriv = jm;
    Dr.createDecipher = Dr.Decipher = X9;
    Dr.createDecipheriv = Dr.Decipheriv = Zm;
    Dr.listCiphers = Dr.getCiphers = J9;
  });
  ji = T2(() => {
  });
  Yu = T2(($m, Gu) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a2 = function() {
        };
        a2.prototype = i.prototype, v.prototype = new a2, v.prototype.constructor = v;
      }
      function f2(v, i, a2) {
        if (f2.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v || 0, i || 10, a2 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a2) {
        return i.cmp(a2) > 0 ? i : a2;
      }, f2.min = function(i, a2) {
        return i.cmp(a2) < 0 ? i : a2;
      }, f2.prototype._init = function(i, a2, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a2, h3);
        if (typeof i == "object")
          return this._initArray(i, a2, h3);
        a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
        var s2 = 0;
        i[0] === "-" && (s2++, this.negative = 1), s2 < i.length && (a2 === 16 ? this._parseHex(i, s2, h3) : (this._parseBase(i, a2, s2), h3 === "le" && this._initArray(this.toArray(), a2, h3)));
      }, f2.prototype._initNumber = function(i, a2, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a2, h3);
      }, f2.prototype._initArray = function(i, a2, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u3, c2, b2 = 0;
        if (h3 === "be")
          for (s2 = i.length - 1, u3 = 0;s2 >= 0; s2 -= 3)
            c2 = i[s2] | i[s2 - 1] << 8 | i[s2 - 2] << 16, this.words[u3] |= c2 << b2 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u3++);
        else if (h3 === "le")
          for (s2 = 0, u3 = 0;s2 < i.length; s2 += 3)
            c2 = i[s2] | i[s2 + 1] << 8 | i[s2 + 2] << 16, this.words[u3] |= c2 << b2 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u3++);
        return this.strip();
      };
      function m2(v, i) {
        var a2 = v.charCodeAt(i);
        return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
      }
      function y3(v, i, a2) {
        var h3 = m2(v, a2);
        return a2 - 1 >= i && (h3 |= m2(v, a2 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a2, h3) {
        this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u3 = 0, c2 = 0, b2;
        if (h3 === "be")
          for (s2 = i.length - 1;s2 >= a2; s2 -= 2)
            b2 = y3(i, a2, s2) << u3, this.words[c2] |= b2 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b2 >>> 26) : u3 += 8;
        else {
          var l2 = i.length - a2;
          for (s2 = l2 % 2 === 0 ? a2 + 1 : a2;s2 < i.length; s2 += 2)
            b2 = y3(i, a2, s2) << u3, this.words[c2] |= b2 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b2 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M2(v, i, a2, h3) {
        for (var s2 = 0, u3 = Math.min(v.length, a2), c2 = i;c2 < u3; c2++) {
          var b2 = v.charCodeAt(c2) - 48;
          s2 *= h3, b2 >= 49 ? s2 += b2 - 49 + 10 : b2 >= 17 ? s2 += b2 - 17 + 10 : s2 += b2;
        }
        return s2;
      }
      f2.prototype._parseBase = function(i, a2, h3) {
        this.words = [0], this.length = 1;
        for (var s2 = 0, u3 = 1;u3 <= 67108863; u3 *= a2)
          s2++;
        s2--, u3 = u3 / a2 | 0;
        for (var c2 = i.length - h3, b2 = c2 % s2, l2 = Math.min(c2, c2 - b2) + h3, n = 0, d2 = h3;d2 < l2; d2 += s2)
          n = M2(i, d2, d2 + s2, a2), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b2; d2++)
            w *= a2;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a2 = 0;a2 < this.length; a2++)
          i.words[a2] = this.words[a2];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a2) {
        i = i || 10, a2 = a2 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s2 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b2 = this.words[c2], l2 = ((b2 << s2 | u3) & 16777215).toString(16);
            u3 = b2 >>> 24 - s2 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l2.length] + l2 + h3 : h3 = l2 + h3, s2 += 2, s2 >= 26 && (s2 -= 26, c2--);
          }
          for (u3 !== 0 && (h3 = u3.toString(16) + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d2 = E3[i];
          h3 = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g3 = w.modn(d2).toString(i);
            w = w.idivn(d2), w.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a2) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
      }, f2.prototype.toArray = function(i, a2) {
        return this.toArrayLike(Array, i, a2);
      }, f2.prototype.toArrayLike = function(i, a2, h3) {
        var s2 = this.byteLength(), u3 = h3 || Math.max(1, s2);
        r(s2 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a2 === "le", b2 = new i(u3), l2, n, d2 = this.clone();
        if (c2) {
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b2[n] = l2;
          for (;n < u3; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u3 - s2; n++)
            b2[n] = 0;
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b2[u3 - n - 1] = l2;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a2 = i, h3 = 0;
        return a2 >= 4096 && (h3 += 13, a2 >>>= 13), a2 >= 64 && (h3 += 7, a2 >>>= 7), a2 >= 8 && (h3 += 4, a2 >>>= 4), a2 >= 2 && (h3 += 2, a2 >>>= 2), h3 + a2;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a2 = i, h3 = 0;
        return (a2 & 8191) === 0 && (h3 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h3 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h3 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h3 += 2, a2 >>>= 2), (a2 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a2 = this._countBits(i);
        return (this.length - 1) * 26 + a2;
      };
      function B3(v) {
        for (var i = new Array(v.bitLength()), a2 = 0;a2 < i.length; a2++) {
          var h3 = a2 / 26 | 0, s2 = a2 % 26;
          i[a2] = (v.words[h3] & 1 << s2) >>> s2;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a2 = 0;a2 < this.length; a2++) {
          var h3 = this._zeroBits(this.words[a2]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a2 = 0;a2 < i.length; a2++)
          this.words[a2] = this.words[a2] | i.words[a2];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a2;
        this.length > i.length ? a2 = i : a2 = this;
        for (var h3 = 0;h3 < a2.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a2, h3;
        this.length > i.length ? (a2 = this, h3 = i) : (a2 = i, h3 = this);
        for (var s2 = 0;s2 < h3.length; s2++)
          this.words[s2] = a2.words[s2] ^ h3.words[s2];
        if (this !== a2)
          for (;s2 < a2.length; s2++)
            this.words[s2] = a2.words[s2];
        return this.length = a2.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a2), h3 > 0 && a2--;
        for (var s2 = 0;s2 < a2; s2++)
          this.words[s2] = ~this.words[s2] & 67108863;
        return h3 > 0 && (this.words[s2] = ~this.words[s2] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a2) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s2 = i % 26;
        return this._expand(h3 + 1), a2 ? this.words[h3] = this.words[h3] | 1 << s2 : this.words[h3] = this.words[h3] & ~(1 << s2), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a2;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
        var h3, s2;
        this.length > i.length ? (h3 = this, s2 = i) : (h3 = i, s2 = this);
        for (var u3 = 0, c2 = 0;c2 < s2.length; c2++)
          a2 = (h3.words[c2] | 0) + (s2.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        for (;u3 !== 0 && c2 < h3.length; c2++)
          a2 = (h3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        if (this.length = h3.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a2;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a2 = this.iadd(i);
          return i.negative = 1, a2._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s2, u3;
        h3 > 0 ? (s2 = this, u3 = i) : (s2 = i, u3 = this);
        for (var c2 = 0, b2 = 0;b2 < u3.length; b2++)
          a2 = (s2.words[b2] | 0) - (u3.words[b2] | 0) + c2, c2 = a2 >> 26, this.words[b2] = a2 & 67108863;
        for (;c2 !== 0 && b2 < s2.length; b2++)
          a2 = (s2.words[b2] | 0) + c2, c2 = a2 >> 26, this.words[b2] = a2 & 67108863;
        if (c2 === 0 && b2 < s2.length && s2 !== this)
          for (;b2 < s2.length; b2++)
            this.words[b2] = s2.words[b2];
        return this.length = Math.max(this.length, b2), s2 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q2(v, i, a2) {
        a2.negative = i.negative ^ v.negative;
        var h3 = v.length + i.length | 0;
        a2.length = h3, h3 = h3 - 1 | 0;
        var s2 = v.words[0] | 0, u3 = i.words[0] | 0, c2 = s2 * u3, b2 = c2 & 67108863, l2 = c2 / 67108864 | 0;
        a2.words[0] = b2;
        for (var n = 1;n < h3; n++) {
          for (var d2 = l2 >>> 26, w = l2 & 67108863, g3 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v.length + 1);_3 <= g3; _3++) {
            var A2 = n - _3 | 0;
            s2 = v.words[A2] | 0, u3 = i.words[_3] | 0, c2 = s2 * u3 + w, d2 += c2 / 67108864 | 0, w = c2 & 67108863;
          }
          a2.words[n] = w | 0, l2 = d2 | 0;
        }
        return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
      }
      var L3 = function(i, a2, h3) {
        var s2 = i.words, u3 = a2.words, c2 = h3.words, b2 = 0, l2, n, d2, w = s2[0] | 0, g3 = w & 8191, _3 = w >>> 13, A2 = s2[1] | 0, R2 = A2 & 8191, I3 = A2 >>> 13, Me = s2[2] | 0, k3 = Me & 8191, D2 = Me >>> 13, nt = s2[3] | 0, C = nt & 8191, O3 = nt >>> 13, vt = s2[4] | 0, F = vt & 8191, U3 = vt >>> 13, bt = s2[5] | 0, z = bt & 8191, H2 = bt >>> 13, mt = s2[6] | 0, W = mt & 8191, K2 = mt >>> 13, gt = s2[7] | 0, j3 = gt & 8191, Z2 = gt >>> 13, yt = s2[8] | 0, V3 = yt & 8191, $2 = yt >>> 13, wt = s2[9] | 0, G2 = wt & 8191, Y2 = wt >>> 13, Mt = u3[0] | 0, X3 = Mt & 8191, J2 = Mt >>> 13, _t = u3[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u3[2] | 0, te = xt & 8191, re = xt >>> 13, St = u3[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u3[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u3[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u3[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u3[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u3[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u3[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a2.negative, h3.length = 19, l2 = Math.imul(g3, X3), n = Math.imul(g3, J2), n = n + Math.imul(_3, X3) | 0, d2 = Math.imul(_3, J2);
        var ft = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l2 = Math.imul(R2, X3), n = Math.imul(R2, J2), n = n + Math.imul(I3, X3) | 0, d2 = Math.imul(I3, J2), l2 = l2 + Math.imul(g3, Q2) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_3, Q2) | 0, d2 = d2 + Math.imul(_3, ee) | 0;
        var Be = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k3, X3), n = Math.imul(k3, J2), n = n + Math.imul(D2, X3) | 0, d2 = Math.imul(D2, J2), l2 = l2 + Math.imul(R2, Q2) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I3, Q2) | 0, d2 = d2 + Math.imul(I3, ee) | 0, l2 = l2 + Math.imul(g3, te) | 0, n = n + Math.imul(g3, re) | 0, n = n + Math.imul(_3, te) | 0, d2 = d2 + Math.imul(_3, re) | 0;
        var qe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l2 = Math.imul(C, X3), n = Math.imul(C, J2), n = n + Math.imul(O3, X3) | 0, d2 = Math.imul(O3, J2), l2 = l2 + Math.imul(k3, Q2) | 0, n = n + Math.imul(k3, ee) | 0, n = n + Math.imul(D2, Q2) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R2, te) | 0, n = n + Math.imul(R2, re) | 0, n = n + Math.imul(I3, te) | 0, d2 = d2 + Math.imul(I3, re) | 0, l2 = l2 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_3, ie) | 0, d2 = d2 + Math.imul(_3, ne) | 0;
        var ze = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F, X3), n = Math.imul(F, J2), n = n + Math.imul(U3, X3) | 0, d2 = Math.imul(U3, J2), l2 = l2 + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O3, Q2) | 0, d2 = d2 + Math.imul(O3, ee) | 0, l2 = l2 + Math.imul(k3, te) | 0, n = n + Math.imul(k3, re) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re) | 0, l2 = l2 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I3, ie) | 0, d2 = d2 + Math.imul(I3, ne) | 0, l2 = l2 + Math.imul(g3, fe) | 0, n = n + Math.imul(g3, ae) | 0, n = n + Math.imul(_3, fe) | 0, d2 = d2 + Math.imul(_3, ae) | 0;
        var He = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X3), n = Math.imul(z, J2), n = n + Math.imul(H2, X3) | 0, d2 = Math.imul(H2, J2), l2 = l2 + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U3, Q2) | 0, d2 = d2 + Math.imul(U3, ee) | 0, l2 = l2 + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O3, te) | 0, d2 = d2 + Math.imul(O3, re) | 0, l2 = l2 + Math.imul(k3, ie) | 0, n = n + Math.imul(k3, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R2, fe) | 0, n = n + Math.imul(R2, ae) | 0, n = n + Math.imul(I3, fe) | 0, d2 = d2 + Math.imul(I3, ae) | 0, l2 = l2 + Math.imul(g3, oe) | 0, n = n + Math.imul(g3, se) | 0, n = n + Math.imul(_3, oe) | 0, d2 = d2 + Math.imul(_3, se) | 0;
        var We = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X3), n = Math.imul(W, J2), n = n + Math.imul(K2, X3) | 0, d2 = Math.imul(K2, J2), l2 = l2 + Math.imul(z, Q2) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q2) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U3, te) | 0, d2 = d2 + Math.imul(U3, re) | 0, l2 = l2 + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O3, ie) | 0, d2 = d2 + Math.imul(O3, ne) | 0, l2 = l2 + Math.imul(k3, fe) | 0, n = n + Math.imul(k3, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R2, oe) | 0, n = n + Math.imul(R2, se) | 0, n = n + Math.imul(I3, oe) | 0, d2 = d2 + Math.imul(I3, se) | 0, l2 = l2 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue) | 0, n = n + Math.imul(_3, he) | 0, d2 = d2 + Math.imul(_3, ue) | 0;
        var Ke = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j3, X3), n = Math.imul(j3, J2), n = n + Math.imul(Z2, X3) | 0, d2 = Math.imul(Z2, J2), l2 = l2 + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q2) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re) | 0, l2 = l2 + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U3, ie) | 0, d2 = d2 + Math.imul(U3, ne) | 0, l2 = l2 + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O3, fe) | 0, d2 = d2 + Math.imul(O3, ae) | 0, l2 = l2 + Math.imul(k3, oe) | 0, n = n + Math.imul(k3, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue) | 0, n = n + Math.imul(I3, he) | 0, d2 = d2 + Math.imul(I3, ue) | 0, l2 = l2 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_3, le) | 0, d2 = d2 + Math.imul(_3, de) | 0;
        var je = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X3), n = Math.imul(V3, J2), n = n + Math.imul($2, X3) | 0, d2 = Math.imul($2, J2), l2 = l2 + Math.imul(j3, Q2) | 0, n = n + Math.imul(j3, ee) | 0, n = n + Math.imul(Z2, Q2) | 0, d2 = d2 + Math.imul(Z2, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U3, fe) | 0, d2 = d2 + Math.imul(U3, ae) | 0, l2 = l2 + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O3, oe) | 0, d2 = d2 + Math.imul(O3, se) | 0, l2 = l2 + Math.imul(k3, he) | 0, n = n + Math.imul(k3, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I3, le) | 0, d2 = d2 + Math.imul(I3, de) | 0, l2 = l2 + Math.imul(g3, ce) | 0, n = n + Math.imul(g3, pe) | 0, n = n + Math.imul(_3, ce) | 0, d2 = d2 + Math.imul(_3, pe) | 0;
        var Ze = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G2, X3), n = Math.imul(G2, J2), n = n + Math.imul(Y2, X3) | 0, d2 = Math.imul(Y2, J2), l2 = l2 + Math.imul(V3, Q2) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q2) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j3, te) | 0, n = n + Math.imul(j3, re) | 0, n = n + Math.imul(Z2, te) | 0, d2 = d2 + Math.imul(Z2, re) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U3, oe) | 0, d2 = d2 + Math.imul(U3, se) | 0, l2 = l2 + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O3, he) | 0, d2 = d2 + Math.imul(O3, ue) | 0, l2 = l2 + Math.imul(k3, le) | 0, n = n + Math.imul(k3, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R2, ce) | 0, n = n + Math.imul(R2, pe) | 0, n = n + Math.imul(I3, ce) | 0, d2 = d2 + Math.imul(I3, pe) | 0, l2 = l2 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_3, ve) | 0, d2 = d2 + Math.imul(_3, be) | 0;
        var Ve = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G2, Q2), n = Math.imul(G2, ee), n = n + Math.imul(Y2, Q2) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re) | 0, l2 = l2 + Math.imul(j3, ie) | 0, n = n + Math.imul(j3, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d2 = d2 + Math.imul(Z2, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U3, he) | 0, d2 = d2 + Math.imul(U3, ue) | 0, l2 = l2 + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O3, le) | 0, d2 = d2 + Math.imul(O3, de) | 0, l2 = l2 + Math.imul(k3, ce) | 0, n = n + Math.imul(k3, pe) | 0, n = n + Math.imul(D2, ce) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I3, ve) | 0, d2 = d2 + Math.imul(I3, be) | 0;
        var $e = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G2, te), n = Math.imul(G2, re), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j3, fe) | 0, n = n + Math.imul(j3, ae) | 0, n = n + Math.imul(Z2, fe) | 0, d2 = d2 + Math.imul(Z2, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U3, le) | 0, d2 = d2 + Math.imul(U3, de) | 0, l2 = l2 + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O3, ce) | 0, d2 = d2 + Math.imul(O3, pe) | 0, l2 = l2 + Math.imul(k3, ve) | 0, n = n + Math.imul(k3, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
        var Ge = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j3, oe) | 0, n = n + Math.imul(j3, se) | 0, n = n + Math.imul(Z2, oe) | 0, d2 = d2 + Math.imul(Z2, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U3, ce) | 0, d2 = d2 + Math.imul(U3, pe) | 0, l2 = l2 + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O3, ve) | 0, d2 = d2 + Math.imul(O3, be) | 0;
        var Ye = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G2, fe), n = Math.imul(G2, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j3, he) | 0, n = n + Math.imul(j3, ue) | 0, n = n + Math.imul(Z2, he) | 0, d2 = d2 + Math.imul(Z2, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U3, ve) | 0, d2 = d2 + Math.imul(U3, be) | 0;
        var Xe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G2, oe), n = Math.imul(G2, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j3, le) | 0, n = n + Math.imul(j3, de) | 0, n = n + Math.imul(Z2, le) | 0, d2 = d2 + Math.imul(Z2, de) | 0, l2 = l2 + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
        var Je = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G2, he), n = Math.imul(G2, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j3, ce) | 0, n = n + Math.imul(j3, pe) | 0, n = n + Math.imul(Z2, ce) | 0, d2 = d2 + Math.imul(Z2, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
        var Qe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j3, ve) | 0, n = n + Math.imul(j3, be) | 0, n = n + Math.imul(Z2, ve) | 0, d2 = d2 + Math.imul(Z2, be) | 0;
        var et = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G2, ce), n = Math.imul(G2, pe), n = n + Math.imul(Y2, ce) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
        var tt = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l2 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
        var rt = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d2 + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe, c2[3] = ze, c2[4] = He, c2[5] = We, c2[6] = Ke, c2[7] = je, c2[8] = Ze, c2[9] = Ve, c2[10] = $e, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe, c2[16] = et, c2[17] = tt, c2[18] = rt, b2 !== 0 && (c2[19] = b2, h3.length++), h3;
      };
      Math.imul || (L3 = q2);
      function ge(v, i, a2) {
        a2.negative = i.negative ^ v.negative, a2.length = v.length + i.length;
        for (var h3 = 0, s2 = 0, u3 = 0;u3 < a2.length - 1; u3++) {
          var c2 = s2;
          s2 = 0;
          for (var b2 = h3 & 67108863, l2 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v.length + 1);n <= l2; n++) {
            var d2 = u3 - n, w = v.words[d2] | 0, g3 = i.words[n] | 0, _3 = w * g3, A2 = _3 & 67108863;
            c2 = c2 + (_3 / 67108864 | 0) | 0, A2 = A2 + b2 | 0, b2 = A2 & 67108863, c2 = c2 + (A2 >>> 26) | 0, s2 += c2 >>> 26, c2 &= 67108863;
          }
          a2.words[u3] = b2, h3 = c2, c2 = s2;
        }
        return h3 !== 0 ? a2.words[u3] = h3 : a2.length--, a2.strip();
      }
      function _e(v, i, a2) {
        var h3 = new N3;
        return h3.mulp(v, i, a2);
      }
      f2.prototype.mulTo = function(i, a2) {
        var h3, s2 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a2) : s2 < 63 ? h3 = q2(this, i, a2) : s2 < 1024 ? h3 = ge(this, i, a2) : h3 = _e(this, i, a2), h3;
      };
      function N3(v, i) {
        this.x = v, this.y = i;
      }
      N3.prototype.makeRBT = function(i) {
        for (var a2 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s2 = 0;s2 < i; s2++)
          a2[s2] = this.revBin(s2, h3, i);
        return a2;
      }, N3.prototype.revBin = function(i, a2, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s2 = 0, u3 = 0;u3 < a2; u3++)
          s2 |= (i & 1) << a2 - u3 - 1, i >>= 1;
        return s2;
      }, N3.prototype.permute = function(i, a2, h3, s2, u3, c2) {
        for (var b2 = 0;b2 < c2; b2++)
          s2[b2] = a2[i[b2]], u3[b2] = h3[i[b2]];
      }, N3.prototype.transform = function(i, a2, h3, s2, u3, c2) {
        this.permute(c2, i, a2, h3, s2, u3);
        for (var b2 = 1;b2 < u3; b2 <<= 1)
          for (var l2 = b2 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w = 0;w < u3; w += l2)
            for (var g3 = n, _3 = d2, A2 = 0;A2 < b2; A2++) {
              var R2 = h3[w + A2], I3 = s2[w + A2], Me = h3[w + A2 + b2], k3 = s2[w + A2 + b2], D2 = g3 * Me - _3 * k3;
              k3 = g3 * k3 + _3 * Me, Me = D2, h3[w + A2] = R2 + Me, s2[w + A2] = I3 + k3, h3[w + A2 + b2] = R2 - Me, s2[w + A2 + b2] = I3 - k3, A2 !== l2 && (D2 = n * g3 - d2 * _3, _3 = n * _3 + d2 * g3, g3 = D2);
            }
      }, N3.prototype.guessLen13b = function(i, a2) {
        var h3 = Math.max(a2, i) | 1, s2 = h3 & 1, u3 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u3++;
        return 1 << u3 + 1 + s2;
      }, N3.prototype.conjugate = function(i, a2, h3) {
        if (!(h3 <= 1))
          for (var s2 = 0;s2 < h3 / 2; s2++) {
            var u3 = i[s2];
            i[s2] = i[h3 - s2 - 1], i[h3 - s2 - 1] = u3, u3 = a2[s2], a2[s2] = -a2[h3 - s2 - 1], a2[h3 - s2 - 1] = -u3;
          }
      }, N3.prototype.normalize13b = function(i, a2) {
        for (var h3 = 0, s2 = 0;s2 < a2 / 2; s2++) {
          var u3 = Math.round(i[2 * s2 + 1] / a2) * 8192 + Math.round(i[2 * s2] / a2) + h3;
          i[s2] = u3 & 67108863, u3 < 67108864 ? h3 = 0 : h3 = u3 / 67108864 | 0;
        }
        return i;
      }, N3.prototype.convert13b = function(i, a2, h3, s2) {
        for (var u3 = 0, c2 = 0;c2 < a2; c2++)
          u3 = u3 + (i[c2] | 0), h3[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h3[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a2;c2 < s2; ++c2)
          h3[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N3.prototype.stub = function(i) {
        for (var a2 = new Array(i), h3 = 0;h3 < i; h3++)
          a2[h3] = 0;
        return a2;
      }, N3.prototype.mulp = function(i, a2, h3) {
        var s2 = 2 * this.guessLen13b(i.length, a2.length), u3 = this.makeRBT(s2), c2 = this.stub(s2), b2 = new Array(s2), l2 = new Array(s2), n = new Array(s2), d2 = new Array(s2), w = new Array(s2), g3 = new Array(s2), _3 = h3.words;
        _3.length = s2, this.convert13b(i.words, i.length, b2, s2), this.convert13b(a2.words, a2.length, d2, s2), this.transform(b2, c2, l2, n, s2, u3), this.transform(d2, c2, w, g3, s2, u3);
        for (var A2 = 0;A2 < s2; A2++) {
          var R2 = l2[A2] * w[A2] - n[A2] * g3[A2];
          n[A2] = l2[A2] * g3[A2] + n[A2] * w[A2], l2[A2] = R2;
        }
        return this.conjugate(l2, n, s2), this.transform(l2, n, _3, c2, s2, u3), this.conjugate(_3, c2, s2), this.normalize13b(_3, s2), h3.negative = i.negative ^ a2.negative, h3.length = i.length + a2.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
      }, f2.prototype.mulf = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), _e(this, i, a2);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a2 = 0, h3 = 0;h3 < this.length; h3++) {
          var s2 = (this.words[h3] | 0) * i, u3 = (s2 & 67108863) + (a2 & 67108863);
          a2 >>= 26, a2 += s2 / 67108864 | 0, a2 += u3 >>> 26, this.words[h3] = u3 & 67108863;
        }
        return a2 !== 0 && (this.words[h3] = a2, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a2 = B3(i);
        if (a2.length === 0)
          return new f2(1);
        for (var h3 = this, s2 = 0;s2 < a2.length && a2[s2] === 0; s2++, h3 = h3.sqr())
          ;
        if (++s2 < a2.length)
          for (var u3 = h3.sqr();s2 < a2.length; s2++, u3 = u3.sqr())
            a2[s2] !== 0 && (h3 = h3.mul(u3));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s2 = 67108863 >>> 26 - a2 << 26 - a2, u3;
        if (a2 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b2 = this.words[u3] & s2, l2 = (this.words[u3] | 0) - b2 << a2;
            this.words[u3] = l2 | c2, c2 = b2 >>> 26 - a2;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h3] = this.words[u3];
          for (u3 = 0;u3 < h3; u3++)
            this.words[u3] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a2, h3) {
        r(typeof i == "number" && i >= 0);
        var s2;
        a2 ? s2 = (a2 - a2 % 26) / 26 : s2 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u3 << u3, l2 = h3;
        if (s2 -= c2, s2 = Math.max(0, s2), l2) {
          for (var n = 0;n < c2; n++)
            l2.words[n] = this.words[n];
          l2.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d2 = 0;
        for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s2); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d2 << 26 - u3 | w >>> u3, d2 = w & b2;
        }
        return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a2, h3) {
        return r(this.negative === 0), this.iushrn(i, a2, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s2 = 1 << a2;
        if (this.length <= h3)
          return false;
        var u3 = this.words[h3];
        return !!(u3 & s2);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a2 !== 0 && h3++, this.length = Math.min(h3, this.length), a2 !== 0) {
          var s2 = 67108863 ^ 67108863 >>> a2 << a2;
          this.words[this.length - 1] &= s2;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
          this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
        return this.length = Math.max(this.length, a2 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
            this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a2, h3) {
        var s2 = i.length + h3, u3;
        this._expand(s2);
        var c2, b2 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h3] | 0) + b2;
          var l2 = (i.words[u3] | 0) * a2;
          c2 -= l2 & 67108863, b2 = (c2 >> 26) - (l2 / 67108864 | 0), this.words[u3 + h3] = c2 & 67108863;
        }
        for (;u3 < this.length - h3; u3++)
          c2 = (this.words[u3 + h3] | 0) + b2, b2 = c2 >> 26, this.words[u3 + h3] = c2 & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b2, b2 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a2) {
        var h3 = this.length - i.length, s2 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b2 = this._countBits(c2);
        h3 = 26 - b2, h3 !== 0 && (u3 = u3.ushln(h3), s2.iushln(h3), c2 = u3.words[u3.length - 1] | 0);
        var l2 = s2.length - u3.length, n;
        if (a2 !== "mod") {
          n = new f2(null), n.length = l2 + 1, n.words = new Array(n.length);
          for (var d2 = 0;d2 < n.length; d2++)
            n.words[d2] = 0;
        }
        var w = s2.clone()._ishlnsubmul(u3, 1, l2);
        w.negative === 0 && (s2 = w, n && (n.words[l2] = 1));
        for (var g3 = l2 - 1;g3 >= 0; g3--) {
          var _3 = (s2.words[u3.length + g3] | 0) * 67108864 + (s2.words[u3.length + g3 - 1] | 0);
          for (_3 = Math.min(_3 / c2 | 0, 67108863), s2._ishlnsubmul(u3, _3, g3);s2.negative !== 0; )
            _3--, s2.negative = 0, s2._ishlnsubmul(u3, 1, g3), s2.isZero() || (s2.negative ^= 1);
          n && (n.words[g3] = _3);
        }
        return n && n.strip(), s2.strip(), a2 !== "div" && h3 !== 0 && s2.iushrn(h3), { div: n || null, mod: s2 };
      }, f2.prototype.divmod = function(i, a2, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s2, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a2), a2 !== "mod" && (s2 = c2.div.neg()), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.iadd(i)), { div: s2, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a2), a2 !== "mod" && (s2 = c2.div.neg()), { div: s2, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a2);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a2 = this.divmod(i);
        if (a2.mod.isZero())
          return a2.div;
        var h3 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s2 = i.ushrn(1), u3 = i.andln(1), c2 = h3.cmp(s2);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a2 = (1 << 26) % i, h3 = 0, s2 = this.length - 1;s2 >= 0; s2--)
          h3 = (a2 * h3 + (this.words[s2] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s2 = (this.words[h3] | 0) + a2 * 67108864;
          this.words[h3] = s2 / i | 0, a2 = s2 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s2 = new f2(1), u3 = new f2(0), c2 = new f2(0), b2 = new f2(1), l2 = 0;a2.isEven() && h3.isEven(); )
          a2.iushrn(1), h3.iushrn(1), ++l2;
        for (var n = h3.clone(), d2 = a2.clone();!a2.isZero(); ) {
          for (var w = 0, g3 = 1;(a2.words[0] & g3) === 0 && w < 26; ++w, g3 <<= 1)
            ;
          if (w > 0)
            for (a2.iushrn(w);w-- > 0; )
              (s2.isOdd() || u3.isOdd()) && (s2.iadd(n), u3.isub(d2)), s2.iushrn(1), u3.iushrn(1);
          for (var _3 = 0, A2 = 1;(h3.words[0] & A2) === 0 && _3 < 26; ++_3, A2 <<= 1)
            ;
          if (_3 > 0)
            for (h3.iushrn(_3);_3-- > 0; )
              (c2.isOdd() || b2.isOdd()) && (c2.iadd(n), b2.isub(d2)), c2.iushrn(1), b2.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s2.isub(c2), u3.isub(b2)) : (h3.isub(a2), c2.isub(s2), b2.isub(u3));
        }
        return { a: c2, b: b2, gcd: h3.iushln(l2) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s2 = new f2(1), u3 = new f2(0), c2 = h3.clone();a2.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b2 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b2 < 26; ++b2, l2 <<= 1)
            ;
          if (b2 > 0)
            for (a2.iushrn(b2);b2-- > 0; )
              s2.isOdd() && s2.iadd(c2), s2.iushrn(1);
          for (var n = 0, d2 = 1;(h3.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s2.isub(u3)) : (h3.isub(a2), u3.isub(s2));
        }
        var w;
        return a2.cmpn(1) === 0 ? w = s2 : w = u3, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a2 = this.clone(), h3 = i.clone();
        a2.negative = 0, h3.negative = 0;
        for (var s2 = 0;a2.isEven() && h3.isEven(); s2++)
          a2.iushrn(1), h3.iushrn(1);
        do {
          for (;a2.isEven(); )
            a2.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u3 = a2.cmp(h3);
          if (u3 < 0) {
            var c2 = a2;
            a2 = h3, h3 = c2;
          } else if (u3 === 0 || h3.cmpn(1) === 0)
            break;
          a2.isub(h3);
        } while (true);
        return h3.iushln(s2);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a2 = i % 26, h3 = (i - a2) / 26, s2 = 1 << a2;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s2, this;
        for (var u3 = s2, c2 = h3;u3 !== 0 && c2 < this.length; c2++) {
          var b2 = this.words[c2] | 0;
          b2 += u3, u3 = b2 >>> 26, b2 &= 67108863, this.words[c2] = b2;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a2 = i < 0;
        if (this.negative !== 0 && !a2)
          return -1;
        if (this.negative === 0 && a2)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a2 && (i = -i), r(i <= 67108863, "Number is too big");
          var s2 = this.words[0] | 0;
          h3 = s2 === i ? 0 : s2 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a2 = this.ucmp(i);
        return this.negative !== 0 ? -a2 | 0 : a2;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s2 = this.words[h3] | 0, u3 = i.words[h3] | 0;
          if (s2 !== u3) {
            s2 < u3 ? a2 = -1 : s2 > u3 && (a2 = 1);
            break;
          }
        }
        return a2;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a2 = i, h3;
        do
          this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h3 = a2.bitLength();
        while (h3 > this.n);
        var s2 = h3 < this.n ? -1 : a2.ucmp(this.p);
        return s2 === 0 ? (a2.words[0] = 0, a2.length = 1) : s2 > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
      }, ye.prototype.split = function(i, a2) {
        i.iushrn(this.n, 0, a2);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a2) {
        for (var h3 = 4194303, s2 = Math.min(i.length, 9), u3 = 0;u3 < s2; u3++)
          a2.words[u3] = i.words[u3];
        if (a2.length = s2, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a2.words[a2.length++] = c2 & h3, u3 = 10;u3 < i.length; u3++) {
          var b2 = i.words[u3] | 0;
          i.words[u3 - 10] = (b2 & h3) << 4 | c2 >>> 22, c2 = b2;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s2 = i.words[h3] | 0;
          a2 += s2 * 977, i.words[h3] = a2 & 67108863, a2 = s2 * 64 + (a2 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s2 = (i.words[h3] | 0) * 19 + a2, u3 = s2 & 67108863;
          s2 >>>= 26, i.words[h3] = u3, a2 = s2;
        }
        return a2 !== 0 && (i.words[i.length++] = a2), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a2;
        if (i === "k256")
          a2 = new xe;
        else if (i === "p224")
          a2 = new Re;
        else if (i === "p192")
          a2 = new Ee;
        else if (i === "p25519")
          a2 = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a2, a2;
      };
      function P2(v) {
        if (typeof v == "string") {
          var i = f2._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a2) {
        r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.add(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.iadd(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.sub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.isub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a2) {
        return this._verify1(i), this.imod(i.ushln(a2));
      }, P2.prototype.imul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.imul(a2));
      }, P2.prototype.mul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.mul(a2));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a2 = this.m.andln(3);
        if (r(a2 % 2 === 1), a2 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s2 = this.m.subn(1), u3 = 0;!s2.isZero() && s2.andln(1) === 0; )
          u3++, s2.iushrn(1);
        r(!s2.isZero());
        var c2 = new f2(1).toRed(this), b2 = c2.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l2).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d2 = this.pow(n, s2), w = this.pow(i, s2.addn(1).iushrn(1)), g3 = this.pow(i, s2), _3 = u3;g3.cmp(c2) !== 0; ) {
          for (var A2 = g3, R2 = 0;A2.cmp(c2) !== 0; R2++)
            A2 = A2.redSqr();
          r(R2 < _3);
          var I3 = this.pow(d2, new f2(1).iushln(_3 - R2 - 1));
          w = w.redMul(I3), d2 = I3.redSqr(), g3 = g3.redMul(d2), _3 = R2;
        }
        return w;
      }, P2.prototype.invm = function(i) {
        var a2 = i._invmp(this.m);
        return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
      }, P2.prototype.pow = function(i, a2) {
        if (a2.isZero())
          return new f2(1).toRed(this);
        if (a2.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s2 = new Array(1 << h3);
        s2[0] = new f2(1).toRed(this), s2[1] = i;
        for (var u3 = 2;u3 < s2.length; u3++)
          s2[u3] = this.mul(s2[u3 - 1], i);
        var c2 = s2[0], b2 = 0, l2 = 0, n = a2.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a2.length - 1;u3 >= 0; u3--) {
          for (var d2 = a2.words[u3], w = n - 1;w >= 0; w--) {
            var g3 = d2 >> w & 1;
            if (c2 !== s2[0] && (c2 = this.sqr(c2)), g3 === 0 && b2 === 0) {
              l2 = 0;
              continue;
            }
            b2 <<= 1, b2 |= g3, l2++, !(l2 !== h3 && (u3 !== 0 || w !== 0)) && (c2 = this.mul(c2, s2[b2]), l2 = 0, b2 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a2 = i.umod(this.m);
        return a2 === i ? a2.clone() : a2;
      }, P2.prototype.convertFrom = function(i) {
        var a2 = i.clone();
        return a2.red = null, a2;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P2.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a2 = this.imod(i.mul(this.rinv));
        return a2.red = null, a2;
      }, Se.prototype.imul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a2), s2 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s2).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.mul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a2), s2 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s2).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a2 = this.imod(i._invmp(this.m).mul(this.r2));
        return a2._forceRed(this);
      };
    })(typeof Gu > "u" || Gu, $m);
  });
  Ym = T2((Gm, Xu) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a2 = function() {
        };
        a2.prototype = i.prototype, v.prototype = new a2, v.prototype.constructor = v;
      }
      function f2(v, i, a2) {
        if (f2.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v || 0, i || 10, a2 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a2) {
        return i.cmp(a2) > 0 ? i : a2;
      }, f2.min = function(i, a2) {
        return i.cmp(a2) < 0 ? i : a2;
      }, f2.prototype._init = function(i, a2, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a2, h3);
        if (typeof i == "object")
          return this._initArray(i, a2, h3);
        a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
        var s2 = 0;
        i[0] === "-" && (s2++, this.negative = 1), s2 < i.length && (a2 === 16 ? this._parseHex(i, s2, h3) : (this._parseBase(i, a2, s2), h3 === "le" && this._initArray(this.toArray(), a2, h3)));
      }, f2.prototype._initNumber = function(i, a2, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a2, h3);
      }, f2.prototype._initArray = function(i, a2, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u3, c2, b2 = 0;
        if (h3 === "be")
          for (s2 = i.length - 1, u3 = 0;s2 >= 0; s2 -= 3)
            c2 = i[s2] | i[s2 - 1] << 8 | i[s2 - 2] << 16, this.words[u3] |= c2 << b2 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u3++);
        else if (h3 === "le")
          for (s2 = 0, u3 = 0;s2 < i.length; s2 += 3)
            c2 = i[s2] | i[s2 + 1] << 8 | i[s2 + 2] << 16, this.words[u3] |= c2 << b2 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u3++);
        return this.strip();
      };
      function m2(v, i) {
        var a2 = v.charCodeAt(i);
        return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
      }
      function y3(v, i, a2) {
        var h3 = m2(v, a2);
        return a2 - 1 >= i && (h3 |= m2(v, a2 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a2, h3) {
        this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u3 = 0, c2 = 0, b2;
        if (h3 === "be")
          for (s2 = i.length - 1;s2 >= a2; s2 -= 2)
            b2 = y3(i, a2, s2) << u3, this.words[c2] |= b2 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b2 >>> 26) : u3 += 8;
        else {
          var l2 = i.length - a2;
          for (s2 = l2 % 2 === 0 ? a2 + 1 : a2;s2 < i.length; s2 += 2)
            b2 = y3(i, a2, s2) << u3, this.words[c2] |= b2 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b2 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M2(v, i, a2, h3) {
        for (var s2 = 0, u3 = Math.min(v.length, a2), c2 = i;c2 < u3; c2++) {
          var b2 = v.charCodeAt(c2) - 48;
          s2 *= h3, b2 >= 49 ? s2 += b2 - 49 + 10 : b2 >= 17 ? s2 += b2 - 17 + 10 : s2 += b2;
        }
        return s2;
      }
      f2.prototype._parseBase = function(i, a2, h3) {
        this.words = [0], this.length = 1;
        for (var s2 = 0, u3 = 1;u3 <= 67108863; u3 *= a2)
          s2++;
        s2--, u3 = u3 / a2 | 0;
        for (var c2 = i.length - h3, b2 = c2 % s2, l2 = Math.min(c2, c2 - b2) + h3, n = 0, d2 = h3;d2 < l2; d2 += s2)
          n = M2(i, d2, d2 + s2, a2), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b2; d2++)
            w *= a2;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a2 = 0;a2 < this.length; a2++)
          i.words[a2] = this.words[a2];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a2) {
        i = i || 10, a2 = a2 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s2 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b2 = this.words[c2], l2 = ((b2 << s2 | u3) & 16777215).toString(16);
            u3 = b2 >>> 24 - s2 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l2.length] + l2 + h3 : h3 = l2 + h3, s2 += 2, s2 >= 26 && (s2 -= 26, c2--);
          }
          for (u3 !== 0 && (h3 = u3.toString(16) + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d2 = E3[i];
          h3 = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g3 = w.modn(d2).toString(i);
            w = w.idivn(d2), w.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a2) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
      }, f2.prototype.toArray = function(i, a2) {
        return this.toArrayLike(Array, i, a2);
      }, f2.prototype.toArrayLike = function(i, a2, h3) {
        var s2 = this.byteLength(), u3 = h3 || Math.max(1, s2);
        r(s2 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a2 === "le", b2 = new i(u3), l2, n, d2 = this.clone();
        if (c2) {
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b2[n] = l2;
          for (;n < u3; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u3 - s2; n++)
            b2[n] = 0;
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b2[u3 - n - 1] = l2;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a2 = i, h3 = 0;
        return a2 >= 4096 && (h3 += 13, a2 >>>= 13), a2 >= 64 && (h3 += 7, a2 >>>= 7), a2 >= 8 && (h3 += 4, a2 >>>= 4), a2 >= 2 && (h3 += 2, a2 >>>= 2), h3 + a2;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a2 = i, h3 = 0;
        return (a2 & 8191) === 0 && (h3 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h3 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h3 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h3 += 2, a2 >>>= 2), (a2 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a2 = this._countBits(i);
        return (this.length - 1) * 26 + a2;
      };
      function B3(v) {
        for (var i = new Array(v.bitLength()), a2 = 0;a2 < i.length; a2++) {
          var h3 = a2 / 26 | 0, s2 = a2 % 26;
          i[a2] = (v.words[h3] & 1 << s2) >>> s2;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a2 = 0;a2 < this.length; a2++) {
          var h3 = this._zeroBits(this.words[a2]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a2 = 0;a2 < i.length; a2++)
          this.words[a2] = this.words[a2] | i.words[a2];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a2;
        this.length > i.length ? a2 = i : a2 = this;
        for (var h3 = 0;h3 < a2.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a2, h3;
        this.length > i.length ? (a2 = this, h3 = i) : (a2 = i, h3 = this);
        for (var s2 = 0;s2 < h3.length; s2++)
          this.words[s2] = a2.words[s2] ^ h3.words[s2];
        if (this !== a2)
          for (;s2 < a2.length; s2++)
            this.words[s2] = a2.words[s2];
        return this.length = a2.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a2), h3 > 0 && a2--;
        for (var s2 = 0;s2 < a2; s2++)
          this.words[s2] = ~this.words[s2] & 67108863;
        return h3 > 0 && (this.words[s2] = ~this.words[s2] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a2) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s2 = i % 26;
        return this._expand(h3 + 1), a2 ? this.words[h3] = this.words[h3] | 1 << s2 : this.words[h3] = this.words[h3] & ~(1 << s2), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a2;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
        var h3, s2;
        this.length > i.length ? (h3 = this, s2 = i) : (h3 = i, s2 = this);
        for (var u3 = 0, c2 = 0;c2 < s2.length; c2++)
          a2 = (h3.words[c2] | 0) + (s2.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        for (;u3 !== 0 && c2 < h3.length; c2++)
          a2 = (h3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        if (this.length = h3.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a2;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a2 = this.iadd(i);
          return i.negative = 1, a2._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s2, u3;
        h3 > 0 ? (s2 = this, u3 = i) : (s2 = i, u3 = this);
        for (var c2 = 0, b2 = 0;b2 < u3.length; b2++)
          a2 = (s2.words[b2] | 0) - (u3.words[b2] | 0) + c2, c2 = a2 >> 26, this.words[b2] = a2 & 67108863;
        for (;c2 !== 0 && b2 < s2.length; b2++)
          a2 = (s2.words[b2] | 0) + c2, c2 = a2 >> 26, this.words[b2] = a2 & 67108863;
        if (c2 === 0 && b2 < s2.length && s2 !== this)
          for (;b2 < s2.length; b2++)
            this.words[b2] = s2.words[b2];
        return this.length = Math.max(this.length, b2), s2 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q2(v, i, a2) {
        a2.negative = i.negative ^ v.negative;
        var h3 = v.length + i.length | 0;
        a2.length = h3, h3 = h3 - 1 | 0;
        var s2 = v.words[0] | 0, u3 = i.words[0] | 0, c2 = s2 * u3, b2 = c2 & 67108863, l2 = c2 / 67108864 | 0;
        a2.words[0] = b2;
        for (var n = 1;n < h3; n++) {
          for (var d2 = l2 >>> 26, w = l2 & 67108863, g3 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v.length + 1);_3 <= g3; _3++) {
            var A2 = n - _3 | 0;
            s2 = v.words[A2] | 0, u3 = i.words[_3] | 0, c2 = s2 * u3 + w, d2 += c2 / 67108864 | 0, w = c2 & 67108863;
          }
          a2.words[n] = w | 0, l2 = d2 | 0;
        }
        return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
      }
      var L3 = function(i, a2, h3) {
        var s2 = i.words, u3 = a2.words, c2 = h3.words, b2 = 0, l2, n, d2, w = s2[0] | 0, g3 = w & 8191, _3 = w >>> 13, A2 = s2[1] | 0, R2 = A2 & 8191, I3 = A2 >>> 13, Me = s2[2] | 0, k3 = Me & 8191, D2 = Me >>> 13, nt = s2[3] | 0, C = nt & 8191, O3 = nt >>> 13, vt = s2[4] | 0, F = vt & 8191, U3 = vt >>> 13, bt = s2[5] | 0, z = bt & 8191, H2 = bt >>> 13, mt = s2[6] | 0, W = mt & 8191, K2 = mt >>> 13, gt = s2[7] | 0, j3 = gt & 8191, Z2 = gt >>> 13, yt = s2[8] | 0, V3 = yt & 8191, $2 = yt >>> 13, wt = s2[9] | 0, G2 = wt & 8191, Y2 = wt >>> 13, Mt = u3[0] | 0, X3 = Mt & 8191, J2 = Mt >>> 13, _t = u3[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u3[2] | 0, te = xt & 8191, re = xt >>> 13, St = u3[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u3[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u3[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u3[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u3[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u3[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u3[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a2.negative, h3.length = 19, l2 = Math.imul(g3, X3), n = Math.imul(g3, J2), n = n + Math.imul(_3, X3) | 0, d2 = Math.imul(_3, J2);
        var ft = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l2 = Math.imul(R2, X3), n = Math.imul(R2, J2), n = n + Math.imul(I3, X3) | 0, d2 = Math.imul(I3, J2), l2 = l2 + Math.imul(g3, Q2) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_3, Q2) | 0, d2 = d2 + Math.imul(_3, ee) | 0;
        var Be = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k3, X3), n = Math.imul(k3, J2), n = n + Math.imul(D2, X3) | 0, d2 = Math.imul(D2, J2), l2 = l2 + Math.imul(R2, Q2) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I3, Q2) | 0, d2 = d2 + Math.imul(I3, ee) | 0, l2 = l2 + Math.imul(g3, te) | 0, n = n + Math.imul(g3, re) | 0, n = n + Math.imul(_3, te) | 0, d2 = d2 + Math.imul(_3, re) | 0;
        var qe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l2 = Math.imul(C, X3), n = Math.imul(C, J2), n = n + Math.imul(O3, X3) | 0, d2 = Math.imul(O3, J2), l2 = l2 + Math.imul(k3, Q2) | 0, n = n + Math.imul(k3, ee) | 0, n = n + Math.imul(D2, Q2) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R2, te) | 0, n = n + Math.imul(R2, re) | 0, n = n + Math.imul(I3, te) | 0, d2 = d2 + Math.imul(I3, re) | 0, l2 = l2 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_3, ie) | 0, d2 = d2 + Math.imul(_3, ne) | 0;
        var ze = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F, X3), n = Math.imul(F, J2), n = n + Math.imul(U3, X3) | 0, d2 = Math.imul(U3, J2), l2 = l2 + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O3, Q2) | 0, d2 = d2 + Math.imul(O3, ee) | 0, l2 = l2 + Math.imul(k3, te) | 0, n = n + Math.imul(k3, re) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re) | 0, l2 = l2 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I3, ie) | 0, d2 = d2 + Math.imul(I3, ne) | 0, l2 = l2 + Math.imul(g3, fe) | 0, n = n + Math.imul(g3, ae) | 0, n = n + Math.imul(_3, fe) | 0, d2 = d2 + Math.imul(_3, ae) | 0;
        var He = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X3), n = Math.imul(z, J2), n = n + Math.imul(H2, X3) | 0, d2 = Math.imul(H2, J2), l2 = l2 + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U3, Q2) | 0, d2 = d2 + Math.imul(U3, ee) | 0, l2 = l2 + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O3, te) | 0, d2 = d2 + Math.imul(O3, re) | 0, l2 = l2 + Math.imul(k3, ie) | 0, n = n + Math.imul(k3, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R2, fe) | 0, n = n + Math.imul(R2, ae) | 0, n = n + Math.imul(I3, fe) | 0, d2 = d2 + Math.imul(I3, ae) | 0, l2 = l2 + Math.imul(g3, oe) | 0, n = n + Math.imul(g3, se) | 0, n = n + Math.imul(_3, oe) | 0, d2 = d2 + Math.imul(_3, se) | 0;
        var We = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X3), n = Math.imul(W, J2), n = n + Math.imul(K2, X3) | 0, d2 = Math.imul(K2, J2), l2 = l2 + Math.imul(z, Q2) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q2) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U3, te) | 0, d2 = d2 + Math.imul(U3, re) | 0, l2 = l2 + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O3, ie) | 0, d2 = d2 + Math.imul(O3, ne) | 0, l2 = l2 + Math.imul(k3, fe) | 0, n = n + Math.imul(k3, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R2, oe) | 0, n = n + Math.imul(R2, se) | 0, n = n + Math.imul(I3, oe) | 0, d2 = d2 + Math.imul(I3, se) | 0, l2 = l2 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue) | 0, n = n + Math.imul(_3, he) | 0, d2 = d2 + Math.imul(_3, ue) | 0;
        var Ke = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j3, X3), n = Math.imul(j3, J2), n = n + Math.imul(Z2, X3) | 0, d2 = Math.imul(Z2, J2), l2 = l2 + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q2) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re) | 0, l2 = l2 + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U3, ie) | 0, d2 = d2 + Math.imul(U3, ne) | 0, l2 = l2 + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O3, fe) | 0, d2 = d2 + Math.imul(O3, ae) | 0, l2 = l2 + Math.imul(k3, oe) | 0, n = n + Math.imul(k3, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue) | 0, n = n + Math.imul(I3, he) | 0, d2 = d2 + Math.imul(I3, ue) | 0, l2 = l2 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_3, le) | 0, d2 = d2 + Math.imul(_3, de) | 0;
        var je = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X3), n = Math.imul(V3, J2), n = n + Math.imul($2, X3) | 0, d2 = Math.imul($2, J2), l2 = l2 + Math.imul(j3, Q2) | 0, n = n + Math.imul(j3, ee) | 0, n = n + Math.imul(Z2, Q2) | 0, d2 = d2 + Math.imul(Z2, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U3, fe) | 0, d2 = d2 + Math.imul(U3, ae) | 0, l2 = l2 + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O3, oe) | 0, d2 = d2 + Math.imul(O3, se) | 0, l2 = l2 + Math.imul(k3, he) | 0, n = n + Math.imul(k3, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I3, le) | 0, d2 = d2 + Math.imul(I3, de) | 0, l2 = l2 + Math.imul(g3, ce) | 0, n = n + Math.imul(g3, pe) | 0, n = n + Math.imul(_3, ce) | 0, d2 = d2 + Math.imul(_3, pe) | 0;
        var Ze = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G2, X3), n = Math.imul(G2, J2), n = n + Math.imul(Y2, X3) | 0, d2 = Math.imul(Y2, J2), l2 = l2 + Math.imul(V3, Q2) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q2) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j3, te) | 0, n = n + Math.imul(j3, re) | 0, n = n + Math.imul(Z2, te) | 0, d2 = d2 + Math.imul(Z2, re) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U3, oe) | 0, d2 = d2 + Math.imul(U3, se) | 0, l2 = l2 + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O3, he) | 0, d2 = d2 + Math.imul(O3, ue) | 0, l2 = l2 + Math.imul(k3, le) | 0, n = n + Math.imul(k3, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R2, ce) | 0, n = n + Math.imul(R2, pe) | 0, n = n + Math.imul(I3, ce) | 0, d2 = d2 + Math.imul(I3, pe) | 0, l2 = l2 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_3, ve) | 0, d2 = d2 + Math.imul(_3, be) | 0;
        var Ve = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G2, Q2), n = Math.imul(G2, ee), n = n + Math.imul(Y2, Q2) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re) | 0, l2 = l2 + Math.imul(j3, ie) | 0, n = n + Math.imul(j3, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d2 = d2 + Math.imul(Z2, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U3, he) | 0, d2 = d2 + Math.imul(U3, ue) | 0, l2 = l2 + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O3, le) | 0, d2 = d2 + Math.imul(O3, de) | 0, l2 = l2 + Math.imul(k3, ce) | 0, n = n + Math.imul(k3, pe) | 0, n = n + Math.imul(D2, ce) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I3, ve) | 0, d2 = d2 + Math.imul(I3, be) | 0;
        var $e = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G2, te), n = Math.imul(G2, re), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j3, fe) | 0, n = n + Math.imul(j3, ae) | 0, n = n + Math.imul(Z2, fe) | 0, d2 = d2 + Math.imul(Z2, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U3, le) | 0, d2 = d2 + Math.imul(U3, de) | 0, l2 = l2 + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O3, ce) | 0, d2 = d2 + Math.imul(O3, pe) | 0, l2 = l2 + Math.imul(k3, ve) | 0, n = n + Math.imul(k3, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
        var Ge = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j3, oe) | 0, n = n + Math.imul(j3, se) | 0, n = n + Math.imul(Z2, oe) | 0, d2 = d2 + Math.imul(Z2, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U3, ce) | 0, d2 = d2 + Math.imul(U3, pe) | 0, l2 = l2 + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O3, ve) | 0, d2 = d2 + Math.imul(O3, be) | 0;
        var Ye = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G2, fe), n = Math.imul(G2, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j3, he) | 0, n = n + Math.imul(j3, ue) | 0, n = n + Math.imul(Z2, he) | 0, d2 = d2 + Math.imul(Z2, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U3, ve) | 0, d2 = d2 + Math.imul(U3, be) | 0;
        var Xe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G2, oe), n = Math.imul(G2, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j3, le) | 0, n = n + Math.imul(j3, de) | 0, n = n + Math.imul(Z2, le) | 0, d2 = d2 + Math.imul(Z2, de) | 0, l2 = l2 + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
        var Je = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G2, he), n = Math.imul(G2, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j3, ce) | 0, n = n + Math.imul(j3, pe) | 0, n = n + Math.imul(Z2, ce) | 0, d2 = d2 + Math.imul(Z2, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
        var Qe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j3, ve) | 0, n = n + Math.imul(j3, be) | 0, n = n + Math.imul(Z2, ve) | 0, d2 = d2 + Math.imul(Z2, be) | 0;
        var et = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G2, ce), n = Math.imul(G2, pe), n = n + Math.imul(Y2, ce) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
        var tt = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l2 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
        var rt = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d2 + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe, c2[3] = ze, c2[4] = He, c2[5] = We, c2[6] = Ke, c2[7] = je, c2[8] = Ze, c2[9] = Ve, c2[10] = $e, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe, c2[16] = et, c2[17] = tt, c2[18] = rt, b2 !== 0 && (c2[19] = b2, h3.length++), h3;
      };
      Math.imul || (L3 = q2);
      function ge(v, i, a2) {
        a2.negative = i.negative ^ v.negative, a2.length = v.length + i.length;
        for (var h3 = 0, s2 = 0, u3 = 0;u3 < a2.length - 1; u3++) {
          var c2 = s2;
          s2 = 0;
          for (var b2 = h3 & 67108863, l2 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v.length + 1);n <= l2; n++) {
            var d2 = u3 - n, w = v.words[d2] | 0, g3 = i.words[n] | 0, _3 = w * g3, A2 = _3 & 67108863;
            c2 = c2 + (_3 / 67108864 | 0) | 0, A2 = A2 + b2 | 0, b2 = A2 & 67108863, c2 = c2 + (A2 >>> 26) | 0, s2 += c2 >>> 26, c2 &= 67108863;
          }
          a2.words[u3] = b2, h3 = c2, c2 = s2;
        }
        return h3 !== 0 ? a2.words[u3] = h3 : a2.length--, a2.strip();
      }
      function _e(v, i, a2) {
        var h3 = new N3;
        return h3.mulp(v, i, a2);
      }
      f2.prototype.mulTo = function(i, a2) {
        var h3, s2 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a2) : s2 < 63 ? h3 = q2(this, i, a2) : s2 < 1024 ? h3 = ge(this, i, a2) : h3 = _e(this, i, a2), h3;
      };
      function N3(v, i) {
        this.x = v, this.y = i;
      }
      N3.prototype.makeRBT = function(i) {
        for (var a2 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s2 = 0;s2 < i; s2++)
          a2[s2] = this.revBin(s2, h3, i);
        return a2;
      }, N3.prototype.revBin = function(i, a2, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s2 = 0, u3 = 0;u3 < a2; u3++)
          s2 |= (i & 1) << a2 - u3 - 1, i >>= 1;
        return s2;
      }, N3.prototype.permute = function(i, a2, h3, s2, u3, c2) {
        for (var b2 = 0;b2 < c2; b2++)
          s2[b2] = a2[i[b2]], u3[b2] = h3[i[b2]];
      }, N3.prototype.transform = function(i, a2, h3, s2, u3, c2) {
        this.permute(c2, i, a2, h3, s2, u3);
        for (var b2 = 1;b2 < u3; b2 <<= 1)
          for (var l2 = b2 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w = 0;w < u3; w += l2)
            for (var g3 = n, _3 = d2, A2 = 0;A2 < b2; A2++) {
              var R2 = h3[w + A2], I3 = s2[w + A2], Me = h3[w + A2 + b2], k3 = s2[w + A2 + b2], D2 = g3 * Me - _3 * k3;
              k3 = g3 * k3 + _3 * Me, Me = D2, h3[w + A2] = R2 + Me, s2[w + A2] = I3 + k3, h3[w + A2 + b2] = R2 - Me, s2[w + A2 + b2] = I3 - k3, A2 !== l2 && (D2 = n * g3 - d2 * _3, _3 = n * _3 + d2 * g3, g3 = D2);
            }
      }, N3.prototype.guessLen13b = function(i, a2) {
        var h3 = Math.max(a2, i) | 1, s2 = h3 & 1, u3 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u3++;
        return 1 << u3 + 1 + s2;
      }, N3.prototype.conjugate = function(i, a2, h3) {
        if (!(h3 <= 1))
          for (var s2 = 0;s2 < h3 / 2; s2++) {
            var u3 = i[s2];
            i[s2] = i[h3 - s2 - 1], i[h3 - s2 - 1] = u3, u3 = a2[s2], a2[s2] = -a2[h3 - s2 - 1], a2[h3 - s2 - 1] = -u3;
          }
      }, N3.prototype.normalize13b = function(i, a2) {
        for (var h3 = 0, s2 = 0;s2 < a2 / 2; s2++) {
          var u3 = Math.round(i[2 * s2 + 1] / a2) * 8192 + Math.round(i[2 * s2] / a2) + h3;
          i[s2] = u3 & 67108863, u3 < 67108864 ? h3 = 0 : h3 = u3 / 67108864 | 0;
        }
        return i;
      }, N3.prototype.convert13b = function(i, a2, h3, s2) {
        for (var u3 = 0, c2 = 0;c2 < a2; c2++)
          u3 = u3 + (i[c2] | 0), h3[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h3[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a2;c2 < s2; ++c2)
          h3[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N3.prototype.stub = function(i) {
        for (var a2 = new Array(i), h3 = 0;h3 < i; h3++)
          a2[h3] = 0;
        return a2;
      }, N3.prototype.mulp = function(i, a2, h3) {
        var s2 = 2 * this.guessLen13b(i.length, a2.length), u3 = this.makeRBT(s2), c2 = this.stub(s2), b2 = new Array(s2), l2 = new Array(s2), n = new Array(s2), d2 = new Array(s2), w = new Array(s2), g3 = new Array(s2), _3 = h3.words;
        _3.length = s2, this.convert13b(i.words, i.length, b2, s2), this.convert13b(a2.words, a2.length, d2, s2), this.transform(b2, c2, l2, n, s2, u3), this.transform(d2, c2, w, g3, s2, u3);
        for (var A2 = 0;A2 < s2; A2++) {
          var R2 = l2[A2] * w[A2] - n[A2] * g3[A2];
          n[A2] = l2[A2] * g3[A2] + n[A2] * w[A2], l2[A2] = R2;
        }
        return this.conjugate(l2, n, s2), this.transform(l2, n, _3, c2, s2, u3), this.conjugate(_3, c2, s2), this.normalize13b(_3, s2), h3.negative = i.negative ^ a2.negative, h3.length = i.length + a2.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
      }, f2.prototype.mulf = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), _e(this, i, a2);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a2 = 0, h3 = 0;h3 < this.length; h3++) {
          var s2 = (this.words[h3] | 0) * i, u3 = (s2 & 67108863) + (a2 & 67108863);
          a2 >>= 26, a2 += s2 / 67108864 | 0, a2 += u3 >>> 26, this.words[h3] = u3 & 67108863;
        }
        return a2 !== 0 && (this.words[h3] = a2, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a2 = B3(i);
        if (a2.length === 0)
          return new f2(1);
        for (var h3 = this, s2 = 0;s2 < a2.length && a2[s2] === 0; s2++, h3 = h3.sqr())
          ;
        if (++s2 < a2.length)
          for (var u3 = h3.sqr();s2 < a2.length; s2++, u3 = u3.sqr())
            a2[s2] !== 0 && (h3 = h3.mul(u3));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s2 = 67108863 >>> 26 - a2 << 26 - a2, u3;
        if (a2 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b2 = this.words[u3] & s2, l2 = (this.words[u3] | 0) - b2 << a2;
            this.words[u3] = l2 | c2, c2 = b2 >>> 26 - a2;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h3] = this.words[u3];
          for (u3 = 0;u3 < h3; u3++)
            this.words[u3] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a2, h3) {
        r(typeof i == "number" && i >= 0);
        var s2;
        a2 ? s2 = (a2 - a2 % 26) / 26 : s2 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u3 << u3, l2 = h3;
        if (s2 -= c2, s2 = Math.max(0, s2), l2) {
          for (var n = 0;n < c2; n++)
            l2.words[n] = this.words[n];
          l2.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d2 = 0;
        for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s2); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d2 << 26 - u3 | w >>> u3, d2 = w & b2;
        }
        return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a2, h3) {
        return r(this.negative === 0), this.iushrn(i, a2, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s2 = 1 << a2;
        if (this.length <= h3)
          return false;
        var u3 = this.words[h3];
        return !!(u3 & s2);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a2 !== 0 && h3++, this.length = Math.min(h3, this.length), a2 !== 0) {
          var s2 = 67108863 ^ 67108863 >>> a2 << a2;
          this.words[this.length - 1] &= s2;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
          this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
        return this.length = Math.max(this.length, a2 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
            this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a2, h3) {
        var s2 = i.length + h3, u3;
        this._expand(s2);
        var c2, b2 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h3] | 0) + b2;
          var l2 = (i.words[u3] | 0) * a2;
          c2 -= l2 & 67108863, b2 = (c2 >> 26) - (l2 / 67108864 | 0), this.words[u3 + h3] = c2 & 67108863;
        }
        for (;u3 < this.length - h3; u3++)
          c2 = (this.words[u3 + h3] | 0) + b2, b2 = c2 >> 26, this.words[u3 + h3] = c2 & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b2, b2 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a2) {
        var h3 = this.length - i.length, s2 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b2 = this._countBits(c2);
        h3 = 26 - b2, h3 !== 0 && (u3 = u3.ushln(h3), s2.iushln(h3), c2 = u3.words[u3.length - 1] | 0);
        var l2 = s2.length - u3.length, n;
        if (a2 !== "mod") {
          n = new f2(null), n.length = l2 + 1, n.words = new Array(n.length);
          for (var d2 = 0;d2 < n.length; d2++)
            n.words[d2] = 0;
        }
        var w = s2.clone()._ishlnsubmul(u3, 1, l2);
        w.negative === 0 && (s2 = w, n && (n.words[l2] = 1));
        for (var g3 = l2 - 1;g3 >= 0; g3--) {
          var _3 = (s2.words[u3.length + g3] | 0) * 67108864 + (s2.words[u3.length + g3 - 1] | 0);
          for (_3 = Math.min(_3 / c2 | 0, 67108863), s2._ishlnsubmul(u3, _3, g3);s2.negative !== 0; )
            _3--, s2.negative = 0, s2._ishlnsubmul(u3, 1, g3), s2.isZero() || (s2.negative ^= 1);
          n && (n.words[g3] = _3);
        }
        return n && n.strip(), s2.strip(), a2 !== "div" && h3 !== 0 && s2.iushrn(h3), { div: n || null, mod: s2 };
      }, f2.prototype.divmod = function(i, a2, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s2, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a2), a2 !== "mod" && (s2 = c2.div.neg()), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.iadd(i)), { div: s2, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a2), a2 !== "mod" && (s2 = c2.div.neg()), { div: s2, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a2);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a2 = this.divmod(i);
        if (a2.mod.isZero())
          return a2.div;
        var h3 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s2 = i.ushrn(1), u3 = i.andln(1), c2 = h3.cmp(s2);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a2 = (1 << 26) % i, h3 = 0, s2 = this.length - 1;s2 >= 0; s2--)
          h3 = (a2 * h3 + (this.words[s2] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s2 = (this.words[h3] | 0) + a2 * 67108864;
          this.words[h3] = s2 / i | 0, a2 = s2 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s2 = new f2(1), u3 = new f2(0), c2 = new f2(0), b2 = new f2(1), l2 = 0;a2.isEven() && h3.isEven(); )
          a2.iushrn(1), h3.iushrn(1), ++l2;
        for (var n = h3.clone(), d2 = a2.clone();!a2.isZero(); ) {
          for (var w = 0, g3 = 1;(a2.words[0] & g3) === 0 && w < 26; ++w, g3 <<= 1)
            ;
          if (w > 0)
            for (a2.iushrn(w);w-- > 0; )
              (s2.isOdd() || u3.isOdd()) && (s2.iadd(n), u3.isub(d2)), s2.iushrn(1), u3.iushrn(1);
          for (var _3 = 0, A2 = 1;(h3.words[0] & A2) === 0 && _3 < 26; ++_3, A2 <<= 1)
            ;
          if (_3 > 0)
            for (h3.iushrn(_3);_3-- > 0; )
              (c2.isOdd() || b2.isOdd()) && (c2.iadd(n), b2.isub(d2)), c2.iushrn(1), b2.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s2.isub(c2), u3.isub(b2)) : (h3.isub(a2), c2.isub(s2), b2.isub(u3));
        }
        return { a: c2, b: b2, gcd: h3.iushln(l2) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s2 = new f2(1), u3 = new f2(0), c2 = h3.clone();a2.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b2 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b2 < 26; ++b2, l2 <<= 1)
            ;
          if (b2 > 0)
            for (a2.iushrn(b2);b2-- > 0; )
              s2.isOdd() && s2.iadd(c2), s2.iushrn(1);
          for (var n = 0, d2 = 1;(h3.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s2.isub(u3)) : (h3.isub(a2), u3.isub(s2));
        }
        var w;
        return a2.cmpn(1) === 0 ? w = s2 : w = u3, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a2 = this.clone(), h3 = i.clone();
        a2.negative = 0, h3.negative = 0;
        for (var s2 = 0;a2.isEven() && h3.isEven(); s2++)
          a2.iushrn(1), h3.iushrn(1);
        do {
          for (;a2.isEven(); )
            a2.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u3 = a2.cmp(h3);
          if (u3 < 0) {
            var c2 = a2;
            a2 = h3, h3 = c2;
          } else if (u3 === 0 || h3.cmpn(1) === 0)
            break;
          a2.isub(h3);
        } while (true);
        return h3.iushln(s2);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a2 = i % 26, h3 = (i - a2) / 26, s2 = 1 << a2;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s2, this;
        for (var u3 = s2, c2 = h3;u3 !== 0 && c2 < this.length; c2++) {
          var b2 = this.words[c2] | 0;
          b2 += u3, u3 = b2 >>> 26, b2 &= 67108863, this.words[c2] = b2;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a2 = i < 0;
        if (this.negative !== 0 && !a2)
          return -1;
        if (this.negative === 0 && a2)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a2 && (i = -i), r(i <= 67108863, "Number is too big");
          var s2 = this.words[0] | 0;
          h3 = s2 === i ? 0 : s2 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a2 = this.ucmp(i);
        return this.negative !== 0 ? -a2 | 0 : a2;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s2 = this.words[h3] | 0, u3 = i.words[h3] | 0;
          if (s2 !== u3) {
            s2 < u3 ? a2 = -1 : s2 > u3 && (a2 = 1);
            break;
          }
        }
        return a2;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a2 = i, h3;
        do
          this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h3 = a2.bitLength();
        while (h3 > this.n);
        var s2 = h3 < this.n ? -1 : a2.ucmp(this.p);
        return s2 === 0 ? (a2.words[0] = 0, a2.length = 1) : s2 > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
      }, ye.prototype.split = function(i, a2) {
        i.iushrn(this.n, 0, a2);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a2) {
        for (var h3 = 4194303, s2 = Math.min(i.length, 9), u3 = 0;u3 < s2; u3++)
          a2.words[u3] = i.words[u3];
        if (a2.length = s2, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a2.words[a2.length++] = c2 & h3, u3 = 10;u3 < i.length; u3++) {
          var b2 = i.words[u3] | 0;
          i.words[u3 - 10] = (b2 & h3) << 4 | c2 >>> 22, c2 = b2;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s2 = i.words[h3] | 0;
          a2 += s2 * 977, i.words[h3] = a2 & 67108863, a2 = s2 * 64 + (a2 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s2 = (i.words[h3] | 0) * 19 + a2, u3 = s2 & 67108863;
          s2 >>>= 26, i.words[h3] = u3, a2 = s2;
        }
        return a2 !== 0 && (i.words[i.length++] = a2), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a2;
        if (i === "k256")
          a2 = new xe;
        else if (i === "p224")
          a2 = new Re;
        else if (i === "p192")
          a2 = new Ee;
        else if (i === "p25519")
          a2 = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a2, a2;
      };
      function P2(v) {
        if (typeof v == "string") {
          var i = f2._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a2) {
        r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.add(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.iadd(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.sub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.isub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a2) {
        return this._verify1(i), this.imod(i.ushln(a2));
      }, P2.prototype.imul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.imul(a2));
      }, P2.prototype.mul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.mul(a2));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a2 = this.m.andln(3);
        if (r(a2 % 2 === 1), a2 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s2 = this.m.subn(1), u3 = 0;!s2.isZero() && s2.andln(1) === 0; )
          u3++, s2.iushrn(1);
        r(!s2.isZero());
        var c2 = new f2(1).toRed(this), b2 = c2.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l2).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d2 = this.pow(n, s2), w = this.pow(i, s2.addn(1).iushrn(1)), g3 = this.pow(i, s2), _3 = u3;g3.cmp(c2) !== 0; ) {
          for (var A2 = g3, R2 = 0;A2.cmp(c2) !== 0; R2++)
            A2 = A2.redSqr();
          r(R2 < _3);
          var I3 = this.pow(d2, new f2(1).iushln(_3 - R2 - 1));
          w = w.redMul(I3), d2 = I3.redSqr(), g3 = g3.redMul(d2), _3 = R2;
        }
        return w;
      }, P2.prototype.invm = function(i) {
        var a2 = i._invmp(this.m);
        return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
      }, P2.prototype.pow = function(i, a2) {
        if (a2.isZero())
          return new f2(1).toRed(this);
        if (a2.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s2 = new Array(1 << h3);
        s2[0] = new f2(1).toRed(this), s2[1] = i;
        for (var u3 = 2;u3 < s2.length; u3++)
          s2[u3] = this.mul(s2[u3 - 1], i);
        var c2 = s2[0], b2 = 0, l2 = 0, n = a2.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a2.length - 1;u3 >= 0; u3--) {
          for (var d2 = a2.words[u3], w = n - 1;w >= 0; w--) {
            var g3 = d2 >> w & 1;
            if (c2 !== s2[0] && (c2 = this.sqr(c2)), g3 === 0 && b2 === 0) {
              l2 = 0;
              continue;
            }
            b2 <<= 1, b2 |= g3, l2++, !(l2 !== h3 && (u3 !== 0 || w !== 0)) && (c2 = this.mul(c2, s2[b2]), l2 = 0, b2 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a2 = i.umod(this.m);
        return a2 === i ? a2.clone() : a2;
      }, P2.prototype.convertFrom = function(i) {
        var a2 = i.clone();
        return a2.red = null, a2;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P2.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a2 = this.imod(i.mul(this.rinv));
        return a2.red = null, a2;
      }, Se.prototype.imul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a2), s2 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s2).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.mul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a2), s2 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s2).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a2 = this.imod(i._invmp(this.m).mul(this.r2));
        return a2._forceRed(this);
      };
    })(typeof Xu > "u" || Xu, Gm);
  });
  Xm = T2(() => {
  });
  As = T2(($T, el) => {
    var Ju;
    el.exports = function(e) {
      return Ju || (Ju = new Zi(null)), Ju.generate(e);
    };
    function Zi(t) {
      this.rand = t;
    }
    el.exports.Rand = Zi;
    Zi.prototype.generate = function(e) {
      return this._rand(e);
    };
    Zi.prototype._rand = function(e) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e);
      for (var r = new Uint8Array(e), o = 0;o < r.length; o++)
        r[o] = this.rand.getByte();
      return r;
    };
    if (typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.crypto.getRandomValues(r), r;
      } : self.msCrypto && self.msCrypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.msCrypto.getRandomValues(r), r;
      } : typeof window == "object" && (Zi.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        if (Qu = Xm(), typeof Qu.randomBytes != "function")
          throw new Error("Not supported");
        Zi.prototype._rand = function(e) {
          return Qu.randomBytes(e);
        };
      } catch {
      }
    var Qu;
  });
  tl = T2((GT, Jm) => {
    var In = Ym(), Q9 = As();
    function Tn(t) {
      this.rand = t || new Q9.Rand;
    }
    Jm.exports = Tn;
    Tn.create = function(e) {
      return new Tn(e);
    };
    Tn.prototype._randbelow = function(e) {
      var r = e.bitLength(), o = Math.ceil(r / 8);
      do
        var f2 = new In(this.rand.generate(o));
      while (f2.cmp(e) >= 0);
      return f2;
    };
    Tn.prototype._randrange = function(e, r) {
      var o = r.sub(e);
      return e.add(this._randbelow(o));
    };
    Tn.prototype.test = function(e, r, o) {
      var f2 = e.bitLength(), p2 = In.mont(e), m2 = new In(1).toRed(p2);
      r || (r = Math.max(1, f2 / 48 | 0));
      for (var y3 = e.subn(1), M2 = 0;!y3.testn(M2); M2++)
        ;
      for (var x3 = e.shrn(M2), S2 = y3.toRed(p2), E3 = true;r > 0; r--) {
        var B3 = this._randrange(new In(2), y3);
        o && o(B3);
        var q2 = B3.toRed(p2).redPow(x3);
        if (!(q2.cmp(m2) === 0 || q2.cmp(S2) === 0)) {
          for (var L3 = 1;L3 < M2; L3++) {
            if (q2 = q2.redSqr(), q2.cmp(m2) === 0)
              return false;
            if (q2.cmp(S2) === 0)
              break;
          }
          if (L3 === M2)
            return false;
        }
      }
      return E3;
    };
    Tn.prototype.getDivisor = function(e, r) {
      var o = e.bitLength(), f2 = In.mont(e), p2 = new In(1).toRed(f2);
      r || (r = Math.max(1, o / 48 | 0));
      for (var m2 = e.subn(1), y3 = 0;!m2.testn(y3); y3++)
        ;
      for (var M2 = e.shrn(y3), x3 = m2.toRed(f2);r > 0; r--) {
        var S2 = this._randrange(new In(2), m2), E3 = e.gcd(S2);
        if (E3.cmpn(1) !== 0)
          return E3;
        var B3 = S2.toRed(f2).redPow(M2);
        if (!(B3.cmp(p2) === 0 || B3.cmp(x3) === 0)) {
          for (var q2 = 1;q2 < y3; q2++) {
            if (B3 = B3.redSqr(), B3.cmp(p2) === 0)
              return B3.fromRed().subn(1).gcd(e);
            if (B3.cmp(x3) === 0)
              break;
          }
          if (q2 === y3)
            return B3 = B3.redSqr(), B3.fromRed().subn(1).gcd(e);
        }
      }
      return false;
    };
  });
  ol = T2((ek, tg) => {
    var eS = on();
    tg.exports = al;
    al.simpleSieve = nl;
    al.fermatTest = fl;
    var Ht = Yu(), tS = new Ht(24), rS = tl(), Qm = new rS, iS = new Ht(1), il = new Ht(2), nS = new Ht(5), YT = new Ht(16), XT = new Ht(8), fS = new Ht(10), aS = new Ht(3), JT = new Ht(7), oS = new Ht(11), eg = new Ht(4), QT = new Ht(12), rl = null;
    function sS() {
      if (rl !== null)
        return rl;
      var t = 1048576, e = [];
      e[0] = 2;
      for (var r = 1, o = 3;o < t; o += 2) {
        for (var f2 = Math.ceil(Math.sqrt(o)), p2 = 0;p2 < r && e[p2] <= f2 && o % e[p2] !== 0; p2++)
          ;
        r !== p2 && e[p2] <= f2 || (e[r++] = o);
      }
      return rl = e, e;
    }
    function nl(t) {
      for (var e = sS(), r = 0;r < e.length; r++)
        if (t.modn(e[r]) === 0)
          return t.cmpn(e[r]) === 0;
      return true;
    }
    function fl(t) {
      var e = Ht.mont(t);
      return il.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
    }
    function al(t, e) {
      if (t < 16)
        return e === 2 || e === 5 ? new Ht([140, 123]) : new Ht([140, 39]);
      e = new Ht(e);
      for (var r, o;; ) {
        for (r = new Ht(eS(Math.ceil(t / 8)));r.bitLength() > t; )
          r.ishrn(1);
        if (r.isEven() && r.iadd(iS), r.testn(1) || r.iadd(il), e.cmp(il)) {
          if (!e.cmp(nS))
            for (;r.mod(fS).cmp(aS); )
              r.iadd(eg);
        } else
          for (;r.mod(tS).cmp(oS); )
            r.iadd(eg);
        if (o = r.shrn(1), nl(o) && nl(r) && fl(o) && fl(r) && Qm.test(o) && Qm.test(r))
          return r;
      }
    }
  });
  rg = T2((tk, hS) => {
    hS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  });
  ag = T2((rk, fg) => {
    var yr = Yu(), uS = tl(), ig = new uS, lS = new yr(24), dS = new yr(11), cS = new yr(10), pS = new yr(3), vS = new yr(7), ng = ol(), bS = on();
    fg.exports = Si;
    function mS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new yr(t), this;
    }
    function gS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new yr(t), this;
    }
    var Rs = {};
    function yS(t, e) {
      var r = e.toString("hex"), o = [r, t.toString(16)].join("_");
      if (o in Rs)
        return Rs[o];
      var f2 = 0;
      if (t.isEven() || !ng.simpleSieve || !ng.fermatTest(t) || !ig.test(t))
        return f2 += 1, r === "02" || r === "05" ? f2 += 8 : f2 += 4, Rs[o] = f2, f2;
      ig.test(t.shrn(1)) || (f2 += 2);
      var p2;
      switch (r) {
        case "02":
          t.mod(lS).cmp(dS) && (f2 += 8);
          break;
        case "05":
          p2 = t.mod(cS), p2.cmp(pS) && p2.cmp(vS) && (f2 += 8);
          break;
        default:
          f2 += 4;
      }
      return Rs[o] = f2, f2;
    }
    function Si(t, e, r) {
      this.setGenerator(e), this.__prime = new yr(t), this._prime = yr.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = mS, this.setPrivateKey = gS) : this._primeCode = 8;
    }
    Object.defineProperty(Si.prototype, "verifyError", { enumerable: true, get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = yS(this.__prime, this.__gen)), this._primeCode;
    } });
    Si.prototype.generateKeys = function() {
      return this._priv || (this._priv = new yr(bS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    Si.prototype.computeSecret = function(t) {
      t = new yr(t), t = t.toRed(this._prime);
      var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), o = this.getPrime();
      if (r.length < o.length) {
        var f2 = new Buffer(o.length - r.length);
        f2.fill(0), r = Buffer.concat([f2, r]);
      }
      return r;
    };
    Si.prototype.getPublicKey = function(e) {
      return Bs(this._pub, e);
    };
    Si.prototype.getPrivateKey = function(e) {
      return Bs(this._priv, e);
    };
    Si.prototype.getPrime = function(t) {
      return Bs(this.__prime, t);
    };
    Si.prototype.getGenerator = function(t) {
      return Bs(this._gen, t);
    };
    Si.prototype.setGenerator = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new yr(t), this;
    };
    function Bs(t, e) {
      var r = new Buffer(t.toArray());
      return e ? r.toString(e) : r;
    }
  });
  hg = T2((_f) => {
    var wS = ol(), og = rg(), sl = ag();
    function MS(t) {
      var e = new Buffer(og[t].prime, "hex"), r = new Buffer(og[t].gen, "hex");
      return new sl(e, r);
    }
    var _S = { binary: true, hex: true, base64: true };
    function sg(t, e, r, o) {
      return Buffer.isBuffer(e) || _S[e] === undefined ? sg(t, "binary", e, r) : (e = e || "binary", o = o || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o)), typeof t == "number" ? new sl(wS(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new sl(t, r, true)));
    }
    _f.DiffieHellmanGroup = _f.createDiffieHellmanGroup = _f.getDiffieHellman = MS;
    _f.createDiffieHellman = _f.DiffieHellman = sg;
  });
  hl = T2((nk, ug) => {
    ug.exports = ki().EventEmitter;
  });
  pg = T2((fk, cg) => {
    function lg(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f2) {
          return Object.getOwnPropertyDescriptor(t, f2).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function xS(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lg(Object(r), true).forEach(function(o) {
          SS(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lg(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function SS(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function ES(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dg(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function AS(t, e, r) {
      return e && dg(t.prototype, e), r && dg(t, r), t;
    }
    var RS = Ut(), qs = RS.Buffer, BS = $f(), ul = BS.inspect, qS = ul && ul.custom || "inspect";
    function IS(t, e, r) {
      qs.prototype.copy.call(t, e, r);
    }
    cg.exports = function() {
      function t() {
        ES(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return AS(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f2 = "" + o.data;o = o.next; )
          f2 += r + o.data;
        return f2;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return qs.alloc(0);
        for (var o = qs.allocUnsafe(r >>> 0), f2 = this.head, p2 = 0;f2; )
          IS(f2.data, o, p2), p2 += f2.data.length, f2 = f2.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f2;
        return r < this.head.data.length ? (f2 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f2 = this.shift() : f2 = o ? this._getString(r) : this._getBuffer(r), f2;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f2 = 1, p2 = o.data;
        for (r -= p2.length;o = o.next; ) {
          var m2 = o.data, y3 = r > m2.length ? m2.length : r;
          if (y3 === m2.length ? p2 += m2 : p2 += m2.slice(0, r), r -= y3, r === 0) {
            y3 === m2.length ? (++f2, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m2.slice(y3));
            break;
          }
          ++f2;
        }
        return this.length -= f2, p2;
      } }, { key: "_getBuffer", value: function(r) {
        var o = qs.allocUnsafe(r), f2 = this.head, p2 = 1;
        for (f2.data.copy(o), r -= f2.data.length;f2 = f2.next; ) {
          var m2 = f2.data, y3 = r > m2.length ? m2.length : r;
          if (m2.copy(o, o.length - r, 0, y3), r -= y3, r === 0) {
            y3 === m2.length ? (++p2, f2.next ? this.head = f2.next : this.head = this.tail = null) : (this.head = f2, f2.data = m2.slice(y3));
            break;
          }
          ++p2;
        }
        return this.length -= p2, o;
      } }, { key: qS, value: function(r, o) {
        return ul(this, xS({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  dl = T2((ak, bg) => {
    function TS(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f2 = this._writableState && this._writableState.destroyed;
      return o || f2 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(ll, this, t)) : process.nextTick(ll, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p2) {
        !e && p2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = true, process.nextTick(vg, r, p2)) : process.nextTick(vg, r, p2) : e ? (process.nextTick(Is, r), e(p2)) : process.nextTick(Is, r);
      }), this);
    }
    function vg(t, e) {
      ll(t, e), Is(t);
    }
    function Is(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function kS() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function ll(t, e) {
      t.emit("error", e);
    }
    function LS(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bg.exports = { destroy: TS, undestroy: kS, errorOrDestroy: LS };
  });
  kn = T2((ok, yg) => {
    function NS(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gg = {};
    function wr(t, e, r) {
      r || (r = Error);
      function o(p2, m2, y3) {
        return typeof e == "string" ? e : e(p2, m2, y3);
      }
      var f2 = function(p2) {
        NS(m2, p2);
        function m2(y3, M2, x3) {
          return p2.call(this, o(y3, M2, x3)) || this;
        }
        return m2;
      }(r);
      f2.prototype.name = r.name, f2.prototype.code = t, gg[t] = f2;
    }
    function mg(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function DS(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function PS(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function CS(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    wr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    wr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && DS(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f2;
      if (PS(t, " argument"))
        f2 = "The ".concat(t, " ").concat(o, " ").concat(mg(e, "type"));
      else {
        var p2 = CS(t, ".") ? "property" : "argument";
        f2 = 'The "'.concat(t, '" ').concat(p2, " ").concat(o, " ").concat(mg(e, "type"));
      }
      return f2 += ". Received type ".concat(typeof r), f2;
    }, TypeError);
    wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    wr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    wr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    wr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    wr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yg.exports.codes = gg;
  });
  cl = T2((sk, wg) => {
    var OS = kn().codes.ERR_INVALID_OPT_VALUE;
    function FS(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function US(t, e, r, o) {
      var f2 = FS(e, o, r);
      if (f2 != null) {
        if (!(isFinite(f2) && Math.floor(f2) === f2) || f2 < 0) {
          var p2 = o ? r : "highWaterMark";
          throw new OS(p2, f2);
        }
        return Math.floor(f2);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wg.exports = { getHighWaterMark: US };
  });
  bl = T2((hk, Ag) => {
    Ag.exports = ut;
    function _g(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        cE(e, t);
      };
    }
    var xf;
    ut.WritableState = ka;
    var zS = { deprecate: G0() }, xg = hl(), ks = Ut().Buffer, HS = global.Uint8Array || function() {
    };
    function WS(t) {
      return ks.from(t);
    }
    function KS(t) {
      return ks.isBuffer(t) || t instanceof HS;
    }
    var vl = dl(), jS = cl(), ZS = jS.getHighWaterMark, Vi = kn().codes, VS = Vi.ERR_INVALID_ARG_TYPE, $S = Vi.ERR_METHOD_NOT_IMPLEMENTED, GS = Vi.ERR_MULTIPLE_CALLBACK, YS = Vi.ERR_STREAM_CANNOT_PIPE, XS = Vi.ERR_STREAM_DESTROYED, JS = Vi.ERR_STREAM_NULL_VALUES, QS = Vi.ERR_STREAM_WRITE_AFTER_END, eE = Vi.ERR_UNKNOWN_ENCODING, Sf = vl.errorOrDestroy;
    Ie()(ut, xg);
    function tE() {
    }
    function ka(t, e, r) {
      xf = xf || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof xf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = ZS(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f2) {
        sE(e, f2);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new _g(this);
    }
    ka.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(ka.prototype, "buffer", { get: zS.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ts;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut, Symbol.hasInstance, { value: function(e) {
      return Ts.call(this, e) ? true : this !== ut ? false : e && e._writableState instanceof ka;
    } })) : Ts = function(e) {
      return e instanceof this;
    };
    function ut(t) {
      xf = xf || Ln();
      var e = this instanceof xf;
      if (!e && !Ts.call(ut, this))
        return new ut(t);
      this._writableState = new ka(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
    }
    ut.prototype.pipe = function() {
      Sf(this, new YS);
    };
    function rE(t, e) {
      var r = new QS;
      Sf(t, r), process.nextTick(e, r);
    }
    function iE(t, e, r, o) {
      var f2;
      return r === null ? f2 = new JS : typeof r != "string" && !e.objectMode && (f2 = new VS("chunk", ["string", "Buffer"], r)), f2 ? (Sf(t, f2), process.nextTick(o, f2), false) : true;
    }
    ut.prototype.write = function(t, e, r) {
      var o = this._writableState, f2 = false, p2 = !o.objectMode && KS(t);
      return p2 && !ks.isBuffer(t) && (t = WS(t)), typeof e == "function" && (r = e, e = null), p2 ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = tE), o.ending ? rE(this, r) : (p2 || iE(this, o, t, r)) && (o.pendingcb++, f2 = fE(this, o, p2, t, e, r)), f2;
    };
    ut.prototype.cork = function() {
      this._writableState.corked++;
    };
    ut.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Sg(this, t));
    };
    ut.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new eE(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ut.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function nE(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ks.from(e, r)), e;
    }
    Object.defineProperty(ut.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function fE(t, e, r, o, f2, p2) {
      if (!r) {
        var m2 = nE(e, o, f2);
        o !== m2 && (r = true, f2 = "buffer", o = m2);
      }
      var y3 = e.objectMode ? 1 : o.length;
      e.length += y3;
      var M2 = e.length < e.highWaterMark;
      if (M2 || (e.needDrain = true), e.writing || e.corked) {
        var x3 = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f2, isBuf: r, callback: p2, next: null }, x3 ? x3.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        pl(t, e, false, y3, o, f2, p2);
      return M2;
    }
    function pl(t, e, r, o, f2, p2, m2) {
      e.writelen = o, e.writecb = m2, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new XS("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p2, e.onwrite), e.sync = false;
    }
    function aE(t, e, r, o, f2) {
      --e.pendingcb, r ? (process.nextTick(f2, o), process.nextTick(Ta, t, e), t._writableState.errorEmitted = true, Sf(t, o)) : (f2(o), t._writableState.errorEmitted = true, Sf(t, o), Ta(t, e));
    }
    function oE(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function sE(t, e) {
      var r = t._writableState, o = r.sync, f2 = r.writecb;
      if (typeof f2 != "function")
        throw new GS;
      if (oE(r), e)
        aE(t, r, o, e, f2);
      else {
        var p2 = Eg(r) || t.destroyed;
        !p2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Sg(t, r), o ? process.nextTick(Mg, t, r, p2, f2) : Mg(t, r, p2, f2);
      }
    }
    function Mg(t, e, r, o) {
      r || hE(t, e), e.pendingcb--, o(), Ta(t, e);
    }
    function hE(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Sg(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f2 = new Array(o), p2 = e.corkedRequestsFree;
        p2.entry = r;
        for (var m2 = 0, y3 = true;r; )
          f2[m2] = r, r.isBuf || (y3 = false), r = r.next, m2 += 1;
        f2.allBuffers = y3, pl(t, e, true, e.length, f2, "", p2.finish), e.pendingcb++, e.lastBufferedRequest = null, p2.next ? (e.corkedRequestsFree = p2.next, p2.next = null) : e.corkedRequestsFree = new _g(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M2, encoding: x3, callback: S2 } = r, E3 = e.objectMode ? 1 : M2.length;
          if (pl(t, e, false, E3, M2, x3, S2), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ut.prototype._write = function(t, e, r) {
      r(new $S("_write()"));
    };
    ut.prototype._writev = null;
    ut.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || dE(this, o, r), this;
    };
    Object.defineProperty(ut.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Eg(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function uE(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && Sf(t, r), e.prefinished = true, t.emit("prefinish"), Ta(t, e);
      });
    }
    function lE(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(uE, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Ta(t, e) {
      var r = Eg(e);
      if (r && (lE(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function dE(t, e, r) {
      e.ending = true, Ta(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function cE(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f2 = o.callback;
        e.pendingcb--, f2(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ut.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ut.prototype.destroy = vl.destroy;
    ut.prototype._undestroy = vl.undestroy;
    ut.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  Ln = T2((uk, Bg) => {
    var pE = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    Bg.exports = ti;
    var Rg = yl(), gl = bl();
    Ie()(ti, Rg);
    for (ml = pE(gl.prototype), Ls = 0;Ls < ml.length; Ls++)
      Ns = ml[Ls], ti.prototype[Ns] || (ti.prototype[Ns] = gl.prototype[Ns]);
    var ml, Ns, Ls;
    function ti(t) {
      if (!(this instanceof ti))
        return new ti(t);
      Rg.call(this, t), gl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", vE)));
    }
    Object.defineProperty(ti.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(ti.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(ti.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function vE() {
      this._writableState.ended || process.nextTick(bE, this);
    }
    function bE(t) {
      t.end();
    }
    Object.defineProperty(ti.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  Ds = T2((lk, Tg) => {
    var qg = kn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function mE(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f2 = 0;f2 < r; f2++)
            o[f2] = arguments[f2];
          t.apply(this, o);
        }
      };
    }
    function gE() {
    }
    function yE(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Ig(t, e, r) {
      if (typeof e == "function")
        return Ig(t, null, e);
      e || (e = {}), r = mE(r || gE);
      var o = e.readable || e.readable !== false && t.readable, f2 = e.writable || e.writable !== false && t.writable, p2 = function() {
        t.writable || y3();
      }, m2 = t._writableState && t._writableState.finished, y3 = function() {
        f2 = false, m2 = true, o || r.call(t);
      }, M2 = t._readableState && t._readableState.endEmitted, x3 = function() {
        o = false, M2 = true, f2 || r.call(t);
      }, S2 = function(L3) {
        r.call(t, L3);
      }, E3 = function() {
        var L3;
        if (o && !M2)
          return (!t._readableState || !t._readableState.ended) && (L3 = new qg), r.call(t, L3);
        if (f2 && !m2)
          return (!t._writableState || !t._writableState.ended) && (L3 = new qg), r.call(t, L3);
      }, B3 = function() {
        t.req.on("finish", y3);
      };
      return yE(t) ? (t.on("complete", y3), t.on("abort", E3), t.req ? B3() : t.on("request", B3)) : f2 && !t._writableState && (t.on("end", p2), t.on("close", p2)), t.on("end", x3), t.on("finish", y3), e.error !== false && t.on("error", S2), t.on("close", E3), function() {
        t.removeListener("complete", y3), t.removeListener("abort", E3), t.removeListener("request", B3), t.req && t.req.removeListener("finish", y3), t.removeListener("end", p2), t.removeListener("close", p2), t.removeListener("finish", y3), t.removeListener("end", x3), t.removeListener("error", S2), t.removeListener("close", E3);
      };
    }
    Tg.exports = Ig;
  });
  Lg = T2((dk, kg) => {
    var Ps;
    function $i(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var wE = Ds(), Gi = Symbol("lastResolve"), Nn = Symbol("lastReject"), La = Symbol("error"), Cs = Symbol("ended"), Dn = Symbol("lastPromise"), wl = Symbol("handlePromise"), Pn = Symbol("stream");
    function Yi(t, e) {
      return { value: t, done: e };
    }
    function ME(t) {
      var e = t[Gi];
      if (e !== null) {
        var r = t[Pn].read();
        r !== null && (t[Dn] = null, t[Gi] = null, t[Nn] = null, e(Yi(r, false)));
      }
    }
    function _E(t) {
      process.nextTick(ME, t);
    }
    function xE(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[Cs]) {
            r(Yi(undefined, true));
            return;
          }
          e[wl](r, o);
        }, o);
      };
    }
    var SE = Object.getPrototypeOf(function() {
    }), EE = Object.setPrototypeOf((Ps = { get stream() {
      return this[Pn];
    }, next: function() {
      var e = this, r = this[La];
      if (r !== null)
        return Promise.reject(r);
      if (this[Cs])
        return Promise.resolve(Yi(undefined, true));
      if (this[Pn].destroyed)
        return new Promise(function(m2, y3) {
          process.nextTick(function() {
            e[La] ? y3(e[La]) : m2(Yi(undefined, true));
          });
        });
      var o = this[Dn], f2;
      if (o)
        f2 = new Promise(xE(o, this));
      else {
        var p2 = this[Pn].read();
        if (p2 !== null)
          return Promise.resolve(Yi(p2, false));
        f2 = new Promise(this[wl]);
      }
      return this[Dn] = f2, f2;
    } }, $i(Ps, Symbol.asyncIterator, function() {
      return this;
    }), $i(Ps, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[Pn].destroy(null, function(f2) {
          if (f2) {
            o(f2);
            return;
          }
          r(Yi(undefined, true));
        });
      });
    }), Ps), SE), AE = function(e) {
      var r, o = Object.create(EE, (r = {}, $i(r, Pn, { value: e, writable: true }), $i(r, Gi, { value: null, writable: true }), $i(r, Nn, { value: null, writable: true }), $i(r, La, { value: null, writable: true }), $i(r, Cs, { value: e._readableState.endEmitted, writable: true }), $i(r, wl, { value: function(p2, m2) {
        var y3 = o[Pn].read();
        y3 ? (o[Dn] = null, o[Gi] = null, o[Nn] = null, p2(Yi(y3, false))) : (o[Gi] = p2, o[Nn] = m2);
      }, writable: true }), r));
      return o[Dn] = null, wE(e, function(f2) {
        if (f2 && f2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p2 = o[Nn];
          p2 !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, p2(f2)), o[La] = f2;
          return;
        }
        var m2 = o[Gi];
        m2 !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, m2(Yi(undefined, true))), o[Cs] = true;
      }), e.on("readable", _E.bind(null, o)), o;
    };
    kg.exports = AE;
  });
  Dg = T2((ck, Ng) => {
    Ng.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  yl = T2((vk, jg) => {
    jg.exports = Oe;
    var Ef;
    Oe.ReadableState = Fg;
    var pk = ki().EventEmitter, Og = function(e, r) {
      return e.listeners(r).length;
    }, Da = hl(), Os = Ut().Buffer, RE = global.Uint8Array || function() {
    };
    function BE(t) {
      return Os.from(t);
    }
    function qE(t) {
      return Os.isBuffer(t) || t instanceof RE;
    }
    var Ml = $f(), De;
    Ml && Ml.debuglog ? De = Ml.debuglog("stream") : De = function() {
    };
    var IE = pg(), Bl = dl(), TE = cl(), kE = TE.getHighWaterMark, Fs = kn().codes, LE = Fs.ERR_INVALID_ARG_TYPE, NE = Fs.ERR_STREAM_PUSH_AFTER_EOF, DE = Fs.ERR_METHOD_NOT_IMPLEMENTED, PE = Fs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Af, _l, xl;
    Ie()(Oe, Da);
    var Na = Bl.errorOrDestroy, Sl = ["error", "close", "destroy", "pause", "resume"];
    function CE(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Fg(t, e, r) {
      Ef = Ef || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ef), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = kE(this, t, "readableHighWaterMark", r), this.buffer = new IE, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Af || (Af = (Qf(), ur(Jf)).StringDecoder), this.decoder = new Af(t.encoding), this.encoding = t.encoding);
    }
    function Oe(t) {
      if (Ef = Ef || Ln(), !(this instanceof Oe))
        return new Oe(t);
      var e = this instanceof Ef;
      this._readableState = new Fg(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Da.call(this);
    }
    Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Oe.prototype.destroy = Bl.destroy;
    Oe.prototype._undestroy = Bl.undestroy;
    Oe.prototype._destroy = function(t, e) {
      e(t);
    };
    Oe.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Os.from(t, e), e = ""), o = true), Ug(this, t, e, false, o);
    };
    Oe.prototype.unshift = function(t) {
      return Ug(this, t, null, true, false);
    };
    function Ug(t, e, r, o, f2) {
      De("readableAddChunk", e);
      var p2 = t._readableState;
      if (e === null)
        p2.reading = false, UE(t, p2);
      else {
        var m2;
        if (f2 || (m2 = OE(p2, e)), m2)
          Na(t, m2);
        else if (p2.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p2.objectMode && Object.getPrototypeOf(e) !== Os.prototype && (e = BE(e)), o)
            p2.endEmitted ? Na(t, new PE) : El(t, p2, e, true);
          else if (p2.ended)
            Na(t, new NE);
          else {
            if (p2.destroyed)
              return false;
            p2.reading = false, p2.decoder && !r ? (e = p2.decoder.write(e), p2.objectMode || e.length !== 0 ? El(t, p2, e, false) : Rl(t, p2)) : El(t, p2, e, false);
          }
        else
          o || (p2.reading = false, Rl(t, p2));
      }
      return !p2.ended && (p2.length < p2.highWaterMark || p2.length === 0);
    }
    function El(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Us(t)), Rl(t, e);
    }
    function OE(t, e) {
      var r;
      return !qE(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new LE("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Oe.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Oe.prototype.setEncoding = function(t) {
      Af || (Af = (Qf(), ur(Jf)).StringDecoder);
      var e = new Af(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Pg = 1073741824;
    function FE(t) {
      return t >= Pg ? t = Pg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Cg(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = FE(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Oe.prototype.read = function(t) {
      De("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return De("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Al(this) : Us(this), null;
      if (t = Cg(t, e), t === 0 && e.ended)
        return e.length === 0 && Al(this), null;
      var o = e.needReadable;
      De("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, De("length less than watermark", o)), e.ended || e.reading ? (o = false, De("reading or ended", o)) : o && (De("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Cg(r, e)));
      var f2;
      return t > 0 ? f2 = Wg(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Al(this)), f2 !== null && this.emit("data", f2), f2;
    };
    function UE(t, e) {
      if (De("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Us(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, zg(t)));
      }
    }
    function Us(t) {
      var e = t._readableState;
      De("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (De("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(zg, t));
    }
    function zg(t) {
      var e = t._readableState;
      De("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ql(t);
    }
    function Rl(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(zE, t, e));
    }
    function zE(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (De("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Oe.prototype._read = function(t) {
      Na(this, new DE("_read()"));
    };
    Oe.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, De("pipe count=%d opts=%j", o.pipesCount, e);
      var f2 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p2 = f2 ? y3 : ge;
      o.endEmitted ? process.nextTick(p2) : r.once("end", p2), t.on("unpipe", m2);
      function m2(_e, N3) {
        De("onunpipe"), _e === r && N3 && N3.hasUnpiped === false && (N3.hasUnpiped = true, S2());
      }
      function y3() {
        De("onend"), t.end();
      }
      var M2 = HE(r);
      t.on("drain", M2);
      var x3 = false;
      function S2() {
        De("cleanup"), t.removeListener("close", q2), t.removeListener("finish", L3), t.removeListener("drain", M2), t.removeListener("error", B3), t.removeListener("unpipe", m2), r.removeListener("end", y3), r.removeListener("end", ge), r.removeListener("data", E3), x3 = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M2();
      }
      r.on("data", E3);
      function E3(_e) {
        De("ondata");
        var N3 = t.write(_e);
        De("dest.write", N3), N3 === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Kg(o.pipes, t) !== -1) && !x3 && (De("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B3(_e) {
        De("onerror", _e), ge(), t.removeListener("error", B3), Og(t, "error") === 0 && Na(t, _e);
      }
      CE(t, "error", B3);
      function q2() {
        t.removeListener("finish", L3), ge();
      }
      t.once("close", q2);
      function L3() {
        De("onfinish"), t.removeListener("close", q2), ge();
      }
      t.once("finish", L3);
      function ge() {
        De("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (De("pipe resume"), r.resume()), t;
    };
    function HE(t) {
      return function() {
        var r = t._readableState;
        De("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Og(t, "data") && (r.flowing = true, ql(t));
      };
    }
    Oe.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f2 } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p2 = 0;p2 < f2; p2++)
          o[p2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m2 = Kg(e.pipes, t);
      return m2 === -1 ? this : (e.pipes.splice(m2, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Oe.prototype.on = function(t, e) {
      var r = Da.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, De("on readable", o.length, o.reading), o.length ? Us(this) : o.reading || process.nextTick(WE, this)), r;
    };
    Oe.prototype.addListener = Oe.prototype.on;
    Oe.prototype.removeListener = function(t, e) {
      var r = Da.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(Hg, this), r;
    };
    Oe.prototype.removeAllListeners = function(t) {
      var e = Da.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(Hg, this), e;
    };
    function Hg(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function WE(t) {
      De("readable nexttick read 0"), t.read(0);
    }
    Oe.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (De("resume"), t.flowing = !t.readableListening, KE(this, t)), t.paused = false, this;
    };
    function KE(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(jE, t, e));
    }
    function jE(t, e) {
      De("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ql(t), e.flowing && !e.reading && t.read(0);
    }
    Oe.prototype.pause = function() {
      return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ql(t) {
      var e = t._readableState;
      for (De("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Oe.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (De("wrapped end"), r.decoder && !r.ended) {
          var m2 = r.decoder.end();
          m2 && m2.length && e.push(m2);
        }
        e.push(null);
      }), t.on("data", function(m2) {
        if (De("wrapped data"), r.decoder && (m2 = r.decoder.write(m2)), !(r.objectMode && m2 == null) && !(!r.objectMode && (!m2 || !m2.length))) {
          var y3 = e.push(m2);
          y3 || (o = true, t.pause());
        }
      });
      for (var f2 in t)
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = function(y3) {
          return function() {
            return t[y3].apply(t, arguments);
          };
        }(f2));
      for (var p2 = 0;p2 < Sl.length; p2++)
        t.on(Sl[p2], this.emit.bind(this, Sl[p2]));
      return this._read = function(m2) {
        De("wrapped _read", m2), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
      return _l === undefined && (_l = Lg()), _l(this);
    });
    Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Oe._fromList = Wg;
    Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wg(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Al(t) {
      var e = t._readableState;
      De("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(ZE, e, t));
    }
    function ZE(t, e) {
      if (De("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Oe.from = function(t, e) {
      return xl === undefined && (xl = Dg()), xl(Oe, t, e);
    });
    function Kg(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  Il = T2((bk, Vg) => {
    Vg.exports = Ei;
    var zs = kn().codes, VE = zs.ERR_METHOD_NOT_IMPLEMENTED, $E = zs.ERR_MULTIPLE_CALLBACK, GE = zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, YE = zs.ERR_TRANSFORM_WITH_LENGTH_0, Hs = Ln();
    Ie()(Ei, Hs);
    function XE(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new $E);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f2 = this._readableState;
      f2.reading = false, (f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
    }
    function Ei(t) {
      if (!(this instanceof Ei))
        return new Ei(t);
      Hs.call(this, t), this._transformState = { afterTransform: XE.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", JE);
    }
    function JE() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Zg(t, e, r);
      }) : Zg(this, null, null);
    }
    Ei.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, Hs.prototype.push.call(this, t, e);
    };
    Ei.prototype._transform = function(t, e, r) {
      r(new VE("_transform()"));
    };
    Ei.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f2 = this._readableState;
        (o.needTransform || f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
      }
    };
    Ei.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    Ei.prototype._destroy = function(t, e) {
      Hs.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Zg(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new YE;
      if (t._transformState.transforming)
        throw new GE;
      return t.push(null);
    }
  });
  Yg = T2((mk, Gg) => {
    Gg.exports = Pa;
    var $g = Il();
    Ie()(Pa, $g);
    function Pa(t) {
      if (!(this instanceof Pa))
        return new Pa(t);
      $g.call(this, t);
    }
    Pa.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  t2 = T2((gk, e2) => {
    var Tl;
    function QE(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var Qg = kn().codes, eA = Qg.ERR_MISSING_ARGS, tA = Qg.ERR_STREAM_DESTROYED;
    function Xg(t) {
      if (t)
        throw t;
    }
    function rA(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function iA(t, e, r, o) {
      o = QE(o);
      var f2 = false;
      t.on("close", function() {
        f2 = true;
      }), Tl === undefined && (Tl = Ds()), Tl(t, { readable: e, writable: r }, function(m2) {
        if (m2)
          return o(m2);
        f2 = true, o();
      });
      var p2 = false;
      return function(m2) {
        if (!f2 && !p2) {
          if (p2 = true, rA(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m2 || new tA("pipe"));
        }
      };
    }
    function Jg(t) {
      t();
    }
    function nA(t, e) {
      return t.pipe(e);
    }
    function fA(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? Xg : t.pop();
    }
    function aA() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = fA(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new eA("streams");
      var f2, p2 = e.map(function(m2, y3) {
        var M2 = y3 < e.length - 1, x3 = y3 > 0;
        return iA(m2, M2, x3, function(S2) {
          f2 || (f2 = S2), S2 && p2.forEach(Jg), !M2 && (p2.forEach(Jg), o(f2));
        });
      });
      return e.reduce(nA);
    }
    e2.exports = aA;
  });
  i2 = T2((Mr, r2) => {
    Mr = r2.exports = yl();
    Mr.Stream = Mr;
    Mr.Readable = Mr;
    Mr.Writable = bl();
    Mr.Duplex = Ln();
    Mr.Transform = Il();
    Mr.PassThrough = Yg();
    Mr.finished = Ds();
    Mr.pipeline = t2();
  });
  Ws = T2((n2, kl) => {
    (function(t, e) {
      function r(h3, s2) {
        if (!h3)
          throw new Error(s2 || "Assertion failed");
      }
      function o(h3, s2) {
        h3.super_ = s2;
        var u3 = function() {
        };
        u3.prototype = s2.prototype, h3.prototype = new u3, h3.prototype.constructor = h3;
      }
      function f2(h3, s2, u3) {
        if (f2.isBN(h3))
          return h3;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h3 !== null && ((s2 === "le" || s2 === "be") && (u3 = s2, s2 = 10), this._init(h3 || 0, s2 || 10, u3 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f2.isBN = function(s2) {
        return s2 instanceof f2 ? true : s2 !== null && typeof s2 == "object" && s2.constructor.wordSize === f2.wordSize && Array.isArray(s2.words);
      }, f2.max = function(s2, u3) {
        return s2.cmp(u3) > 0 ? s2 : u3;
      }, f2.min = function(s2, u3) {
        return s2.cmp(u3) < 0 ? s2 : u3;
      }, f2.prototype._init = function(s2, u3, c2) {
        if (typeof s2 == "number")
          return this._initNumber(s2, u3, c2);
        if (typeof s2 == "object")
          return this._initArray(s2, u3, c2);
        u3 === "hex" && (u3 = 16), r(u3 === (u3 | 0) && u3 >= 2 && u3 <= 36), s2 = s2.toString().replace(/\s+/g, "");
        var b2 = 0;
        s2[0] === "-" && (b2++, this.negative = 1), b2 < s2.length && (u3 === 16 ? this._parseHex(s2, b2, c2) : (this._parseBase(s2, u3, b2), c2 === "le" && this._initArray(this.toArray(), u3, c2)));
      }, f2.prototype._initNumber = function(s2, u3, c2) {
        s2 < 0 && (this.negative = 1, s2 = -s2), s2 < 67108864 ? (this.words = [s2 & 67108863], this.length = 1) : s2 < 4503599627370496 ? (this.words = [s2 & 67108863, s2 / 67108864 & 67108863], this.length = 2) : (r(s2 < 9007199254740992), this.words = [s2 & 67108863, s2 / 67108864 & 67108863, 1], this.length = 3), c2 === "le" && this._initArray(this.toArray(), u3, c2);
      }, f2.prototype._initArray = function(s2, u3, c2) {
        if (r(typeof s2.length == "number"), s2.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(s2.length / 3), this.words = new Array(this.length);
        for (var b2 = 0;b2 < this.length; b2++)
          this.words[b2] = 0;
        var l2, n, d2 = 0;
        if (c2 === "be")
          for (b2 = s2.length - 1, l2 = 0;b2 >= 0; b2 -= 3)
            n = s2[b2] | s2[b2 - 1] << 8 | s2[b2 - 2] << 16, this.words[l2] |= n << d2 & 67108863, this.words[l2 + 1] = n >>> 26 - d2 & 67108863, d2 += 24, d2 >= 26 && (d2 -= 26, l2++);
        else if (c2 === "le")
          for (b2 = 0, l2 = 0;b2 < s2.length; b2 += 3)
            n = s2[b2] | s2[b2 + 1] << 8 | s2[b2 + 2] << 16, this.words[l2] |= n << d2 & 67108863, this.words[l2 + 1] = n >>> 26 - d2 & 67108863, d2 += 24, d2 >= 26 && (d2 -= 26, l2++);
        return this._strip();
      };
      function m2(h3, s2) {
        var u3 = h3.charCodeAt(s2);
        if (u3 >= 48 && u3 <= 57)
          return u3 - 48;
        if (u3 >= 65 && u3 <= 70)
          return u3 - 55;
        if (u3 >= 97 && u3 <= 102)
          return u3 - 87;
        r(false, "Invalid character in " + h3);
      }
      function y3(h3, s2, u3) {
        var c2 = m2(h3, u3);
        return u3 - 1 >= s2 && (c2 |= m2(h3, u3 - 1) << 4), c2;
      }
      f2.prototype._parseHex = function(s2, u3, c2) {
        this.length = Math.ceil((s2.length - u3) / 6), this.words = new Array(this.length);
        for (var b2 = 0;b2 < this.length; b2++)
          this.words[b2] = 0;
        var l2 = 0, n = 0, d2;
        if (c2 === "be")
          for (b2 = s2.length - 1;b2 >= u3; b2 -= 2)
            d2 = y3(s2, u3, b2) << l2, this.words[n] |= d2 & 67108863, l2 >= 18 ? (l2 -= 18, n += 1, this.words[n] |= d2 >>> 26) : l2 += 8;
        else {
          var w = s2.length - u3;
          for (b2 = w % 2 === 0 ? u3 + 1 : u3;b2 < s2.length; b2 += 2)
            d2 = y3(s2, u3, b2) << l2, this.words[n] |= d2 & 67108863, l2 >= 18 ? (l2 -= 18, n += 1, this.words[n] |= d2 >>> 26) : l2 += 8;
        }
        this._strip();
      };
      function M2(h3, s2, u3, c2) {
        for (var b2 = 0, l2 = 0, n = Math.min(h3.length, u3), d2 = s2;d2 < n; d2++) {
          var w = h3.charCodeAt(d2) - 48;
          b2 *= c2, w >= 49 ? l2 = w - 49 + 10 : w >= 17 ? l2 = w - 17 + 10 : l2 = w, r(w >= 0 && l2 < c2, "Invalid character"), b2 += l2;
        }
        return b2;
      }
      f2.prototype._parseBase = function(s2, u3, c2) {
        this.words = [0], this.length = 1;
        for (var b2 = 0, l2 = 1;l2 <= 67108863; l2 *= u3)
          b2++;
        b2--, l2 = l2 / u3 | 0;
        for (var n = s2.length - c2, d2 = n % b2, w = Math.min(n, n - d2) + c2, g3 = 0, _3 = c2;_3 < w; _3 += b2)
          g3 = M2(s2, _3, _3 + b2, u3), this.imuln(l2), this.words[0] + g3 < 67108864 ? this.words[0] += g3 : this._iaddn(g3);
        if (d2 !== 0) {
          var A2 = 1;
          for (g3 = M2(s2, _3, s2.length, u3), _3 = 0;_3 < d2; _3++)
            A2 *= u3;
          this.imuln(A2), this.words[0] + g3 < 67108864 ? this.words[0] += g3 : this._iaddn(g3);
        }
        this._strip();
      }, f2.prototype.copy = function(s2) {
        s2.words = new Array(this.length);
        for (var u3 = 0;u3 < this.length; u3++)
          s2.words[u3] = this.words[u3];
        s2.length = this.length, s2.negative = this.negative, s2.red = this.red;
      };
      function x3(h3, s2) {
        h3.words = s2.words, h3.length = s2.length, h3.negative = s2.negative, h3.red = s2.red;
      }
      if (f2.prototype._move = function(s2) {
        x3(s2, this);
      }, f2.prototype.clone = function() {
        var s2 = new f2(null);
        return this.copy(s2), s2;
      }, f2.prototype._expand = function(s2) {
        for (;this.length < s2; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype._strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          f2.prototype[Symbol.for("nodejs.util.inspect.custom")] = S2;
        } catch {
          f2.prototype.inspect = S2;
        }
      else
        f2.prototype.inspect = S2;
      function S2() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var E3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(s2, u3) {
        s2 = s2 || 10, u3 = u3 | 0 || 1;
        var c2;
        if (s2 === 16 || s2 === "hex") {
          c2 = "";
          for (var b2 = 0, l2 = 0, n = 0;n < this.length; n++) {
            var d2 = this.words[n], w = ((d2 << b2 | l2) & 16777215).toString(16);
            l2 = d2 >>> 24 - b2 & 16777215, b2 += 2, b2 >= 26 && (b2 -= 26, n--), l2 !== 0 || n !== this.length - 1 ? c2 = E3[6 - w.length] + w + c2 : c2 = w + c2;
          }
          for (l2 !== 0 && (c2 = l2.toString(16) + c2);c2.length % u3 !== 0; )
            c2 = "0" + c2;
          return this.negative !== 0 && (c2 = "-" + c2), c2;
        }
        if (s2 === (s2 | 0) && s2 >= 2 && s2 <= 36) {
          var g3 = B3[s2], _3 = q2[s2];
          c2 = "";
          var A2 = this.clone();
          for (A2.negative = 0;!A2.isZero(); ) {
            var R2 = A2.modrn(_3).toString(s2);
            A2 = A2.idivn(_3), A2.isZero() ? c2 = R2 + c2 : c2 = E3[g3 - R2.length] + R2 + c2;
          }
          for (this.isZero() && (c2 = "0" + c2);c2.length % u3 !== 0; )
            c2 = "0" + c2;
          return this.negative !== 0 && (c2 = "-" + c2), c2;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var s2 = this.words[0];
        return this.length === 2 ? s2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s2 : s2;
      }, f2.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p2 && (f2.prototype.toBuffer = function(s2, u3) {
        return this.toArrayLike(p2, s2, u3);
      }), f2.prototype.toArray = function(s2, u3) {
        return this.toArrayLike(Array, s2, u3);
      };
      var L3 = function(s2, u3) {
        return s2.allocUnsafe ? s2.allocUnsafe(u3) : new s2(u3);
      };
      f2.prototype.toArrayLike = function(s2, u3, c2) {
        this._strip();
        var b2 = this.byteLength(), l2 = c2 || Math.max(1, b2);
        r(b2 <= l2, "byte array longer than desired length"), r(l2 > 0, "Requested array length <= 0");
        var n = L3(s2, l2), d2 = u3 === "le" ? "LE" : "BE";
        return this["_toArrayLike" + d2](n, b2), n;
      }, f2.prototype._toArrayLikeLE = function(s2, u3) {
        for (var c2 = 0, b2 = 0, l2 = 0, n = 0;l2 < this.length; l2++) {
          var d2 = this.words[l2] << n | b2;
          s2[c2++] = d2 & 255, c2 < s2.length && (s2[c2++] = d2 >> 8 & 255), c2 < s2.length && (s2[c2++] = d2 >> 16 & 255), n === 6 ? (c2 < s2.length && (s2[c2++] = d2 >> 24 & 255), b2 = 0, n = 0) : (b2 = d2 >>> 24, n += 2);
        }
        if (c2 < s2.length)
          for (s2[c2++] = b2;c2 < s2.length; )
            s2[c2++] = 0;
      }, f2.prototype._toArrayLikeBE = function(s2, u3) {
        for (var c2 = s2.length - 1, b2 = 0, l2 = 0, n = 0;l2 < this.length; l2++) {
          var d2 = this.words[l2] << n | b2;
          s2[c2--] = d2 & 255, c2 >= 0 && (s2[c2--] = d2 >> 8 & 255), c2 >= 0 && (s2[c2--] = d2 >> 16 & 255), n === 6 ? (c2 >= 0 && (s2[c2--] = d2 >> 24 & 255), b2 = 0, n = 0) : (b2 = d2 >>> 24, n += 2);
        }
        if (c2 >= 0)
          for (s2[c2--] = b2;c2 >= 0; )
            s2[c2--] = 0;
      }, Math.clz32 ? f2.prototype._countBits = function(s2) {
        return 32 - Math.clz32(s2);
      } : f2.prototype._countBits = function(s2) {
        var u3 = s2, c2 = 0;
        return u3 >= 4096 && (c2 += 13, u3 >>>= 13), u3 >= 64 && (c2 += 7, u3 >>>= 7), u3 >= 8 && (c2 += 4, u3 >>>= 4), u3 >= 2 && (c2 += 2, u3 >>>= 2), c2 + u3;
      }, f2.prototype._zeroBits = function(s2) {
        if (s2 === 0)
          return 26;
        var u3 = s2, c2 = 0;
        return (u3 & 8191) === 0 && (c2 += 13, u3 >>>= 13), (u3 & 127) === 0 && (c2 += 7, u3 >>>= 7), (u3 & 15) === 0 && (c2 += 4, u3 >>>= 4), (u3 & 3) === 0 && (c2 += 2, u3 >>>= 2), (u3 & 1) === 0 && c2++, c2;
      }, f2.prototype.bitLength = function() {
        var s2 = this.words[this.length - 1], u3 = this._countBits(s2);
        return (this.length - 1) * 26 + u3;
      };
      function ge(h3) {
        for (var s2 = new Array(h3.bitLength()), u3 = 0;u3 < s2.length; u3++) {
          var c2 = u3 / 26 | 0, b2 = u3 % 26;
          s2[u3] = h3.words[c2] >>> b2 & 1;
        }
        return s2;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var s2 = 0, u3 = 0;u3 < this.length; u3++) {
          var c2 = this._zeroBits(this.words[u3]);
          if (s2 += c2, c2 !== 26)
            break;
        }
        return s2;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(s2) {
        return this.negative !== 0 ? this.abs().inotn(s2).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(s2) {
        return this.testn(s2 - 1) ? this.notn(s2).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(s2) {
        for (;this.length < s2.length; )
          this.words[this.length++] = 0;
        for (var u3 = 0;u3 < s2.length; u3++)
          this.words[u3] = this.words[u3] | s2.words[u3];
        return this._strip();
      }, f2.prototype.ior = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuor(s2);
      }, f2.prototype.or = function(s2) {
        return this.length > s2.length ? this.clone().ior(s2) : s2.clone().ior(this);
      }, f2.prototype.uor = function(s2) {
        return this.length > s2.length ? this.clone().iuor(s2) : s2.clone().iuor(this);
      }, f2.prototype.iuand = function(s2) {
        var u3;
        this.length > s2.length ? u3 = s2 : u3 = this;
        for (var c2 = 0;c2 < u3.length; c2++)
          this.words[c2] = this.words[c2] & s2.words[c2];
        return this.length = u3.length, this._strip();
      }, f2.prototype.iand = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuand(s2);
      }, f2.prototype.and = function(s2) {
        return this.length > s2.length ? this.clone().iand(s2) : s2.clone().iand(this);
      }, f2.prototype.uand = function(s2) {
        return this.length > s2.length ? this.clone().iuand(s2) : s2.clone().iuand(this);
      }, f2.prototype.iuxor = function(s2) {
        var u3, c2;
        this.length > s2.length ? (u3 = this, c2 = s2) : (u3 = s2, c2 = this);
        for (var b2 = 0;b2 < c2.length; b2++)
          this.words[b2] = u3.words[b2] ^ c2.words[b2];
        if (this !== u3)
          for (;b2 < u3.length; b2++)
            this.words[b2] = u3.words[b2];
        return this.length = u3.length, this._strip();
      }, f2.prototype.ixor = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuxor(s2);
      }, f2.prototype.xor = function(s2) {
        return this.length > s2.length ? this.clone().ixor(s2) : s2.clone().ixor(this);
      }, f2.prototype.uxor = function(s2) {
        return this.length > s2.length ? this.clone().iuxor(s2) : s2.clone().iuxor(this);
      }, f2.prototype.inotn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u3 = Math.ceil(s2 / 26) | 0, c2 = s2 % 26;
        this._expand(u3), c2 > 0 && u3--;
        for (var b2 = 0;b2 < u3; b2++)
          this.words[b2] = ~this.words[b2] & 67108863;
        return c2 > 0 && (this.words[b2] = ~this.words[b2] & 67108863 >> 26 - c2), this._strip();
      }, f2.prototype.notn = function(s2) {
        return this.clone().inotn(s2);
      }, f2.prototype.setn = function(s2, u3) {
        r(typeof s2 == "number" && s2 >= 0);
        var c2 = s2 / 26 | 0, b2 = s2 % 26;
        return this._expand(c2 + 1), u3 ? this.words[c2] = this.words[c2] | 1 << b2 : this.words[c2] = this.words[c2] & ~(1 << b2), this._strip();
      }, f2.prototype.iadd = function(s2) {
        var u3;
        if (this.negative !== 0 && s2.negative === 0)
          return this.negative = 0, u3 = this.isub(s2), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && s2.negative !== 0)
          return s2.negative = 0, u3 = this.isub(s2), s2.negative = 1, u3._normSign();
        var c2, b2;
        this.length > s2.length ? (c2 = this, b2 = s2) : (c2 = s2, b2 = this);
        for (var l2 = 0, n = 0;n < b2.length; n++)
          u3 = (c2.words[n] | 0) + (b2.words[n] | 0) + l2, this.words[n] = u3 & 67108863, l2 = u3 >>> 26;
        for (;l2 !== 0 && n < c2.length; n++)
          u3 = (c2.words[n] | 0) + l2, this.words[n] = u3 & 67108863, l2 = u3 >>> 26;
        if (this.length = c2.length, l2 !== 0)
          this.words[this.length] = l2, this.length++;
        else if (c2 !== this)
          for (;n < c2.length; n++)
            this.words[n] = c2.words[n];
        return this;
      }, f2.prototype.add = function(s2) {
        var u3;
        return s2.negative !== 0 && this.negative === 0 ? (s2.negative = 0, u3 = this.sub(s2), s2.negative ^= 1, u3) : s2.negative === 0 && this.negative !== 0 ? (this.negative = 0, u3 = s2.sub(this), this.negative = 1, u3) : this.length > s2.length ? this.clone().iadd(s2) : s2.clone().iadd(this);
      }, f2.prototype.isub = function(s2) {
        if (s2.negative !== 0) {
          s2.negative = 0;
          var u3 = this.iadd(s2);
          return s2.negative = 1, u3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(s2), this.negative = 1, this._normSign();
        var c2 = this.cmp(s2);
        if (c2 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var b2, l2;
        c2 > 0 ? (b2 = this, l2 = s2) : (b2 = s2, l2 = this);
        for (var n = 0, d2 = 0;d2 < l2.length; d2++)
          u3 = (b2.words[d2] | 0) - (l2.words[d2] | 0) + n, n = u3 >> 26, this.words[d2] = u3 & 67108863;
        for (;n !== 0 && d2 < b2.length; d2++)
          u3 = (b2.words[d2] | 0) + n, n = u3 >> 26, this.words[d2] = u3 & 67108863;
        if (n === 0 && d2 < b2.length && b2 !== this)
          for (;d2 < b2.length; d2++)
            this.words[d2] = b2.words[d2];
        return this.length = Math.max(this.length, d2), b2 !== this && (this.negative = 1), this._strip();
      }, f2.prototype.sub = function(s2) {
        return this.clone().isub(s2);
      };
      function _e(h3, s2, u3) {
        u3.negative = s2.negative ^ h3.negative;
        var c2 = h3.length + s2.length | 0;
        u3.length = c2, c2 = c2 - 1 | 0;
        var b2 = h3.words[0] | 0, l2 = s2.words[0] | 0, n = b2 * l2, d2 = n & 67108863, w = n / 67108864 | 0;
        u3.words[0] = d2;
        for (var g3 = 1;g3 < c2; g3++) {
          for (var _3 = w >>> 26, A2 = w & 67108863, R2 = Math.min(g3, s2.length - 1), I3 = Math.max(0, g3 - h3.length + 1);I3 <= R2; I3++) {
            var Me = g3 - I3 | 0;
            b2 = h3.words[Me] | 0, l2 = s2.words[I3] | 0, n = b2 * l2 + A2, _3 += n / 67108864 | 0, A2 = n & 67108863;
          }
          u3.words[g3] = A2 | 0, w = _3 | 0;
        }
        return w !== 0 ? u3.words[g3] = w | 0 : u3.length--, u3._strip();
      }
      var N3 = function(s2, u3, c2) {
        var b2 = s2.words, l2 = u3.words, n = c2.words, d2 = 0, w, g3, _3, A2 = b2[0] | 0, R2 = A2 & 8191, I3 = A2 >>> 13, Me = b2[1] | 0, k3 = Me & 8191, D2 = Me >>> 13, nt = b2[2] | 0, C = nt & 8191, O3 = nt >>> 13, vt = b2[3] | 0, F = vt & 8191, U3 = vt >>> 13, bt = b2[4] | 0, z = bt & 8191, H2 = bt >>> 13, mt = b2[5] | 0, W = mt & 8191, K2 = mt >>> 13, gt = b2[6] | 0, j3 = gt & 8191, Z2 = gt >>> 13, yt = b2[7] | 0, V3 = yt & 8191, $2 = yt >>> 13, wt = b2[8] | 0, G2 = wt & 8191, Y2 = wt >>> 13, Mt = b2[9] | 0, X3 = Mt & 8191, J2 = Mt >>> 13, _t = l2[0] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = l2[1] | 0, te = xt & 8191, re = xt >>> 13, St = l2[2] | 0, ie = St & 8191, ne = St >>> 13, Et = l2[3] | 0, fe = Et & 8191, ae = Et >>> 13, At = l2[4] | 0, oe = At & 8191, se = At >>> 13, Rt = l2[5] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = l2[6] | 0, le = Bt & 8191, de = Bt >>> 13, qt = l2[7] | 0, ce = qt & 8191, pe = qt >>> 13, It = l2[8] | 0, ve = It & 8191, be = It >>> 13, ft = l2[9] | 0, Be = ft & 8191, qe = ft >>> 13;
        c2.negative = s2.negative ^ u3.negative, c2.length = 19, w = Math.imul(R2, Q2), g3 = Math.imul(R2, ee), g3 = g3 + Math.imul(I3, Q2) | 0, _3 = Math.imul(I3, ee);
        var ze = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w = Math.imul(k3, Q2), g3 = Math.imul(k3, ee), g3 = g3 + Math.imul(D2, Q2) | 0, _3 = Math.imul(D2, ee), w = w + Math.imul(R2, te) | 0, g3 = g3 + Math.imul(R2, re) | 0, g3 = g3 + Math.imul(I3, te) | 0, _3 = _3 + Math.imul(I3, re) | 0;
        var He = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, w = Math.imul(C, Q2), g3 = Math.imul(C, ee), g3 = g3 + Math.imul(O3, Q2) | 0, _3 = Math.imul(O3, ee), w = w + Math.imul(k3, te) | 0, g3 = g3 + Math.imul(k3, re) | 0, g3 = g3 + Math.imul(D2, te) | 0, _3 = _3 + Math.imul(D2, re) | 0, w = w + Math.imul(R2, ie) | 0, g3 = g3 + Math.imul(R2, ne) | 0, g3 = g3 + Math.imul(I3, ie) | 0, _3 = _3 + Math.imul(I3, ne) | 0;
        var We = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, w = Math.imul(F, Q2), g3 = Math.imul(F, ee), g3 = g3 + Math.imul(U3, Q2) | 0, _3 = Math.imul(U3, ee), w = w + Math.imul(C, te) | 0, g3 = g3 + Math.imul(C, re) | 0, g3 = g3 + Math.imul(O3, te) | 0, _3 = _3 + Math.imul(O3, re) | 0, w = w + Math.imul(k3, ie) | 0, g3 = g3 + Math.imul(k3, ne) | 0, g3 = g3 + Math.imul(D2, ie) | 0, _3 = _3 + Math.imul(D2, ne) | 0, w = w + Math.imul(R2, fe) | 0, g3 = g3 + Math.imul(R2, ae) | 0, g3 = g3 + Math.imul(I3, fe) | 0, _3 = _3 + Math.imul(I3, ae) | 0;
        var Ke = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w = Math.imul(z, Q2), g3 = Math.imul(z, ee), g3 = g3 + Math.imul(H2, Q2) | 0, _3 = Math.imul(H2, ee), w = w + Math.imul(F, te) | 0, g3 = g3 + Math.imul(F, re) | 0, g3 = g3 + Math.imul(U3, te) | 0, _3 = _3 + Math.imul(U3, re) | 0, w = w + Math.imul(C, ie) | 0, g3 = g3 + Math.imul(C, ne) | 0, g3 = g3 + Math.imul(O3, ie) | 0, _3 = _3 + Math.imul(O3, ne) | 0, w = w + Math.imul(k3, fe) | 0, g3 = g3 + Math.imul(k3, ae) | 0, g3 = g3 + Math.imul(D2, fe) | 0, _3 = _3 + Math.imul(D2, ae) | 0, w = w + Math.imul(R2, oe) | 0, g3 = g3 + Math.imul(R2, se) | 0, g3 = g3 + Math.imul(I3, oe) | 0, _3 = _3 + Math.imul(I3, se) | 0;
        var je = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w = Math.imul(W, Q2), g3 = Math.imul(W, ee), g3 = g3 + Math.imul(K2, Q2) | 0, _3 = Math.imul(K2, ee), w = w + Math.imul(z, te) | 0, g3 = g3 + Math.imul(z, re) | 0, g3 = g3 + Math.imul(H2, te) | 0, _3 = _3 + Math.imul(H2, re) | 0, w = w + Math.imul(F, ie) | 0, g3 = g3 + Math.imul(F, ne) | 0, g3 = g3 + Math.imul(U3, ie) | 0, _3 = _3 + Math.imul(U3, ne) | 0, w = w + Math.imul(C, fe) | 0, g3 = g3 + Math.imul(C, ae) | 0, g3 = g3 + Math.imul(O3, fe) | 0, _3 = _3 + Math.imul(O3, ae) | 0, w = w + Math.imul(k3, oe) | 0, g3 = g3 + Math.imul(k3, se) | 0, g3 = g3 + Math.imul(D2, oe) | 0, _3 = _3 + Math.imul(D2, se) | 0, w = w + Math.imul(R2, he) | 0, g3 = g3 + Math.imul(R2, ue) | 0, g3 = g3 + Math.imul(I3, he) | 0, _3 = _3 + Math.imul(I3, ue) | 0;
        var Ze = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, w = Math.imul(j3, Q2), g3 = Math.imul(j3, ee), g3 = g3 + Math.imul(Z2, Q2) | 0, _3 = Math.imul(Z2, ee), w = w + Math.imul(W, te) | 0, g3 = g3 + Math.imul(W, re) | 0, g3 = g3 + Math.imul(K2, te) | 0, _3 = _3 + Math.imul(K2, re) | 0, w = w + Math.imul(z, ie) | 0, g3 = g3 + Math.imul(z, ne) | 0, g3 = g3 + Math.imul(H2, ie) | 0, _3 = _3 + Math.imul(H2, ne) | 0, w = w + Math.imul(F, fe) | 0, g3 = g3 + Math.imul(F, ae) | 0, g3 = g3 + Math.imul(U3, fe) | 0, _3 = _3 + Math.imul(U3, ae) | 0, w = w + Math.imul(C, oe) | 0, g3 = g3 + Math.imul(C, se) | 0, g3 = g3 + Math.imul(O3, oe) | 0, _3 = _3 + Math.imul(O3, se) | 0, w = w + Math.imul(k3, he) | 0, g3 = g3 + Math.imul(k3, ue) | 0, g3 = g3 + Math.imul(D2, he) | 0, _3 = _3 + Math.imul(D2, ue) | 0, w = w + Math.imul(R2, le) | 0, g3 = g3 + Math.imul(R2, de) | 0, g3 = g3 + Math.imul(I3, le) | 0, _3 = _3 + Math.imul(I3, de) | 0;
        var Ve = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w = Math.imul(V3, Q2), g3 = Math.imul(V3, ee), g3 = g3 + Math.imul($2, Q2) | 0, _3 = Math.imul($2, ee), w = w + Math.imul(j3, te) | 0, g3 = g3 + Math.imul(j3, re) | 0, g3 = g3 + Math.imul(Z2, te) | 0, _3 = _3 + Math.imul(Z2, re) | 0, w = w + Math.imul(W, ie) | 0, g3 = g3 + Math.imul(W, ne) | 0, g3 = g3 + Math.imul(K2, ie) | 0, _3 = _3 + Math.imul(K2, ne) | 0, w = w + Math.imul(z, fe) | 0, g3 = g3 + Math.imul(z, ae) | 0, g3 = g3 + Math.imul(H2, fe) | 0, _3 = _3 + Math.imul(H2, ae) | 0, w = w + Math.imul(F, oe) | 0, g3 = g3 + Math.imul(F, se) | 0, g3 = g3 + Math.imul(U3, oe) | 0, _3 = _3 + Math.imul(U3, se) | 0, w = w + Math.imul(C, he) | 0, g3 = g3 + Math.imul(C, ue) | 0, g3 = g3 + Math.imul(O3, he) | 0, _3 = _3 + Math.imul(O3, ue) | 0, w = w + Math.imul(k3, le) | 0, g3 = g3 + Math.imul(k3, de) | 0, g3 = g3 + Math.imul(D2, le) | 0, _3 = _3 + Math.imul(D2, de) | 0, w = w + Math.imul(R2, ce) | 0, g3 = g3 + Math.imul(R2, pe) | 0, g3 = g3 + Math.imul(I3, ce) | 0, _3 = _3 + Math.imul(I3, pe) | 0;
        var $e = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, w = Math.imul(G2, Q2), g3 = Math.imul(G2, ee), g3 = g3 + Math.imul(Y2, Q2) | 0, _3 = Math.imul(Y2, ee), w = w + Math.imul(V3, te) | 0, g3 = g3 + Math.imul(V3, re) | 0, g3 = g3 + Math.imul($2, te) | 0, _3 = _3 + Math.imul($2, re) | 0, w = w + Math.imul(j3, ie) | 0, g3 = g3 + Math.imul(j3, ne) | 0, g3 = g3 + Math.imul(Z2, ie) | 0, _3 = _3 + Math.imul(Z2, ne) | 0, w = w + Math.imul(W, fe) | 0, g3 = g3 + Math.imul(W, ae) | 0, g3 = g3 + Math.imul(K2, fe) | 0, _3 = _3 + Math.imul(K2, ae) | 0, w = w + Math.imul(z, oe) | 0, g3 = g3 + Math.imul(z, se) | 0, g3 = g3 + Math.imul(H2, oe) | 0, _3 = _3 + Math.imul(H2, se) | 0, w = w + Math.imul(F, he) | 0, g3 = g3 + Math.imul(F, ue) | 0, g3 = g3 + Math.imul(U3, he) | 0, _3 = _3 + Math.imul(U3, ue) | 0, w = w + Math.imul(C, le) | 0, g3 = g3 + Math.imul(C, de) | 0, g3 = g3 + Math.imul(O3, le) | 0, _3 = _3 + Math.imul(O3, de) | 0, w = w + Math.imul(k3, ce) | 0, g3 = g3 + Math.imul(k3, pe) | 0, g3 = g3 + Math.imul(D2, ce) | 0, _3 = _3 + Math.imul(D2, pe) | 0, w = w + Math.imul(R2, ve) | 0, g3 = g3 + Math.imul(R2, be) | 0, g3 = g3 + Math.imul(I3, ve) | 0, _3 = _3 + Math.imul(I3, be) | 0;
        var Ge = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w = Math.imul(X3, Q2), g3 = Math.imul(X3, ee), g3 = g3 + Math.imul(J2, Q2) | 0, _3 = Math.imul(J2, ee), w = w + Math.imul(G2, te) | 0, g3 = g3 + Math.imul(G2, re) | 0, g3 = g3 + Math.imul(Y2, te) | 0, _3 = _3 + Math.imul(Y2, re) | 0, w = w + Math.imul(V3, ie) | 0, g3 = g3 + Math.imul(V3, ne) | 0, g3 = g3 + Math.imul($2, ie) | 0, _3 = _3 + Math.imul($2, ne) | 0, w = w + Math.imul(j3, fe) | 0, g3 = g3 + Math.imul(j3, ae) | 0, g3 = g3 + Math.imul(Z2, fe) | 0, _3 = _3 + Math.imul(Z2, ae) | 0, w = w + Math.imul(W, oe) | 0, g3 = g3 + Math.imul(W, se) | 0, g3 = g3 + Math.imul(K2, oe) | 0, _3 = _3 + Math.imul(K2, se) | 0, w = w + Math.imul(z, he) | 0, g3 = g3 + Math.imul(z, ue) | 0, g3 = g3 + Math.imul(H2, he) | 0, _3 = _3 + Math.imul(H2, ue) | 0, w = w + Math.imul(F, le) | 0, g3 = g3 + Math.imul(F, de) | 0, g3 = g3 + Math.imul(U3, le) | 0, _3 = _3 + Math.imul(U3, de) | 0, w = w + Math.imul(C, ce) | 0, g3 = g3 + Math.imul(C, pe) | 0, g3 = g3 + Math.imul(O3, ce) | 0, _3 = _3 + Math.imul(O3, pe) | 0, w = w + Math.imul(k3, ve) | 0, g3 = g3 + Math.imul(k3, be) | 0, g3 = g3 + Math.imul(D2, ve) | 0, _3 = _3 + Math.imul(D2, be) | 0, w = w + Math.imul(R2, Be) | 0, g3 = g3 + Math.imul(R2, qe) | 0, g3 = g3 + Math.imul(I3, Be) | 0, _3 = _3 + Math.imul(I3, qe) | 0;
        var Ye = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w = Math.imul(X3, te), g3 = Math.imul(X3, re), g3 = g3 + Math.imul(J2, te) | 0, _3 = Math.imul(J2, re), w = w + Math.imul(G2, ie) | 0, g3 = g3 + Math.imul(G2, ne) | 0, g3 = g3 + Math.imul(Y2, ie) | 0, _3 = _3 + Math.imul(Y2, ne) | 0, w = w + Math.imul(V3, fe) | 0, g3 = g3 + Math.imul(V3, ae) | 0, g3 = g3 + Math.imul($2, fe) | 0, _3 = _3 + Math.imul($2, ae) | 0, w = w + Math.imul(j3, oe) | 0, g3 = g3 + Math.imul(j3, se) | 0, g3 = g3 + Math.imul(Z2, oe) | 0, _3 = _3 + Math.imul(Z2, se) | 0, w = w + Math.imul(W, he) | 0, g3 = g3 + Math.imul(W, ue) | 0, g3 = g3 + Math.imul(K2, he) | 0, _3 = _3 + Math.imul(K2, ue) | 0, w = w + Math.imul(z, le) | 0, g3 = g3 + Math.imul(z, de) | 0, g3 = g3 + Math.imul(H2, le) | 0, _3 = _3 + Math.imul(H2, de) | 0, w = w + Math.imul(F, ce) | 0, g3 = g3 + Math.imul(F, pe) | 0, g3 = g3 + Math.imul(U3, ce) | 0, _3 = _3 + Math.imul(U3, pe) | 0, w = w + Math.imul(C, ve) | 0, g3 = g3 + Math.imul(C, be) | 0, g3 = g3 + Math.imul(O3, ve) | 0, _3 = _3 + Math.imul(O3, be) | 0, w = w + Math.imul(k3, Be) | 0, g3 = g3 + Math.imul(k3, qe) | 0, g3 = g3 + Math.imul(D2, Be) | 0, _3 = _3 + Math.imul(D2, qe) | 0;
        var Xe = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w = Math.imul(X3, ie), g3 = Math.imul(X3, ne), g3 = g3 + Math.imul(J2, ie) | 0, _3 = Math.imul(J2, ne), w = w + Math.imul(G2, fe) | 0, g3 = g3 + Math.imul(G2, ae) | 0, g3 = g3 + Math.imul(Y2, fe) | 0, _3 = _3 + Math.imul(Y2, ae) | 0, w = w + Math.imul(V3, oe) | 0, g3 = g3 + Math.imul(V3, se) | 0, g3 = g3 + Math.imul($2, oe) | 0, _3 = _3 + Math.imul($2, se) | 0, w = w + Math.imul(j3, he) | 0, g3 = g3 + Math.imul(j3, ue) | 0, g3 = g3 + Math.imul(Z2, he) | 0, _3 = _3 + Math.imul(Z2, ue) | 0, w = w + Math.imul(W, le) | 0, g3 = g3 + Math.imul(W, de) | 0, g3 = g3 + Math.imul(K2, le) | 0, _3 = _3 + Math.imul(K2, de) | 0, w = w + Math.imul(z, ce) | 0, g3 = g3 + Math.imul(z, pe) | 0, g3 = g3 + Math.imul(H2, ce) | 0, _3 = _3 + Math.imul(H2, pe) | 0, w = w + Math.imul(F, ve) | 0, g3 = g3 + Math.imul(F, be) | 0, g3 = g3 + Math.imul(U3, ve) | 0, _3 = _3 + Math.imul(U3, be) | 0, w = w + Math.imul(C, Be) | 0, g3 = g3 + Math.imul(C, qe) | 0, g3 = g3 + Math.imul(O3, Be) | 0, _3 = _3 + Math.imul(O3, qe) | 0;
        var Je = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w = Math.imul(X3, fe), g3 = Math.imul(X3, ae), g3 = g3 + Math.imul(J2, fe) | 0, _3 = Math.imul(J2, ae), w = w + Math.imul(G2, oe) | 0, g3 = g3 + Math.imul(G2, se) | 0, g3 = g3 + Math.imul(Y2, oe) | 0, _3 = _3 + Math.imul(Y2, se) | 0, w = w + Math.imul(V3, he) | 0, g3 = g3 + Math.imul(V3, ue) | 0, g3 = g3 + Math.imul($2, he) | 0, _3 = _3 + Math.imul($2, ue) | 0, w = w + Math.imul(j3, le) | 0, g3 = g3 + Math.imul(j3, de) | 0, g3 = g3 + Math.imul(Z2, le) | 0, _3 = _3 + Math.imul(Z2, de) | 0, w = w + Math.imul(W, ce) | 0, g3 = g3 + Math.imul(W, pe) | 0, g3 = g3 + Math.imul(K2, ce) | 0, _3 = _3 + Math.imul(K2, pe) | 0, w = w + Math.imul(z, ve) | 0, g3 = g3 + Math.imul(z, be) | 0, g3 = g3 + Math.imul(H2, ve) | 0, _3 = _3 + Math.imul(H2, be) | 0, w = w + Math.imul(F, Be) | 0, g3 = g3 + Math.imul(F, qe) | 0, g3 = g3 + Math.imul(U3, Be) | 0, _3 = _3 + Math.imul(U3, qe) | 0;
        var Qe = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w = Math.imul(X3, oe), g3 = Math.imul(X3, se), g3 = g3 + Math.imul(J2, oe) | 0, _3 = Math.imul(J2, se), w = w + Math.imul(G2, he) | 0, g3 = g3 + Math.imul(G2, ue) | 0, g3 = g3 + Math.imul(Y2, he) | 0, _3 = _3 + Math.imul(Y2, ue) | 0, w = w + Math.imul(V3, le) | 0, g3 = g3 + Math.imul(V3, de) | 0, g3 = g3 + Math.imul($2, le) | 0, _3 = _3 + Math.imul($2, de) | 0, w = w + Math.imul(j3, ce) | 0, g3 = g3 + Math.imul(j3, pe) | 0, g3 = g3 + Math.imul(Z2, ce) | 0, _3 = _3 + Math.imul(Z2, pe) | 0, w = w + Math.imul(W, ve) | 0, g3 = g3 + Math.imul(W, be) | 0, g3 = g3 + Math.imul(K2, ve) | 0, _3 = _3 + Math.imul(K2, be) | 0, w = w + Math.imul(z, Be) | 0, g3 = g3 + Math.imul(z, qe) | 0, g3 = g3 + Math.imul(H2, Be) | 0, _3 = _3 + Math.imul(H2, qe) | 0;
        var et = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w = Math.imul(X3, he), g3 = Math.imul(X3, ue), g3 = g3 + Math.imul(J2, he) | 0, _3 = Math.imul(J2, ue), w = w + Math.imul(G2, le) | 0, g3 = g3 + Math.imul(G2, de) | 0, g3 = g3 + Math.imul(Y2, le) | 0, _3 = _3 + Math.imul(Y2, de) | 0, w = w + Math.imul(V3, ce) | 0, g3 = g3 + Math.imul(V3, pe) | 0, g3 = g3 + Math.imul($2, ce) | 0, _3 = _3 + Math.imul($2, pe) | 0, w = w + Math.imul(j3, ve) | 0, g3 = g3 + Math.imul(j3, be) | 0, g3 = g3 + Math.imul(Z2, ve) | 0, _3 = _3 + Math.imul(Z2, be) | 0, w = w + Math.imul(W, Be) | 0, g3 = g3 + Math.imul(W, qe) | 0, g3 = g3 + Math.imul(K2, Be) | 0, _3 = _3 + Math.imul(K2, qe) | 0;
        var tt = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, w = Math.imul(X3, le), g3 = Math.imul(X3, de), g3 = g3 + Math.imul(J2, le) | 0, _3 = Math.imul(J2, de), w = w + Math.imul(G2, ce) | 0, g3 = g3 + Math.imul(G2, pe) | 0, g3 = g3 + Math.imul(Y2, ce) | 0, _3 = _3 + Math.imul(Y2, pe) | 0, w = w + Math.imul(V3, ve) | 0, g3 = g3 + Math.imul(V3, be) | 0, g3 = g3 + Math.imul($2, ve) | 0, _3 = _3 + Math.imul($2, be) | 0, w = w + Math.imul(j3, Be) | 0, g3 = g3 + Math.imul(j3, qe) | 0, g3 = g3 + Math.imul(Z2, Be) | 0, _3 = _3 + Math.imul(Z2, qe) | 0;
        var rt = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, w = Math.imul(X3, ce), g3 = Math.imul(X3, pe), g3 = g3 + Math.imul(J2, ce) | 0, _3 = Math.imul(J2, pe), w = w + Math.imul(G2, ve) | 0, g3 = g3 + Math.imul(G2, be) | 0, g3 = g3 + Math.imul(Y2, ve) | 0, _3 = _3 + Math.imul(Y2, be) | 0, w = w + Math.imul(V3, Be) | 0, g3 = g3 + Math.imul(V3, qe) | 0, g3 = g3 + Math.imul($2, Be) | 0, _3 = _3 + Math.imul($2, qe) | 0;
        var S0 = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (S0 >>> 26) | 0, S0 &= 67108863, w = Math.imul(X3, ve), g3 = Math.imul(X3, be), g3 = g3 + Math.imul(J2, ve) | 0, _3 = Math.imul(J2, be), w = w + Math.imul(G2, Be) | 0, g3 = g3 + Math.imul(G2, qe) | 0, g3 = g3 + Math.imul(Y2, Be) | 0, _3 = _3 + Math.imul(Y2, qe) | 0;
        var E0 = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        d2 = (_3 + (g3 >>> 13) | 0) + (E0 >>> 26) | 0, E0 &= 67108863, w = Math.imul(X3, Be), g3 = Math.imul(X3, qe), g3 = g3 + Math.imul(J2, Be) | 0, _3 = Math.imul(J2, qe);
        var A0 = (d2 + w | 0) + ((g3 & 8191) << 13) | 0;
        return d2 = (_3 + (g3 >>> 13) | 0) + (A0 >>> 26) | 0, A0 &= 67108863, n[0] = ze, n[1] = He, n[2] = We, n[3] = Ke, n[4] = je, n[5] = Ze, n[6] = Ve, n[7] = $e, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe, n[13] = et, n[14] = tt, n[15] = rt, n[16] = S0, n[17] = E0, n[18] = A0, d2 !== 0 && (n[19] = d2, c2.length++), c2;
      };
      Math.imul || (N3 = _e);
      function we(h3, s2, u3) {
        u3.negative = s2.negative ^ h3.negative, u3.length = h3.length + s2.length;
        for (var c2 = 0, b2 = 0, l2 = 0;l2 < u3.length - 1; l2++) {
          var n = b2;
          b2 = 0;
          for (var d2 = c2 & 67108863, w = Math.min(l2, s2.length - 1), g3 = Math.max(0, l2 - h3.length + 1);g3 <= w; g3++) {
            var _3 = l2 - g3, A2 = h3.words[_3] | 0, R2 = s2.words[g3] | 0, I3 = A2 * R2, Me = I3 & 67108863;
            n = n + (I3 / 67108864 | 0) | 0, Me = Me + d2 | 0, d2 = Me & 67108863, n = n + (Me >>> 26) | 0, b2 += n >>> 26, n &= 67108863;
          }
          u3.words[l2] = d2, c2 = n, n = b2;
        }
        return c2 !== 0 ? u3.words[l2] = c2 : u3.length--, u3._strip();
      }
      function ye(h3, s2, u3) {
        return we(h3, s2, u3);
      }
      f2.prototype.mulTo = function(s2, u3) {
        var c2, b2 = this.length + s2.length;
        return this.length === 10 && s2.length === 10 ? c2 = N3(this, s2, u3) : b2 < 63 ? c2 = _e(this, s2, u3) : b2 < 1024 ? c2 = we(this, s2, u3) : c2 = ye(this, s2, u3), c2;
      };
      function xe(h3, s2) {
        this.x = h3, this.y = s2;
      }
      xe.prototype.makeRBT = function(s2) {
        for (var u3 = new Array(s2), c2 = f2.prototype._countBits(s2) - 1, b2 = 0;b2 < s2; b2++)
          u3[b2] = this.revBin(b2, c2, s2);
        return u3;
      }, xe.prototype.revBin = function(s2, u3, c2) {
        if (s2 === 0 || s2 === c2 - 1)
          return s2;
        for (var b2 = 0, l2 = 0;l2 < u3; l2++)
          b2 |= (s2 & 1) << u3 - l2 - 1, s2 >>= 1;
        return b2;
      }, xe.prototype.permute = function(s2, u3, c2, b2, l2, n) {
        for (var d2 = 0;d2 < n; d2++)
          b2[d2] = u3[s2[d2]], l2[d2] = c2[s2[d2]];
      }, xe.prototype.transform = function(s2, u3, c2, b2, l2, n) {
        this.permute(n, s2, u3, c2, b2, l2);
        for (var d2 = 1;d2 < l2; d2 <<= 1)
          for (var w = d2 << 1, g3 = Math.cos(2 * Math.PI / w), _3 = Math.sin(2 * Math.PI / w), A2 = 0;A2 < l2; A2 += w)
            for (var R2 = g3, I3 = _3, Me = 0;Me < d2; Me++) {
              var k3 = c2[A2 + Me], D2 = b2[A2 + Me], nt = c2[A2 + Me + d2], C = b2[A2 + Me + d2], O3 = R2 * nt - I3 * C;
              C = R2 * C + I3 * nt, nt = O3, c2[A2 + Me] = k3 + nt, b2[A2 + Me] = D2 + C, c2[A2 + Me + d2] = k3 - nt, b2[A2 + Me + d2] = D2 - C, Me !== w && (O3 = g3 * R2 - _3 * I3, I3 = g3 * I3 + _3 * R2, R2 = O3);
            }
      }, xe.prototype.guessLen13b = function(s2, u3) {
        var c2 = Math.max(u3, s2) | 1, b2 = c2 & 1, l2 = 0;
        for (c2 = c2 / 2 | 0;c2; c2 = c2 >>> 1)
          l2++;
        return 1 << l2 + 1 + b2;
      }, xe.prototype.conjugate = function(s2, u3, c2) {
        if (!(c2 <= 1))
          for (var b2 = 0;b2 < c2 / 2; b2++) {
            var l2 = s2[b2];
            s2[b2] = s2[c2 - b2 - 1], s2[c2 - b2 - 1] = l2, l2 = u3[b2], u3[b2] = -u3[c2 - b2 - 1], u3[c2 - b2 - 1] = -l2;
          }
      }, xe.prototype.normalize13b = function(s2, u3) {
        for (var c2 = 0, b2 = 0;b2 < u3 / 2; b2++) {
          var l2 = Math.round(s2[2 * b2 + 1] / u3) * 8192 + Math.round(s2[2 * b2] / u3) + c2;
          s2[b2] = l2 & 67108863, l2 < 67108864 ? c2 = 0 : c2 = l2 / 67108864 | 0;
        }
        return s2;
      }, xe.prototype.convert13b = function(s2, u3, c2, b2) {
        for (var l2 = 0, n = 0;n < u3; n++)
          l2 = l2 + (s2[n] | 0), c2[2 * n] = l2 & 8191, l2 = l2 >>> 13, c2[2 * n + 1] = l2 & 8191, l2 = l2 >>> 13;
        for (n = 2 * u3;n < b2; ++n)
          c2[n] = 0;
        r(l2 === 0), r((l2 & -8192) === 0);
      }, xe.prototype.stub = function(s2) {
        for (var u3 = new Array(s2), c2 = 0;c2 < s2; c2++)
          u3[c2] = 0;
        return u3;
      }, xe.prototype.mulp = function(s2, u3, c2) {
        var b2 = 2 * this.guessLen13b(s2.length, u3.length), l2 = this.makeRBT(b2), n = this.stub(b2), d2 = new Array(b2), w = new Array(b2), g3 = new Array(b2), _3 = new Array(b2), A2 = new Array(b2), R2 = new Array(b2), I3 = c2.words;
        I3.length = b2, this.convert13b(s2.words, s2.length, d2, b2), this.convert13b(u3.words, u3.length, _3, b2), this.transform(d2, n, w, g3, b2, l2), this.transform(_3, n, A2, R2, b2, l2);
        for (var Me = 0;Me < b2; Me++) {
          var k3 = w[Me] * A2[Me] - g3[Me] * R2[Me];
          g3[Me] = w[Me] * R2[Me] + g3[Me] * A2[Me], w[Me] = k3;
        }
        return this.conjugate(w, g3, b2), this.transform(w, g3, I3, n, b2, l2), this.conjugate(I3, n, b2), this.normalize13b(I3, b2), c2.negative = s2.negative ^ u3.negative, c2.length = s2.length + u3.length, c2._strip();
      }, f2.prototype.mul = function(s2) {
        var u3 = new f2(null);
        return u3.words = new Array(this.length + s2.length), this.mulTo(s2, u3);
      }, f2.prototype.mulf = function(s2) {
        var u3 = new f2(null);
        return u3.words = new Array(this.length + s2.length), ye(this, s2, u3);
      }, f2.prototype.imul = function(s2) {
        return this.clone().mulTo(s2, this);
      }, f2.prototype.imuln = function(s2) {
        var u3 = s2 < 0;
        u3 && (s2 = -s2), r(typeof s2 == "number"), r(s2 < 67108864);
        for (var c2 = 0, b2 = 0;b2 < this.length; b2++) {
          var l2 = (this.words[b2] | 0) * s2, n = (l2 & 67108863) + (c2 & 67108863);
          c2 >>= 26, c2 += l2 / 67108864 | 0, c2 += n >>> 26, this.words[b2] = n & 67108863;
        }
        return c2 !== 0 && (this.words[b2] = c2, this.length++), u3 ? this.ineg() : this;
      }, f2.prototype.muln = function(s2) {
        return this.clone().imuln(s2);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(s2) {
        var u3 = ge(s2);
        if (u3.length === 0)
          return new f2(1);
        for (var c2 = this, b2 = 0;b2 < u3.length && u3[b2] === 0; b2++, c2 = c2.sqr())
          ;
        if (++b2 < u3.length)
          for (var l2 = c2.sqr();b2 < u3.length; b2++, l2 = l2.sqr())
            u3[b2] !== 0 && (c2 = c2.mul(l2));
        return c2;
      }, f2.prototype.iushln = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u3 = s2 % 26, c2 = (s2 - u3) / 26, b2 = 67108863 >>> 26 - u3 << 26 - u3, l2;
        if (u3 !== 0) {
          var n = 0;
          for (l2 = 0;l2 < this.length; l2++) {
            var d2 = this.words[l2] & b2, w = (this.words[l2] | 0) - d2 << u3;
            this.words[l2] = w | n, n = d2 >>> 26 - u3;
          }
          n && (this.words[l2] = n, this.length++);
        }
        if (c2 !== 0) {
          for (l2 = this.length - 1;l2 >= 0; l2--)
            this.words[l2 + c2] = this.words[l2];
          for (l2 = 0;l2 < c2; l2++)
            this.words[l2] = 0;
          this.length += c2;
        }
        return this._strip();
      }, f2.prototype.ishln = function(s2) {
        return r(this.negative === 0), this.iushln(s2);
      }, f2.prototype.iushrn = function(s2, u3, c2) {
        r(typeof s2 == "number" && s2 >= 0);
        var b2;
        u3 ? b2 = (u3 - u3 % 26) / 26 : b2 = 0;
        var l2 = s2 % 26, n = Math.min((s2 - l2) / 26, this.length), d2 = 67108863 ^ 67108863 >>> l2 << l2, w = c2;
        if (b2 -= n, b2 = Math.max(0, b2), w) {
          for (var g3 = 0;g3 < n; g3++)
            w.words[g3] = this.words[g3];
          w.length = n;
        }
        if (n !== 0)
          if (this.length > n)
            for (this.length -= n, g3 = 0;g3 < this.length; g3++)
              this.words[g3] = this.words[g3 + n];
          else
            this.words[0] = 0, this.length = 1;
        var _3 = 0;
        for (g3 = this.length - 1;g3 >= 0 && (_3 !== 0 || g3 >= b2); g3--) {
          var A2 = this.words[g3] | 0;
          this.words[g3] = _3 << 26 - l2 | A2 >>> l2, _3 = A2 & d2;
        }
        return w && _3 !== 0 && (w.words[w.length++] = _3), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, f2.prototype.ishrn = function(s2, u3, c2) {
        return r(this.negative === 0), this.iushrn(s2, u3, c2);
      }, f2.prototype.shln = function(s2) {
        return this.clone().ishln(s2);
      }, f2.prototype.ushln = function(s2) {
        return this.clone().iushln(s2);
      }, f2.prototype.shrn = function(s2) {
        return this.clone().ishrn(s2);
      }, f2.prototype.ushrn = function(s2) {
        return this.clone().iushrn(s2);
      }, f2.prototype.testn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u3 = s2 % 26, c2 = (s2 - u3) / 26, b2 = 1 << u3;
        if (this.length <= c2)
          return false;
        var l2 = this.words[c2];
        return !!(l2 & b2);
      }, f2.prototype.imaskn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u3 = s2 % 26, c2 = (s2 - u3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c2)
          return this;
        if (u3 !== 0 && c2++, this.length = Math.min(c2, this.length), u3 !== 0) {
          var b2 = 67108863 ^ 67108863 >>> u3 << u3;
          this.words[this.length - 1] &= b2;
        }
        return this._strip();
      }, f2.prototype.maskn = function(s2) {
        return this.clone().imaskn(s2);
      }, f2.prototype.iaddn = function(s2) {
        return r(typeof s2 == "number"), r(s2 < 67108864), s2 < 0 ? this.isubn(-s2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s2 ? (this.words[0] = s2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s2), this.negative = 1, this) : this._iaddn(s2);
      }, f2.prototype._iaddn = function(s2) {
        this.words[0] += s2;
        for (var u3 = 0;u3 < this.length && this.words[u3] >= 67108864; u3++)
          this.words[u3] -= 67108864, u3 === this.length - 1 ? this.words[u3 + 1] = 1 : this.words[u3 + 1]++;
        return this.length = Math.max(this.length, u3 + 1), this;
      }, f2.prototype.isubn = function(s2) {
        if (r(typeof s2 == "number"), r(s2 < 67108864), s2 < 0)
          return this.iaddn(-s2);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(s2), this.negative = 1, this;
        if (this.words[0] -= s2, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var u3 = 0;u3 < this.length && this.words[u3] < 0; u3++)
            this.words[u3] += 67108864, this.words[u3 + 1] -= 1;
        return this._strip();
      }, f2.prototype.addn = function(s2) {
        return this.clone().iaddn(s2);
      }, f2.prototype.subn = function(s2) {
        return this.clone().isubn(s2);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(s2, u3, c2) {
        var b2 = s2.length + c2, l2;
        this._expand(b2);
        var n, d2 = 0;
        for (l2 = 0;l2 < s2.length; l2++) {
          n = (this.words[l2 + c2] | 0) + d2;
          var w = (s2.words[l2] | 0) * u3;
          n -= w & 67108863, d2 = (n >> 26) - (w / 67108864 | 0), this.words[l2 + c2] = n & 67108863;
        }
        for (;l2 < this.length - c2; l2++)
          n = (this.words[l2 + c2] | 0) + d2, d2 = n >> 26, this.words[l2 + c2] = n & 67108863;
        if (d2 === 0)
          return this._strip();
        for (r(d2 === -1), d2 = 0, l2 = 0;l2 < this.length; l2++)
          n = -(this.words[l2] | 0) + d2, d2 = n >> 26, this.words[l2] = n & 67108863;
        return this.negative = 1, this._strip();
      }, f2.prototype._wordDiv = function(s2, u3) {
        var c2 = this.length - s2.length, b2 = this.clone(), l2 = s2, n = l2.words[l2.length - 1] | 0, d2 = this._countBits(n);
        c2 = 26 - d2, c2 !== 0 && (l2 = l2.ushln(c2), b2.iushln(c2), n = l2.words[l2.length - 1] | 0);
        var w = b2.length - l2.length, g3;
        if (u3 !== "mod") {
          g3 = new f2(null), g3.length = w + 1, g3.words = new Array(g3.length);
          for (var _3 = 0;_3 < g3.length; _3++)
            g3.words[_3] = 0;
        }
        var A2 = b2.clone()._ishlnsubmul(l2, 1, w);
        A2.negative === 0 && (b2 = A2, g3 && (g3.words[w] = 1));
        for (var R2 = w - 1;R2 >= 0; R2--) {
          var I3 = (b2.words[l2.length + R2] | 0) * 67108864 + (b2.words[l2.length + R2 - 1] | 0);
          for (I3 = Math.min(I3 / n | 0, 67108863), b2._ishlnsubmul(l2, I3, R2);b2.negative !== 0; )
            I3--, b2.negative = 0, b2._ishlnsubmul(l2, 1, R2), b2.isZero() || (b2.negative ^= 1);
          g3 && (g3.words[R2] = I3);
        }
        return g3 && g3._strip(), b2._strip(), u3 !== "div" && c2 !== 0 && b2.iushrn(c2), { div: g3 || null, mod: b2 };
      }, f2.prototype.divmod = function(s2, u3, c2) {
        if (r(!s2.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var b2, l2, n;
        return this.negative !== 0 && s2.negative === 0 ? (n = this.neg().divmod(s2, u3), u3 !== "mod" && (b2 = n.div.neg()), u3 !== "div" && (l2 = n.mod.neg(), c2 && l2.negative !== 0 && l2.iadd(s2)), { div: b2, mod: l2 }) : this.negative === 0 && s2.negative !== 0 ? (n = this.divmod(s2.neg(), u3), u3 !== "mod" && (b2 = n.div.neg()), { div: b2, mod: n.mod }) : (this.negative & s2.negative) !== 0 ? (n = this.neg().divmod(s2.neg(), u3), u3 !== "div" && (l2 = n.mod.neg(), c2 && l2.negative !== 0 && l2.isub(s2)), { div: n.div, mod: l2 }) : s2.length > this.length || this.cmp(s2) < 0 ? { div: new f2(0), mod: this } : s2.length === 1 ? u3 === "div" ? { div: this.divn(s2.words[0]), mod: null } : u3 === "mod" ? { div: null, mod: new f2(this.modrn(s2.words[0])) } : { div: this.divn(s2.words[0]), mod: new f2(this.modrn(s2.words[0])) } : this._wordDiv(s2, u3);
      }, f2.prototype.div = function(s2) {
        return this.divmod(s2, "div", false).div;
      }, f2.prototype.mod = function(s2) {
        return this.divmod(s2, "mod", false).mod;
      }, f2.prototype.umod = function(s2) {
        return this.divmod(s2, "mod", true).mod;
      }, f2.prototype.divRound = function(s2) {
        var u3 = this.divmod(s2);
        if (u3.mod.isZero())
          return u3.div;
        var c2 = u3.div.negative !== 0 ? u3.mod.isub(s2) : u3.mod, b2 = s2.ushrn(1), l2 = s2.andln(1), n = c2.cmp(b2);
        return n < 0 || l2 === 1 && n === 0 ? u3.div : u3.div.negative !== 0 ? u3.div.isubn(1) : u3.div.iaddn(1);
      }, f2.prototype.modrn = function(s2) {
        var u3 = s2 < 0;
        u3 && (s2 = -s2), r(s2 <= 67108863);
        for (var c2 = (1 << 26) % s2, b2 = 0, l2 = this.length - 1;l2 >= 0; l2--)
          b2 = (c2 * b2 + (this.words[l2] | 0)) % s2;
        return u3 ? -b2 : b2;
      }, f2.prototype.modn = function(s2) {
        return this.modrn(s2);
      }, f2.prototype.idivn = function(s2) {
        var u3 = s2 < 0;
        u3 && (s2 = -s2), r(s2 <= 67108863);
        for (var c2 = 0, b2 = this.length - 1;b2 >= 0; b2--) {
          var l2 = (this.words[b2] | 0) + c2 * 67108864;
          this.words[b2] = l2 / s2 | 0, c2 = l2 % s2;
        }
        return this._strip(), u3 ? this.ineg() : this;
      }, f2.prototype.divn = function(s2) {
        return this.clone().idivn(s2);
      }, f2.prototype.egcd = function(s2) {
        r(s2.negative === 0), r(!s2.isZero());
        var u3 = this, c2 = s2.clone();
        u3.negative !== 0 ? u3 = u3.umod(s2) : u3 = u3.clone();
        for (var b2 = new f2(1), l2 = new f2(0), n = new f2(0), d2 = new f2(1), w = 0;u3.isEven() && c2.isEven(); )
          u3.iushrn(1), c2.iushrn(1), ++w;
        for (var g3 = c2.clone(), _3 = u3.clone();!u3.isZero(); ) {
          for (var A2 = 0, R2 = 1;(u3.words[0] & R2) === 0 && A2 < 26; ++A2, R2 <<= 1)
            ;
          if (A2 > 0)
            for (u3.iushrn(A2);A2-- > 0; )
              (b2.isOdd() || l2.isOdd()) && (b2.iadd(g3), l2.isub(_3)), b2.iushrn(1), l2.iushrn(1);
          for (var I3 = 0, Me = 1;(c2.words[0] & Me) === 0 && I3 < 26; ++I3, Me <<= 1)
            ;
          if (I3 > 0)
            for (c2.iushrn(I3);I3-- > 0; )
              (n.isOdd() || d2.isOdd()) && (n.iadd(g3), d2.isub(_3)), n.iushrn(1), d2.iushrn(1);
          u3.cmp(c2) >= 0 ? (u3.isub(c2), b2.isub(n), l2.isub(d2)) : (c2.isub(u3), n.isub(b2), d2.isub(l2));
        }
        return { a: n, b: d2, gcd: c2.iushln(w) };
      }, f2.prototype._invmp = function(s2) {
        r(s2.negative === 0), r(!s2.isZero());
        var u3 = this, c2 = s2.clone();
        u3.negative !== 0 ? u3 = u3.umod(s2) : u3 = u3.clone();
        for (var b2 = new f2(1), l2 = new f2(0), n = c2.clone();u3.cmpn(1) > 0 && c2.cmpn(1) > 0; ) {
          for (var d2 = 0, w = 1;(u3.words[0] & w) === 0 && d2 < 26; ++d2, w <<= 1)
            ;
          if (d2 > 0)
            for (u3.iushrn(d2);d2-- > 0; )
              b2.isOdd() && b2.iadd(n), b2.iushrn(1);
          for (var g3 = 0, _3 = 1;(c2.words[0] & _3) === 0 && g3 < 26; ++g3, _3 <<= 1)
            ;
          if (g3 > 0)
            for (c2.iushrn(g3);g3-- > 0; )
              l2.isOdd() && l2.iadd(n), l2.iushrn(1);
          u3.cmp(c2) >= 0 ? (u3.isub(c2), b2.isub(l2)) : (c2.isub(u3), l2.isub(b2));
        }
        var A2;
        return u3.cmpn(1) === 0 ? A2 = b2 : A2 = l2, A2.cmpn(0) < 0 && A2.iadd(s2), A2;
      }, f2.prototype.gcd = function(s2) {
        if (this.isZero())
          return s2.abs();
        if (s2.isZero())
          return this.abs();
        var u3 = this.clone(), c2 = s2.clone();
        u3.negative = 0, c2.negative = 0;
        for (var b2 = 0;u3.isEven() && c2.isEven(); b2++)
          u3.iushrn(1), c2.iushrn(1);
        do {
          for (;u3.isEven(); )
            u3.iushrn(1);
          for (;c2.isEven(); )
            c2.iushrn(1);
          var l2 = u3.cmp(c2);
          if (l2 < 0) {
            var n = u3;
            u3 = c2, c2 = n;
          } else if (l2 === 0 || c2.cmpn(1) === 0)
            break;
          u3.isub(c2);
        } while (true);
        return c2.iushln(b2);
      }, f2.prototype.invm = function(s2) {
        return this.egcd(s2).a.umod(s2);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(s2) {
        return this.words[0] & s2;
      }, f2.prototype.bincn = function(s2) {
        r(typeof s2 == "number");
        var u3 = s2 % 26, c2 = (s2 - u3) / 26, b2 = 1 << u3;
        if (this.length <= c2)
          return this._expand(c2 + 1), this.words[c2] |= b2, this;
        for (var l2 = b2, n = c2;l2 !== 0 && n < this.length; n++) {
          var d2 = this.words[n] | 0;
          d2 += l2, l2 = d2 >>> 26, d2 &= 67108863, this.words[n] = d2;
        }
        return l2 !== 0 && (this.words[n] = l2, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(s2) {
        var u3 = s2 < 0;
        if (this.negative !== 0 && !u3)
          return -1;
        if (this.negative === 0 && u3)
          return 1;
        this._strip();
        var c2;
        if (this.length > 1)
          c2 = 1;
        else {
          u3 && (s2 = -s2), r(s2 <= 67108863, "Number is too big");
          var b2 = this.words[0] | 0;
          c2 = b2 === s2 ? 0 : b2 < s2 ? -1 : 1;
        }
        return this.negative !== 0 ? -c2 | 0 : c2;
      }, f2.prototype.cmp = function(s2) {
        if (this.negative !== 0 && s2.negative === 0)
          return -1;
        if (this.negative === 0 && s2.negative !== 0)
          return 1;
        var u3 = this.ucmp(s2);
        return this.negative !== 0 ? -u3 | 0 : u3;
      }, f2.prototype.ucmp = function(s2) {
        if (this.length > s2.length)
          return 1;
        if (this.length < s2.length)
          return -1;
        for (var u3 = 0, c2 = this.length - 1;c2 >= 0; c2--) {
          var b2 = this.words[c2] | 0, l2 = s2.words[c2] | 0;
          if (b2 !== l2) {
            b2 < l2 ? u3 = -1 : b2 > l2 && (u3 = 1);
            break;
          }
        }
        return u3;
      }, f2.prototype.gtn = function(s2) {
        return this.cmpn(s2) === 1;
      }, f2.prototype.gt = function(s2) {
        return this.cmp(s2) === 1;
      }, f2.prototype.gten = function(s2) {
        return this.cmpn(s2) >= 0;
      }, f2.prototype.gte = function(s2) {
        return this.cmp(s2) >= 0;
      }, f2.prototype.ltn = function(s2) {
        return this.cmpn(s2) === -1;
      }, f2.prototype.lt = function(s2) {
        return this.cmp(s2) === -1;
      }, f2.prototype.lten = function(s2) {
        return this.cmpn(s2) <= 0;
      }, f2.prototype.lte = function(s2) {
        return this.cmp(s2) <= 0;
      }, f2.prototype.eqn = function(s2) {
        return this.cmpn(s2) === 0;
      }, f2.prototype.eq = function(s2) {
        return this.cmp(s2) === 0;
      }, f2.red = function(s2) {
        return new i(s2);
      }, f2.prototype.toRed = function(s2) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s2.convertTo(this)._forceRed(s2);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(s2) {
        return this.red = s2, this;
      }, f2.prototype.forceRed = function(s2) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(s2);
      }, f2.prototype.redAdd = function(s2) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s2);
      }, f2.prototype.redIAdd = function(s2) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s2);
      }, f2.prototype.redSub = function(s2) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s2);
      }, f2.prototype.redISub = function(s2) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s2);
      }, f2.prototype.redShl = function(s2) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s2);
      }, f2.prototype.redMul = function(s2) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s2), this.red.mul(this, s2);
      }, f2.prototype.redIMul = function(s2) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s2), this.red.imul(this, s2);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(s2) {
        return r(this.red && !s2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s2);
      };
      var Re = { k256: null, p224: null, p192: null, p25519: null };
      function Ee(h3, s2) {
        this.name = h3, this.p = new f2(s2, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ee.prototype._tmp = function() {
        var s2 = new f2(null);
        return s2.words = new Array(Math.ceil(this.n / 13)), s2;
      }, Ee.prototype.ireduce = function(s2) {
        var u3 = s2, c2;
        do
          this.split(u3, this.tmp), u3 = this.imulK(u3), u3 = u3.iadd(this.tmp), c2 = u3.bitLength();
        while (c2 > this.n);
        var b2 = c2 < this.n ? -1 : u3.ucmp(this.p);
        return b2 === 0 ? (u3.words[0] = 0, u3.length = 1) : b2 > 0 ? u3.isub(this.p) : u3.strip !== undefined ? u3.strip() : u3._strip(), u3;
      }, Ee.prototype.split = function(s2, u3) {
        s2.iushrn(this.n, 0, u3);
      }, Ee.prototype.imulK = function(s2) {
        return s2.imul(this.k);
      };
      function Ae() {
        Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(Ae, Ee), Ae.prototype.split = function(s2, u3) {
        for (var c2 = 4194303, b2 = Math.min(s2.length, 9), l2 = 0;l2 < b2; l2++)
          u3.words[l2] = s2.words[l2];
        if (u3.length = b2, s2.length <= 9) {
          s2.words[0] = 0, s2.length = 1;
          return;
        }
        var n = s2.words[9];
        for (u3.words[u3.length++] = n & c2, l2 = 10;l2 < s2.length; l2++) {
          var d2 = s2.words[l2] | 0;
          s2.words[l2 - 10] = (d2 & c2) << 4 | n >>> 22, n = d2;
        }
        n >>>= 22, s2.words[l2 - 10] = n, n === 0 && s2.length > 10 ? s2.length -= 10 : s2.length -= 9;
      }, Ae.prototype.imulK = function(s2) {
        s2.words[s2.length] = 0, s2.words[s2.length + 1] = 0, s2.length += 2;
        for (var u3 = 0, c2 = 0;c2 < s2.length; c2++) {
          var b2 = s2.words[c2] | 0;
          u3 += b2 * 977, s2.words[c2] = u3 & 67108863, u3 = b2 * 64 + (u3 / 67108864 | 0);
        }
        return s2.words[s2.length - 1] === 0 && (s2.length--, s2.words[s2.length - 1] === 0 && s2.length--), s2;
      };
      function P2() {
        Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(P2, Ee);
      function Se() {
        Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Se, Ee);
      function v() {
        Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(v, Ee), v.prototype.imulK = function(s2) {
        for (var u3 = 0, c2 = 0;c2 < s2.length; c2++) {
          var b2 = (s2.words[c2] | 0) * 19 + u3, l2 = b2 & 67108863;
          b2 >>>= 26, s2.words[c2] = l2, u3 = b2;
        }
        return u3 !== 0 && (s2.words[s2.length++] = u3), s2;
      }, f2._prime = function(s2) {
        if (Re[s2])
          return Re[s2];
        var u3;
        if (s2 === "k256")
          u3 = new Ae;
        else if (s2 === "p224")
          u3 = new P2;
        else if (s2 === "p192")
          u3 = new Se;
        else if (s2 === "p25519")
          u3 = new v;
        else
          throw new Error("Unknown prime " + s2);
        return Re[s2] = u3, u3;
      };
      function i(h3) {
        if (typeof h3 == "string") {
          var s2 = f2._prime(h3);
          this.m = s2.p, this.prime = s2;
        } else
          r(h3.gtn(1), "modulus must be greater than 1"), this.m = h3, this.prime = null;
      }
      i.prototype._verify1 = function(s2) {
        r(s2.negative === 0, "red works only with positives"), r(s2.red, "red works only with red numbers");
      }, i.prototype._verify2 = function(s2, u3) {
        r((s2.negative | u3.negative) === 0, "red works only with positives"), r(s2.red && s2.red === u3.red, "red works only with red numbers");
      }, i.prototype.imod = function(s2) {
        return this.prime ? this.prime.ireduce(s2)._forceRed(this) : (x3(s2, s2.umod(this.m)._forceRed(this)), s2);
      }, i.prototype.neg = function(s2) {
        return s2.isZero() ? s2.clone() : this.m.sub(s2)._forceRed(this);
      }, i.prototype.add = function(s2, u3) {
        this._verify2(s2, u3);
        var c2 = s2.add(u3);
        return c2.cmp(this.m) >= 0 && c2.isub(this.m), c2._forceRed(this);
      }, i.prototype.iadd = function(s2, u3) {
        this._verify2(s2, u3);
        var c2 = s2.iadd(u3);
        return c2.cmp(this.m) >= 0 && c2.isub(this.m), c2;
      }, i.prototype.sub = function(s2, u3) {
        this._verify2(s2, u3);
        var c2 = s2.sub(u3);
        return c2.cmpn(0) < 0 && c2.iadd(this.m), c2._forceRed(this);
      }, i.prototype.isub = function(s2, u3) {
        this._verify2(s2, u3);
        var c2 = s2.isub(u3);
        return c2.cmpn(0) < 0 && c2.iadd(this.m), c2;
      }, i.prototype.shl = function(s2, u3) {
        return this._verify1(s2), this.imod(s2.ushln(u3));
      }, i.prototype.imul = function(s2, u3) {
        return this._verify2(s2, u3), this.imod(s2.imul(u3));
      }, i.prototype.mul = function(s2, u3) {
        return this._verify2(s2, u3), this.imod(s2.mul(u3));
      }, i.prototype.isqr = function(s2) {
        return this.imul(s2, s2.clone());
      }, i.prototype.sqr = function(s2) {
        return this.mul(s2, s2);
      }, i.prototype.sqrt = function(s2) {
        if (s2.isZero())
          return s2.clone();
        var u3 = this.m.andln(3);
        if (r(u3 % 2 === 1), u3 === 3) {
          var c2 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(s2, c2);
        }
        for (var b2 = this.m.subn(1), l2 = 0;!b2.isZero() && b2.andln(1) === 0; )
          l2++, b2.iushrn(1);
        r(!b2.isZero());
        var n = new f2(1).toRed(this), d2 = n.redNeg(), w = this.m.subn(1).iushrn(1), g3 = this.m.bitLength();
        for (g3 = new f2(2 * g3 * g3).toRed(this);this.pow(g3, w).cmp(d2) !== 0; )
          g3.redIAdd(d2);
        for (var _3 = this.pow(g3, b2), A2 = this.pow(s2, b2.addn(1).iushrn(1)), R2 = this.pow(s2, b2), I3 = l2;R2.cmp(n) !== 0; ) {
          for (var Me = R2, k3 = 0;Me.cmp(n) !== 0; k3++)
            Me = Me.redSqr();
          r(k3 < I3);
          var D2 = this.pow(_3, new f2(1).iushln(I3 - k3 - 1));
          A2 = A2.redMul(D2), _3 = D2.redSqr(), R2 = R2.redMul(_3), I3 = k3;
        }
        return A2;
      }, i.prototype.invm = function(s2) {
        var u3 = s2._invmp(this.m);
        return u3.negative !== 0 ? (u3.negative = 0, this.imod(u3).redNeg()) : this.imod(u3);
      }, i.prototype.pow = function(s2, u3) {
        if (u3.isZero())
          return new f2(1).toRed(this);
        if (u3.cmpn(1) === 0)
          return s2.clone();
        var c2 = 4, b2 = new Array(1 << c2);
        b2[0] = new f2(1).toRed(this), b2[1] = s2;
        for (var l2 = 2;l2 < b2.length; l2++)
          b2[l2] = this.mul(b2[l2 - 1], s2);
        var n = b2[0], d2 = 0, w = 0, g3 = u3.bitLength() % 26;
        for (g3 === 0 && (g3 = 26), l2 = u3.length - 1;l2 >= 0; l2--) {
          for (var _3 = u3.words[l2], A2 = g3 - 1;A2 >= 0; A2--) {
            var R2 = _3 >> A2 & 1;
            if (n !== b2[0] && (n = this.sqr(n)), R2 === 0 && d2 === 0) {
              w = 0;
              continue;
            }
            d2 <<= 1, d2 |= R2, w++, !(w !== c2 && (l2 !== 0 || A2 !== 0)) && (n = this.mul(n, b2[d2]), w = 0, d2 = 0);
          }
          g3 = 26;
        }
        return n;
      }, i.prototype.convertTo = function(s2) {
        var u3 = s2.umod(this.m);
        return u3 === s2 ? u3.clone() : u3;
      }, i.prototype.convertFrom = function(s2) {
        var u3 = s2.clone();
        return u3.red = null, u3;
      }, f2.mont = function(s2) {
        return new a2(s2);
      };
      function a2(h3) {
        i.call(this, h3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(a2, i), a2.prototype.convertTo = function(s2) {
        return this.imod(s2.ushln(this.shift));
      }, a2.prototype.convertFrom = function(s2) {
        var u3 = this.imod(s2.mul(this.rinv));
        return u3.red = null, u3;
      }, a2.prototype.imul = function(s2, u3) {
        if (s2.isZero() || u3.isZero())
          return s2.words[0] = 0, s2.length = 1, s2;
        var c2 = s2.imul(u3), b2 = c2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l2 = c2.isub(b2).iushrn(this.shift), n = l2;
        return l2.cmp(this.m) >= 0 ? n = l2.isub(this.m) : l2.cmpn(0) < 0 && (n = l2.iadd(this.m)), n._forceRed(this);
      }, a2.prototype.mul = function(s2, u3) {
        if (s2.isZero() || u3.isZero())
          return new f2(0)._forceRed(this);
        var c2 = s2.mul(u3), b2 = c2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l2 = c2.isub(b2).iushrn(this.shift), n = l2;
        return l2.cmp(this.m) >= 0 ? n = l2.isub(this.m) : l2.cmpn(0) < 0 && (n = l2.iadd(this.m)), n._forceRed(this);
      }, a2.prototype.invm = function(s2) {
        var u3 = this.imod(s2._invmp(this.m).mul(this.r2));
        return u3._forceRed(this);
      };
    })(typeof kl > "u" || kl, n2);
  });
  Ks = T2((yk, o2) => {
    var Rf = Ws(), oA = on();
    function sA(t) {
      var e = f2(t), r = e.toRed(Rf.mont(t.modulus)).redPow(new Rf(t.publicExponent)).fromRed();
      return { blinder: r, unblinder: e.invm(t.modulus) };
    }
    function f2(t) {
      var e = t.modulus.byteLength(), r;
      do
        r = new Rf(oA(e));
      while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
      return r;
    }
    function a2(t, e) {
      var r = sA(e), o = e.modulus.byteLength(), f3 = new Rf(t).mul(r.blinder).umod(e.modulus), p2 = f3.toRed(Rf.mont(e.prime1)), m2 = f3.toRed(Rf.mont(e.prime2)), y3 = e.coefficient, M2 = e.prime1, x3 = e.prime2, S2 = p2.redPow(e.exponent1).fromRed(), E3 = m2.redPow(e.exponent2).fromRed(), B3 = S2.isub(E3).imul(y3).umod(M2).imul(x3);
      return E3.iadd(B3).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", o);
    }
    a2.getr = f2;
    o2.exports = a2;
  });
  s2 = T2((wk, hA) => {
    hA.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  ri = T2((h22, Ll) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a2 = function() {
        };
        a2.prototype = i.prototype, v.prototype = new a2, v.prototype.constructor = v;
      }
      function f2(v, i, a2) {
        if (f2.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v || 0, i || 10, a2 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a2) {
        return i.cmp(a2) > 0 ? i : a2;
      }, f2.min = function(i, a2) {
        return i.cmp(a2) < 0 ? i : a2;
      }, f2.prototype._init = function(i, a2, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a2, h3);
        if (typeof i == "object")
          return this._initArray(i, a2, h3);
        a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a2 === 16 ? this._parseHex(i, s3, h3) : (this._parseBase(i, a2, s3), h3 === "le" && this._initArray(this.toArray(), a2, h3)));
      }, f2.prototype._initNumber = function(i, a2, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a2, h3);
      }, f2.prototype._initArray = function(i, a2, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3, c2, b2 = 0;
        if (h3 === "be")
          for (s3 = i.length - 1, u3 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u3] |= c2 << b2 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u3++);
        else if (h3 === "le")
          for (s3 = 0, u3 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u3] |= c2 << b2 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u3++);
        return this.strip();
      };
      function m2(v, i) {
        var a2 = v.charCodeAt(i);
        return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
      }
      function y3(v, i, a2) {
        var h3 = m2(v, a2);
        return a2 - 1 >= i && (h3 |= m2(v, a2 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a2, h3) {
        this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3 = 0, c2 = 0, b2;
        if (h3 === "be")
          for (s3 = i.length - 1;s3 >= a2; s3 -= 2)
            b2 = y3(i, a2, s3) << u3, this.words[c2] |= b2 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b2 >>> 26) : u3 += 8;
        else {
          var l2 = i.length - a2;
          for (s3 = l2 % 2 === 0 ? a2 + 1 : a2;s3 < i.length; s3 += 2)
            b2 = y3(i, a2, s3) << u3, this.words[c2] |= b2 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b2 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M2(v, i, a2, h3) {
        for (var s3 = 0, u3 = Math.min(v.length, a2), c2 = i;c2 < u3; c2++) {
          var b2 = v.charCodeAt(c2) - 48;
          s3 *= h3, b2 >= 49 ? s3 += b2 - 49 + 10 : b2 >= 17 ? s3 += b2 - 17 + 10 : s3 += b2;
        }
        return s3;
      }
      f2.prototype._parseBase = function(i, a2, h3) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u3 = 1;u3 <= 67108863; u3 *= a2)
          s3++;
        s3--, u3 = u3 / a2 | 0;
        for (var c2 = i.length - h3, b2 = c2 % s3, l2 = Math.min(c2, c2 - b2) + h3, n = 0, d2 = h3;d2 < l2; d2 += s3)
          n = M2(i, d2, d2 + s3, a2), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b2; d2++)
            w *= a2;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a2 = 0;a2 < this.length; a2++)
          i.words[a2] = this.words[a2];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a2) {
        i = i || 10, a2 = a2 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s3 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b2 = this.words[c2], l2 = ((b2 << s3 | u3) & 16777215).toString(16);
            u3 = b2 >>> 24 - s3 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l2.length] + l2 + h3 : h3 = l2 + h3, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u3 !== 0 && (h3 = u3.toString(16) + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d2 = E3[i];
          h3 = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g3 = w.modn(d2).toString(i);
            w = w.idivn(d2), w.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a2) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
      }, f2.prototype.toArray = function(i, a2) {
        return this.toArrayLike(Array, i, a2);
      }, f2.prototype.toArrayLike = function(i, a2, h3) {
        var s3 = this.byteLength(), u3 = h3 || Math.max(1, s3);
        r(s3 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a2 === "le", b2 = new i(u3), l2, n, d2 = this.clone();
        if (c2) {
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b2[n] = l2;
          for (;n < u3; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u3 - s3; n++)
            b2[n] = 0;
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b2[u3 - n - 1] = l2;
        }
        return b2;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a2 = i, h3 = 0;
        return a2 >= 4096 && (h3 += 13, a2 >>>= 13), a2 >= 64 && (h3 += 7, a2 >>>= 7), a2 >= 8 && (h3 += 4, a2 >>>= 4), a2 >= 2 && (h3 += 2, a2 >>>= 2), h3 + a2;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a2 = i, h3 = 0;
        return (a2 & 8191) === 0 && (h3 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h3 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h3 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h3 += 2, a2 >>>= 2), (a2 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a2 = this._countBits(i);
        return (this.length - 1) * 26 + a2;
      };
      function B3(v) {
        for (var i = new Array(v.bitLength()), a2 = 0;a2 < i.length; a2++) {
          var h3 = a2 / 26 | 0, s3 = a2 % 26;
          i[a2] = (v.words[h3] & 1 << s3) >>> s3;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a2 = 0;a2 < this.length; a2++) {
          var h3 = this._zeroBits(this.words[a2]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a2 = 0;a2 < i.length; a2++)
          this.words[a2] = this.words[a2] | i.words[a2];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a2;
        this.length > i.length ? a2 = i : a2 = this;
        for (var h3 = 0;h3 < a2.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a2, h3;
        this.length > i.length ? (a2 = this, h3 = i) : (a2 = i, h3 = this);
        for (var s3 = 0;s3 < h3.length; s3++)
          this.words[s3] = a2.words[s3] ^ h3.words[s3];
        if (this !== a2)
          for (;s3 < a2.length; s3++)
            this.words[s3] = a2.words[s3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a2), h3 > 0 && a2--;
        for (var s3 = 0;s3 < a2; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h3 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a2) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s3 = i % 26;
        return this._expand(h3 + 1), a2 ? this.words[h3] = this.words[h3] | 1 << s3 : this.words[h3] = this.words[h3] & ~(1 << s3), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a2;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
        var h3, s3;
        this.length > i.length ? (h3 = this, s3 = i) : (h3 = i, s3 = this);
        for (var u3 = 0, c2 = 0;c2 < s3.length; c2++)
          a2 = (h3.words[c2] | 0) + (s3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        for (;u3 !== 0 && c2 < h3.length; c2++)
          a2 = (h3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        if (this.length = h3.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a2;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a2 = this.iadd(i);
          return i.negative = 1, a2._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u3;
        h3 > 0 ? (s3 = this, u3 = i) : (s3 = i, u3 = this);
        for (var c2 = 0, b2 = 0;b2 < u3.length; b2++)
          a2 = (s3.words[b2] | 0) - (u3.words[b2] | 0) + c2, c2 = a2 >> 26, this.words[b2] = a2 & 67108863;
        for (;c2 !== 0 && b2 < s3.length; b2++)
          a2 = (s3.words[b2] | 0) + c2, c2 = a2 >> 26, this.words[b2] = a2 & 67108863;
        if (c2 === 0 && b2 < s3.length && s3 !== this)
          for (;b2 < s3.length; b2++)
            this.words[b2] = s3.words[b2];
        return this.length = Math.max(this.length, b2), s3 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q2(v, i, a2) {
        a2.negative = i.negative ^ v.negative;
        var h3 = v.length + i.length | 0;
        a2.length = h3, h3 = h3 - 1 | 0;
        var s3 = v.words[0] | 0, u3 = i.words[0] | 0, c2 = s3 * u3, b2 = c2 & 67108863, l2 = c2 / 67108864 | 0;
        a2.words[0] = b2;
        for (var n = 1;n < h3; n++) {
          for (var d2 = l2 >>> 26, w = l2 & 67108863, g3 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v.length + 1);_3 <= g3; _3++) {
            var A2 = n - _3 | 0;
            s3 = v.words[A2] | 0, u3 = i.words[_3] | 0, c2 = s3 * u3 + w, d2 += c2 / 67108864 | 0, w = c2 & 67108863;
          }
          a2.words[n] = w | 0, l2 = d2 | 0;
        }
        return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
      }
      var L3 = function(i, a2, h3) {
        var s3 = i.words, u3 = a2.words, c2 = h3.words, b2 = 0, l2, n, d2, w = s3[0] | 0, g3 = w & 8191, _3 = w >>> 13, A2 = s3[1] | 0, R2 = A2 & 8191, I3 = A2 >>> 13, Me = s3[2] | 0, k3 = Me & 8191, D2 = Me >>> 13, nt = s3[3] | 0, C = nt & 8191, O3 = nt >>> 13, vt = s3[4] | 0, F = vt & 8191, U3 = vt >>> 13, bt = s3[5] | 0, z = bt & 8191, H2 = bt >>> 13, mt = s3[6] | 0, W = mt & 8191, K2 = mt >>> 13, gt = s3[7] | 0, j3 = gt & 8191, Z2 = gt >>> 13, yt = s3[8] | 0, V3 = yt & 8191, $2 = yt >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y2 = wt >>> 13, Mt = u3[0] | 0, X3 = Mt & 8191, J2 = Mt >>> 13, _t = u3[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u3[2] | 0, te = xt & 8191, re = xt >>> 13, St = u3[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u3[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u3[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u3[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u3[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u3[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u3[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a2.negative, h3.length = 19, l2 = Math.imul(g3, X3), n = Math.imul(g3, J2), n = n + Math.imul(_3, X3) | 0, d2 = Math.imul(_3, J2);
        var ft = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l2 = Math.imul(R2, X3), n = Math.imul(R2, J2), n = n + Math.imul(I3, X3) | 0, d2 = Math.imul(I3, J2), l2 = l2 + Math.imul(g3, Q2) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_3, Q2) | 0, d2 = d2 + Math.imul(_3, ee) | 0;
        var Be = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k3, X3), n = Math.imul(k3, J2), n = n + Math.imul(D2, X3) | 0, d2 = Math.imul(D2, J2), l2 = l2 + Math.imul(R2, Q2) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I3, Q2) | 0, d2 = d2 + Math.imul(I3, ee) | 0, l2 = l2 + Math.imul(g3, te) | 0, n = n + Math.imul(g3, re) | 0, n = n + Math.imul(_3, te) | 0, d2 = d2 + Math.imul(_3, re) | 0;
        var qe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l2 = Math.imul(C, X3), n = Math.imul(C, J2), n = n + Math.imul(O3, X3) | 0, d2 = Math.imul(O3, J2), l2 = l2 + Math.imul(k3, Q2) | 0, n = n + Math.imul(k3, ee) | 0, n = n + Math.imul(D2, Q2) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R2, te) | 0, n = n + Math.imul(R2, re) | 0, n = n + Math.imul(I3, te) | 0, d2 = d2 + Math.imul(I3, re) | 0, l2 = l2 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_3, ie) | 0, d2 = d2 + Math.imul(_3, ne) | 0;
        var ze = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F, X3), n = Math.imul(F, J2), n = n + Math.imul(U3, X3) | 0, d2 = Math.imul(U3, J2), l2 = l2 + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O3, Q2) | 0, d2 = d2 + Math.imul(O3, ee) | 0, l2 = l2 + Math.imul(k3, te) | 0, n = n + Math.imul(k3, re) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re) | 0, l2 = l2 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I3, ie) | 0, d2 = d2 + Math.imul(I3, ne) | 0, l2 = l2 + Math.imul(g3, fe) | 0, n = n + Math.imul(g3, ae) | 0, n = n + Math.imul(_3, fe) | 0, d2 = d2 + Math.imul(_3, ae) | 0;
        var He = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X3), n = Math.imul(z, J2), n = n + Math.imul(H2, X3) | 0, d2 = Math.imul(H2, J2), l2 = l2 + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U3, Q2) | 0, d2 = d2 + Math.imul(U3, ee) | 0, l2 = l2 + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O3, te) | 0, d2 = d2 + Math.imul(O3, re) | 0, l2 = l2 + Math.imul(k3, ie) | 0, n = n + Math.imul(k3, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R2, fe) | 0, n = n + Math.imul(R2, ae) | 0, n = n + Math.imul(I3, fe) | 0, d2 = d2 + Math.imul(I3, ae) | 0, l2 = l2 + Math.imul(g3, oe) | 0, n = n + Math.imul(g3, se) | 0, n = n + Math.imul(_3, oe) | 0, d2 = d2 + Math.imul(_3, se) | 0;
        var We = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X3), n = Math.imul(W, J2), n = n + Math.imul(K2, X3) | 0, d2 = Math.imul(K2, J2), l2 = l2 + Math.imul(z, Q2) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q2) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U3, te) | 0, d2 = d2 + Math.imul(U3, re) | 0, l2 = l2 + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O3, ie) | 0, d2 = d2 + Math.imul(O3, ne) | 0, l2 = l2 + Math.imul(k3, fe) | 0, n = n + Math.imul(k3, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R2, oe) | 0, n = n + Math.imul(R2, se) | 0, n = n + Math.imul(I3, oe) | 0, d2 = d2 + Math.imul(I3, se) | 0, l2 = l2 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue) | 0, n = n + Math.imul(_3, he) | 0, d2 = d2 + Math.imul(_3, ue) | 0;
        var Ke = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j3, X3), n = Math.imul(j3, J2), n = n + Math.imul(Z2, X3) | 0, d2 = Math.imul(Z2, J2), l2 = l2 + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q2) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re) | 0, l2 = l2 + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U3, ie) | 0, d2 = d2 + Math.imul(U3, ne) | 0, l2 = l2 + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O3, fe) | 0, d2 = d2 + Math.imul(O3, ae) | 0, l2 = l2 + Math.imul(k3, oe) | 0, n = n + Math.imul(k3, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue) | 0, n = n + Math.imul(I3, he) | 0, d2 = d2 + Math.imul(I3, ue) | 0, l2 = l2 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_3, le) | 0, d2 = d2 + Math.imul(_3, de) | 0;
        var je = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X3), n = Math.imul(V3, J2), n = n + Math.imul($2, X3) | 0, d2 = Math.imul($2, J2), l2 = l2 + Math.imul(j3, Q2) | 0, n = n + Math.imul(j3, ee) | 0, n = n + Math.imul(Z2, Q2) | 0, d2 = d2 + Math.imul(Z2, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U3, fe) | 0, d2 = d2 + Math.imul(U3, ae) | 0, l2 = l2 + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O3, oe) | 0, d2 = d2 + Math.imul(O3, se) | 0, l2 = l2 + Math.imul(k3, he) | 0, n = n + Math.imul(k3, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I3, le) | 0, d2 = d2 + Math.imul(I3, de) | 0, l2 = l2 + Math.imul(g3, ce) | 0, n = n + Math.imul(g3, pe) | 0, n = n + Math.imul(_3, ce) | 0, d2 = d2 + Math.imul(_3, pe) | 0;
        var Ze = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G2, X3), n = Math.imul(G2, J2), n = n + Math.imul(Y2, X3) | 0, d2 = Math.imul(Y2, J2), l2 = l2 + Math.imul(V3, Q2) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q2) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j3, te) | 0, n = n + Math.imul(j3, re) | 0, n = n + Math.imul(Z2, te) | 0, d2 = d2 + Math.imul(Z2, re) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U3, oe) | 0, d2 = d2 + Math.imul(U3, se) | 0, l2 = l2 + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O3, he) | 0, d2 = d2 + Math.imul(O3, ue) | 0, l2 = l2 + Math.imul(k3, le) | 0, n = n + Math.imul(k3, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R2, ce) | 0, n = n + Math.imul(R2, pe) | 0, n = n + Math.imul(I3, ce) | 0, d2 = d2 + Math.imul(I3, pe) | 0, l2 = l2 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_3, ve) | 0, d2 = d2 + Math.imul(_3, be) | 0;
        var Ve = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G2, Q2), n = Math.imul(G2, ee), n = n + Math.imul(Y2, Q2) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re) | 0, l2 = l2 + Math.imul(j3, ie) | 0, n = n + Math.imul(j3, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d2 = d2 + Math.imul(Z2, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U3, he) | 0, d2 = d2 + Math.imul(U3, ue) | 0, l2 = l2 + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O3, le) | 0, d2 = d2 + Math.imul(O3, de) | 0, l2 = l2 + Math.imul(k3, ce) | 0, n = n + Math.imul(k3, pe) | 0, n = n + Math.imul(D2, ce) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I3, ve) | 0, d2 = d2 + Math.imul(I3, be) | 0;
        var $e = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G2, te), n = Math.imul(G2, re), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j3, fe) | 0, n = n + Math.imul(j3, ae) | 0, n = n + Math.imul(Z2, fe) | 0, d2 = d2 + Math.imul(Z2, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U3, le) | 0, d2 = d2 + Math.imul(U3, de) | 0, l2 = l2 + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O3, ce) | 0, d2 = d2 + Math.imul(O3, pe) | 0, l2 = l2 + Math.imul(k3, ve) | 0, n = n + Math.imul(k3, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
        var Ge = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j3, oe) | 0, n = n + Math.imul(j3, se) | 0, n = n + Math.imul(Z2, oe) | 0, d2 = d2 + Math.imul(Z2, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U3, ce) | 0, d2 = d2 + Math.imul(U3, pe) | 0, l2 = l2 + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O3, ve) | 0, d2 = d2 + Math.imul(O3, be) | 0;
        var Ye = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G2, fe), n = Math.imul(G2, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j3, he) | 0, n = n + Math.imul(j3, ue) | 0, n = n + Math.imul(Z2, he) | 0, d2 = d2 + Math.imul(Z2, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U3, ve) | 0, d2 = d2 + Math.imul(U3, be) | 0;
        var Xe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G2, oe), n = Math.imul(G2, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j3, le) | 0, n = n + Math.imul(j3, de) | 0, n = n + Math.imul(Z2, le) | 0, d2 = d2 + Math.imul(Z2, de) | 0, l2 = l2 + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
        var Je = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G2, he), n = Math.imul(G2, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j3, ce) | 0, n = n + Math.imul(j3, pe) | 0, n = n + Math.imul(Z2, ce) | 0, d2 = d2 + Math.imul(Z2, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
        var Qe = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j3, ve) | 0, n = n + Math.imul(j3, be) | 0, n = n + Math.imul(Z2, ve) | 0, d2 = d2 + Math.imul(Z2, be) | 0;
        var et = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G2, ce), n = Math.imul(G2, pe), n = n + Math.imul(Y2, ce) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
        var tt = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        b2 = (d2 + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l2 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
        var rt = (b2 + l2 | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d2 + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe, c2[3] = ze, c2[4] = He, c2[5] = We, c2[6] = Ke, c2[7] = je, c2[8] = Ze, c2[9] = Ve, c2[10] = $e, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe, c2[16] = et, c2[17] = tt, c2[18] = rt, b2 !== 0 && (c2[19] = b2, h3.length++), h3;
      };
      Math.imul || (L3 = q2);
      function ge(v, i, a2) {
        a2.negative = i.negative ^ v.negative, a2.length = v.length + i.length;
        for (var h3 = 0, s3 = 0, u3 = 0;u3 < a2.length - 1; u3++) {
          var c2 = s3;
          s3 = 0;
          for (var b2 = h3 & 67108863, l2 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v.length + 1);n <= l2; n++) {
            var d2 = u3 - n, w = v.words[d2] | 0, g3 = i.words[n] | 0, _3 = w * g3, A2 = _3 & 67108863;
            c2 = c2 + (_3 / 67108864 | 0) | 0, A2 = A2 + b2 | 0, b2 = A2 & 67108863, c2 = c2 + (A2 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a2.words[u3] = b2, h3 = c2, c2 = s3;
        }
        return h3 !== 0 ? a2.words[u3] = h3 : a2.length--, a2.strip();
      }
      function _e(v, i, a2) {
        var h3 = new N3;
        return h3.mulp(v, i, a2);
      }
      f2.prototype.mulTo = function(i, a2) {
        var h3, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a2) : s3 < 63 ? h3 = q2(this, i, a2) : s3 < 1024 ? h3 = ge(this, i, a2) : h3 = _e(this, i, a2), h3;
      };
      function N3(v, i) {
        this.x = v, this.y = i;
      }
      N3.prototype.makeRBT = function(i) {
        for (var a2 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a2[s3] = this.revBin(s3, h3, i);
        return a2;
      }, N3.prototype.revBin = function(i, a2, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s3 = 0, u3 = 0;u3 < a2; u3++)
          s3 |= (i & 1) << a2 - u3 - 1, i >>= 1;
        return s3;
      }, N3.prototype.permute = function(i, a2, h3, s3, u3, c2) {
        for (var b2 = 0;b2 < c2; b2++)
          s3[b2] = a2[i[b2]], u3[b2] = h3[i[b2]];
      }, N3.prototype.transform = function(i, a2, h3, s3, u3, c2) {
        this.permute(c2, i, a2, h3, s3, u3);
        for (var b2 = 1;b2 < u3; b2 <<= 1)
          for (var l2 = b2 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w = 0;w < u3; w += l2)
            for (var g3 = n, _3 = d2, A2 = 0;A2 < b2; A2++) {
              var R2 = h3[w + A2], I3 = s3[w + A2], Me = h3[w + A2 + b2], k3 = s3[w + A2 + b2], D2 = g3 * Me - _3 * k3;
              k3 = g3 * k3 + _3 * Me, Me = D2, h3[w + A2] = R2 + Me, s3[w + A2] = I3 + k3, h3[w + A2 + b2] = R2 - Me, s3[w + A2 + b2] = I3 - k3, A2 !== l2 && (D2 = n * g3 - d2 * _3, _3 = n * _3 + d2 * g3, g3 = D2);
            }
      }, N3.prototype.guessLen13b = function(i, a2) {
        var h3 = Math.max(a2, i) | 1, s3 = h3 & 1, u3 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u3++;
        return 1 << u3 + 1 + s3;
      }, N3.prototype.conjugate = function(i, a2, h3) {
        if (!(h3 <= 1))
          for (var s3 = 0;s3 < h3 / 2; s3++) {
            var u3 = i[s3];
            i[s3] = i[h3 - s3 - 1], i[h3 - s3 - 1] = u3, u3 = a2[s3], a2[s3] = -a2[h3 - s3 - 1], a2[h3 - s3 - 1] = -u3;
          }
      }, N3.prototype.normalize13b = function(i, a2) {
        for (var h3 = 0, s3 = 0;s3 < a2 / 2; s3++) {
          var u3 = Math.round(i[2 * s3 + 1] / a2) * 8192 + Math.round(i[2 * s3] / a2) + h3;
          i[s3] = u3 & 67108863, u3 < 67108864 ? h3 = 0 : h3 = u3 / 67108864 | 0;
        }
        return i;
      }, N3.prototype.convert13b = function(i, a2, h3, s3) {
        for (var u3 = 0, c2 = 0;c2 < a2; c2++)
          u3 = u3 + (i[c2] | 0), h3[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h3[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a2;c2 < s3; ++c2)
          h3[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N3.prototype.stub = function(i) {
        for (var a2 = new Array(i), h3 = 0;h3 < i; h3++)
          a2[h3] = 0;
        return a2;
      }, N3.prototype.mulp = function(i, a2, h3) {
        var s3 = 2 * this.guessLen13b(i.length, a2.length), u3 = this.makeRBT(s3), c2 = this.stub(s3), b2 = new Array(s3), l2 = new Array(s3), n = new Array(s3), d2 = new Array(s3), w = new Array(s3), g3 = new Array(s3), _3 = h3.words;
        _3.length = s3, this.convert13b(i.words, i.length, b2, s3), this.convert13b(a2.words, a2.length, d2, s3), this.transform(b2, c2, l2, n, s3, u3), this.transform(d2, c2, w, g3, s3, u3);
        for (var A2 = 0;A2 < s3; A2++) {
          var R2 = l2[A2] * w[A2] - n[A2] * g3[A2];
          n[A2] = l2[A2] * g3[A2] + n[A2] * w[A2], l2[A2] = R2;
        }
        return this.conjugate(l2, n, s3), this.transform(l2, n, _3, c2, s3, u3), this.conjugate(_3, c2, s3), this.normalize13b(_3, s3), h3.negative = i.negative ^ a2.negative, h3.length = i.length + a2.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
      }, f2.prototype.mulf = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), _e(this, i, a2);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a2 = 0, h3 = 0;h3 < this.length; h3++) {
          var s3 = (this.words[h3] | 0) * i, u3 = (s3 & 67108863) + (a2 & 67108863);
          a2 >>= 26, a2 += s3 / 67108864 | 0, a2 += u3 >>> 26, this.words[h3] = u3 & 67108863;
        }
        return a2 !== 0 && (this.words[h3] = a2, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a2 = B3(i);
        if (a2.length === 0)
          return new f2(1);
        for (var h3 = this, s3 = 0;s3 < a2.length && a2[s3] === 0; s3++, h3 = h3.sqr())
          ;
        if (++s3 < a2.length)
          for (var u3 = h3.sqr();s3 < a2.length; s3++, u3 = u3.sqr())
            a2[s3] !== 0 && (h3 = h3.mul(u3));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 67108863 >>> 26 - a2 << 26 - a2, u3;
        if (a2 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b2 = this.words[u3] & s3, l2 = (this.words[u3] | 0) - b2 << a2;
            this.words[u3] = l2 | c2, c2 = b2 >>> 26 - a2;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h3] = this.words[u3];
          for (u3 = 0;u3 < h3; u3++)
            this.words[u3] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a2, h3) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a2 ? s3 = (a2 - a2 % 26) / 26 : s3 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u3 << u3, l2 = h3;
        if (s3 -= c2, s3 = Math.max(0, s3), l2) {
          for (var n = 0;n < c2; n++)
            l2.words[n] = this.words[n];
          l2.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d2 = 0;
        for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s3); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d2 << 26 - u3 | w >>> u3, d2 = w & b2;
        }
        return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a2, h3) {
        return r(this.negative === 0), this.iushrn(i, a2, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 1 << a2;
        if (this.length <= h3)
          return false;
        var u3 = this.words[h3];
        return !!(u3 & s3);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a2 !== 0 && h3++, this.length = Math.min(h3, this.length), a2 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a2 << a2;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
          this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
        return this.length = Math.max(this.length, a2 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
            this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a2, h3) {
        var s3 = i.length + h3, u3;
        this._expand(s3);
        var c2, b2 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h3] | 0) + b2;
          var l2 = (i.words[u3] | 0) * a2;
          c2 -= l2 & 67108863, b2 = (c2 >> 26) - (l2 / 67108864 | 0), this.words[u3 + h3] = c2 & 67108863;
        }
        for (;u3 < this.length - h3; u3++)
          c2 = (this.words[u3 + h3] | 0) + b2, b2 = c2 >> 26, this.words[u3 + h3] = c2 & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b2, b2 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a2) {
        var h3 = this.length - i.length, s3 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b2 = this._countBits(c2);
        h3 = 26 - b2, h3 !== 0 && (u3 = u3.ushln(h3), s3.iushln(h3), c2 = u3.words[u3.length - 1] | 0);
        var l2 = s3.length - u3.length, n;
        if (a2 !== "mod") {
          n = new f2(null), n.length = l2 + 1, n.words = new Array(n.length);
          for (var d2 = 0;d2 < n.length; d2++)
            n.words[d2] = 0;
        }
        var w = s3.clone()._ishlnsubmul(u3, 1, l2);
        w.negative === 0 && (s3 = w, n && (n.words[l2] = 1));
        for (var g3 = l2 - 1;g3 >= 0; g3--) {
          var _3 = (s3.words[u3.length + g3] | 0) * 67108864 + (s3.words[u3.length + g3 - 1] | 0);
          for (_3 = Math.min(_3 / c2 | 0, 67108863), s3._ishlnsubmul(u3, _3, g3);s3.negative !== 0; )
            _3--, s3.negative = 0, s3._ishlnsubmul(u3, 1, g3), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g3] = _3);
        }
        return n && n.strip(), s3.strip(), a2 !== "div" && h3 !== 0 && s3.iushrn(h3), { div: n || null, mod: s3 };
      }, f2.prototype.divmod = function(i, a2, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s3, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a2), a2 !== "mod" && (s3 = c2.div.neg()), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.iadd(i)), { div: s3, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a2), a2 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a2);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a2 = this.divmod(i);
        if (a2.mod.isZero())
          return a2.div;
        var h3 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s3 = i.ushrn(1), u3 = i.andln(1), c2 = h3.cmp(s3);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a2 = (1 << 26) % i, h3 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h3 = (a2 * h3 + (this.words[s3] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = (this.words[h3] | 0) + a2 * 67108864;
          this.words[h3] = s3 / i | 0, a2 = s3 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s3 = new f2(1), u3 = new f2(0), c2 = new f2(0), b2 = new f2(1), l2 = 0;a2.isEven() && h3.isEven(); )
          a2.iushrn(1), h3.iushrn(1), ++l2;
        for (var n = h3.clone(), d2 = a2.clone();!a2.isZero(); ) {
          for (var w = 0, g3 = 1;(a2.words[0] & g3) === 0 && w < 26; ++w, g3 <<= 1)
            ;
          if (w > 0)
            for (a2.iushrn(w);w-- > 0; )
              (s3.isOdd() || u3.isOdd()) && (s3.iadd(n), u3.isub(d2)), s3.iushrn(1), u3.iushrn(1);
          for (var _3 = 0, A2 = 1;(h3.words[0] & A2) === 0 && _3 < 26; ++_3, A2 <<= 1)
            ;
          if (_3 > 0)
            for (h3.iushrn(_3);_3-- > 0; )
              (c2.isOdd() || b2.isOdd()) && (c2.iadd(n), b2.isub(d2)), c2.iushrn(1), b2.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s3.isub(c2), u3.isub(b2)) : (h3.isub(a2), c2.isub(s3), b2.isub(u3));
        }
        return { a: c2, b: b2, gcd: h3.iushln(l2) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s3 = new f2(1), u3 = new f2(0), c2 = h3.clone();a2.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b2 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b2 < 26; ++b2, l2 <<= 1)
            ;
          if (b2 > 0)
            for (a2.iushrn(b2);b2-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d2 = 1;(h3.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s3.isub(u3)) : (h3.isub(a2), u3.isub(s3));
        }
        var w;
        return a2.cmpn(1) === 0 ? w = s3 : w = u3, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a2 = this.clone(), h3 = i.clone();
        a2.negative = 0, h3.negative = 0;
        for (var s3 = 0;a2.isEven() && h3.isEven(); s3++)
          a2.iushrn(1), h3.iushrn(1);
        do {
          for (;a2.isEven(); )
            a2.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u3 = a2.cmp(h3);
          if (u3 < 0) {
            var c2 = a2;
            a2 = h3, h3 = c2;
          } else if (u3 === 0 || h3.cmpn(1) === 0)
            break;
          a2.isub(h3);
        } while (true);
        return h3.iushln(s3);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 1 << a2;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s3, this;
        for (var u3 = s3, c2 = h3;u3 !== 0 && c2 < this.length; c2++) {
          var b2 = this.words[c2] | 0;
          b2 += u3, u3 = b2 >>> 26, b2 &= 67108863, this.words[c2] = b2;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a2 = i < 0;
        if (this.negative !== 0 && !a2)
          return -1;
        if (this.negative === 0 && a2)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a2 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h3 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a2 = this.ucmp(i);
        return this.negative !== 0 ? -a2 | 0 : a2;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = this.words[h3] | 0, u3 = i.words[h3] | 0;
          if (s3 !== u3) {
            s3 < u3 ? a2 = -1 : s3 > u3 && (a2 = 1);
            break;
          }
        }
        return a2;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a2 = i, h3;
        do
          this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h3 = a2.bitLength();
        while (h3 > this.n);
        var s3 = h3 < this.n ? -1 : a2.ucmp(this.p);
        return s3 === 0 ? (a2.words[0] = 0, a2.length = 1) : s3 > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
      }, ye.prototype.split = function(i, a2) {
        i.iushrn(this.n, 0, a2);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a2) {
        for (var h3 = 4194303, s3 = Math.min(i.length, 9), u3 = 0;u3 < s3; u3++)
          a2.words[u3] = i.words[u3];
        if (a2.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a2.words[a2.length++] = c2 & h3, u3 = 10;u3 < i.length; u3++) {
          var b2 = i.words[u3] | 0;
          i.words[u3 - 10] = (b2 & h3) << 4 | c2 >>> 22, c2 = b2;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = i.words[h3] | 0;
          a2 += s3 * 977, i.words[h3] = a2 & 67108863, a2 = s3 * 64 + (a2 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = (i.words[h3] | 0) * 19 + a2, u3 = s3 & 67108863;
          s3 >>>= 26, i.words[h3] = u3, a2 = s3;
        }
        return a2 !== 0 && (i.words[i.length++] = a2), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a2;
        if (i === "k256")
          a2 = new xe;
        else if (i === "p224")
          a2 = new Re;
        else if (i === "p192")
          a2 = new Ee;
        else if (i === "p25519")
          a2 = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a2, a2;
      };
      function P2(v) {
        if (typeof v == "string") {
          var i = f2._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a2) {
        r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.add(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.iadd(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.sub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.isub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a2) {
        return this._verify1(i), this.imod(i.ushln(a2));
      }, P2.prototype.imul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.imul(a2));
      }, P2.prototype.mul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.mul(a2));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a2 = this.m.andln(3);
        if (r(a2 % 2 === 1), a2 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s3 = this.m.subn(1), u3 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u3++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f2(1).toRed(this), b2 = c2.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l2).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d2 = this.pow(n, s3), w = this.pow(i, s3.addn(1).iushrn(1)), g3 = this.pow(i, s3), _3 = u3;g3.cmp(c2) !== 0; ) {
          for (var A2 = g3, R2 = 0;A2.cmp(c2) !== 0; R2++)
            A2 = A2.redSqr();
          r(R2 < _3);
          var I3 = this.pow(d2, new f2(1).iushln(_3 - R2 - 1));
          w = w.redMul(I3), d2 = I3.redSqr(), g3 = g3.redMul(d2), _3 = R2;
        }
        return w;
      }, P2.prototype.invm = function(i) {
        var a2 = i._invmp(this.m);
        return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
      }, P2.prototype.pow = function(i, a2) {
        if (a2.isZero())
          return new f2(1).toRed(this);
        if (a2.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s3 = new Array(1 << h3);
        s3[0] = new f2(1).toRed(this), s3[1] = i;
        for (var u3 = 2;u3 < s3.length; u3++)
          s3[u3] = this.mul(s3[u3 - 1], i);
        var c2 = s3[0], b2 = 0, l2 = 0, n = a2.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a2.length - 1;u3 >= 0; u3--) {
          for (var d2 = a2.words[u3], w = n - 1;w >= 0; w--) {
            var g3 = d2 >> w & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g3 === 0 && b2 === 0) {
              l2 = 0;
              continue;
            }
            b2 <<= 1, b2 |= g3, l2++, !(l2 !== h3 && (u3 !== 0 || w !== 0)) && (c2 = this.mul(c2, s3[b2]), l2 = 0, b2 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a2 = i.umod(this.m);
        return a2 === i ? a2.clone() : a2;
      }, P2.prototype.convertFrom = function(i) {
        var a2 = i.clone();
        return a2.red = null, a2;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P2.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a2 = this.imod(i.mul(this.rinv));
        return a2.red = null, a2;
      }, Se.prototype.imul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a2), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.mul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a2), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a2 = this.imod(i._invmp(this.m).mul(this.r2));
        return a2._forceRed(this);
      };
    })(typeof Ll > "u" || Ll, h22);
  });
  Nl = T2((d2) => {
    var js = d2;
    function uA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t != "string") {
        for (var o = 0;o < t.length; o++)
          r[o] = t[o] | 0;
        return r;
      }
      if (e === "hex") {
        t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
        for (var o = 0;o < t.length; o += 2)
          r.push(parseInt(t[o] + t[o + 1], 16));
      } else
        for (var o = 0;o < t.length; o++) {
          var f2 = t.charCodeAt(o), p2 = f2 >> 8, m2 = f2 & 255;
          p2 ? r.push(p2, m2) : r.push(m2);
        }
      return r;
    }
    js.toArray = uA;
    function u22(t) {
      return t.length === 1 ? "0" + t : t;
    }
    js.zero2 = u22;
    function l2(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += u22(t[r].toString(16));
      return e;
    }
    js.toHex = l2;
    js.encode = function(e, r) {
      return r === "hex" ? l2(e) : e;
    };
  });
  or = T2((c2) => {
    var Pr = c2, lA = ri(), dA = ar(), Zs = Nl();
    Pr.assert = dA;
    Pr.toArray = Zs.toArray;
    Pr.zero2 = Zs.zero2;
    Pr.toHex = Zs.toHex;
    Pr.encode = Zs.encode;
    function cA(t, e, r) {
      var o = new Array(Math.max(t.bitLength(), r) + 1);
      o.fill(0);
      for (var f2 = 1 << e + 1, p2 = t.clone(), m2 = 0;m2 < o.length; m2++) {
        var y3, M2 = p2.andln(f2 - 1);
        p2.isOdd() ? (M2 > (f2 >> 1) - 1 ? y3 = (f2 >> 1) - M2 : y3 = M2, p2.isubn(y3)) : y3 = 0, o[m2] = y3, p2.iushrn(1);
      }
      return o;
    }
    Pr.getNAF = cA;
    function pA(t, e) {
      var r = [[], []];
      t = t.clone(), e = e.clone();
      for (var o = 0, f2 = 0, p2;t.cmpn(-o) > 0 || e.cmpn(-f2) > 0; ) {
        var m2 = t.andln(3) + o & 3, y3 = e.andln(3) + f2 & 3;
        m2 === 3 && (m2 = -1), y3 === 3 && (y3 = -1);
        var M2;
        (m2 & 1) === 0 ? M2 = 0 : (p2 = t.andln(7) + o & 7, (p2 === 3 || p2 === 5) && y3 === 2 ? M2 = -m2 : M2 = m2), r[0].push(M2);
        var x3;
        (y3 & 1) === 0 ? x3 = 0 : (p2 = e.andln(7) + f2 & 7, (p2 === 3 || p2 === 5) && m2 === 2 ? x3 = -y3 : x3 = y3), r[1].push(x3), 2 * o === M2 + 1 && (o = 1 - o), 2 * f2 === x3 + 1 && (f2 = 1 - f2), t.iushrn(1), e.iushrn(1);
      }
      return r;
    }
    Pr.getJSF = pA;
    function vA(t, e, r) {
      var o = "_" + e;
      t.prototype[e] = function() {
        return this[o] !== undefined ? this[o] : this[o] = r.call(this);
      };
    }
    Pr.cachedProperty = vA;
    function bA(t) {
      return typeof t == "string" ? Pr.toArray(t, "hex") : t;
    }
    Pr.parseBytes = bA;
    function mA(t) {
      return new lA(t, "hex", "le");
    }
    Pr.intFromLE = mA;
  });
  Oa = T2((xk, p2) => {
    var Cn = ri(), Ca = or(), Vs = Ca.getNAF, gA = Ca.getJSF, $s = Ca.assert;
    function Xi(t, e) {
      this.type = t, this.p = new Cn(e.p, 16), this.red = e.prime ? Cn.red(e.prime) : Cn.mont(this.p), this.zero = new Cn(0).toRed(this.red), this.one = new Cn(1).toRed(this.red), this.two = new Cn(2).toRed(this.red), this.n = e.n && new Cn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    p2.exports = Xi;
    Xi.prototype.point = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype.validate = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype._fixedNafMul = function(e, r) {
      $s(e.precomputed);
      var o = e._getDoubles(), f2 = Vs(r, 1, this._bitLength), p3 = (1 << o.step + 1) - (o.step % 2 === 0 ? 2 : 1);
      p3 /= 3;
      var m2 = [], y3, M2;
      for (y3 = 0;y3 < f2.length; y3 += o.step) {
        M2 = 0;
        for (var x3 = y3 + o.step - 1;x3 >= y3; x3--)
          M2 = (M2 << 1) + f2[x3];
        m2.push(M2);
      }
      for (var S2 = this.jpoint(null, null, null), E3 = this.jpoint(null, null, null), B3 = p3;B3 > 0; B3--) {
        for (y3 = 0;y3 < m2.length; y3++)
          M2 = m2[y3], M2 === B3 ? E3 = E3.mixedAdd(o.points[y3]) : M2 === -B3 && (E3 = E3.mixedAdd(o.points[y3].neg()));
        S2 = S2.add(E3);
      }
      return S2.toP();
    };
    Xi.prototype._wnafMul = function(e, r) {
      var o = 4, f2 = e._getNAFPoints(o);
      o = f2.wnd;
      for (var p3 = f2.points, m2 = Vs(r, o, this._bitLength), y3 = this.jpoint(null, null, null), M2 = m2.length - 1;M2 >= 0; M2--) {
        for (var x3 = 0;M2 >= 0 && m2[M2] === 0; M2--)
          x3++;
        if (M2 >= 0 && x3++, y3 = y3.dblp(x3), M2 < 0)
          break;
        var S2 = m2[M2];
        $s(S2 !== 0), e.type === "affine" ? S2 > 0 ? y3 = y3.mixedAdd(p3[S2 - 1 >> 1]) : y3 = y3.mixedAdd(p3[-S2 - 1 >> 1].neg()) : S2 > 0 ? y3 = y3.add(p3[S2 - 1 >> 1]) : y3 = y3.add(p3[-S2 - 1 >> 1].neg());
      }
      return e.type === "affine" ? y3.toP() : y3;
    };
    Xi.prototype._wnafMulAdd = function(e, r, o, f2, p3) {
      var m2 = this._wnafT1, y3 = this._wnafT2, M2 = this._wnafT3, x3 = 0, S2, E3, B3;
      for (S2 = 0;S2 < f2; S2++) {
        B3 = r[S2];
        var q2 = B3._getNAFPoints(e);
        m2[S2] = q2.wnd, y3[S2] = q2.points;
      }
      for (S2 = f2 - 1;S2 >= 1; S2 -= 2) {
        var L3 = S2 - 1, ge = S2;
        if (m2[L3] !== 1 || m2[ge] !== 1) {
          M2[L3] = Vs(o[L3], m2[L3], this._bitLength), M2[ge] = Vs(o[ge], m2[ge], this._bitLength), x3 = Math.max(M2[L3].length, x3), x3 = Math.max(M2[ge].length, x3);
          continue;
        }
        var _e = [r[L3], null, null, r[ge]];
        r[L3].y.cmp(r[ge].y) === 0 ? (_e[1] = r[L3].add(r[ge]), _e[2] = r[L3].toJ().mixedAdd(r[ge].neg())) : r[L3].y.cmp(r[ge].y.redNeg()) === 0 ? (_e[1] = r[L3].toJ().mixedAdd(r[ge]), _e[2] = r[L3].add(r[ge].neg())) : (_e[1] = r[L3].toJ().mixedAdd(r[ge]), _e[2] = r[L3].toJ().mixedAdd(r[ge].neg()));
        var N3 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = gA(o[L3], o[ge]);
        for (x3 = Math.max(we[0].length, x3), M2[L3] = new Array(x3), M2[ge] = new Array(x3), E3 = 0;E3 < x3; E3++) {
          var ye = we[0][E3] | 0, xe = we[1][E3] | 0;
          M2[L3][E3] = N3[(ye + 1) * 3 + (xe + 1)], M2[ge][E3] = 0, y3[L3] = _e;
        }
      }
      var Re = this.jpoint(null, null, null), Ee = this._wnafT4;
      for (S2 = x3;S2 >= 0; S2--) {
        for (var Ae = 0;S2 >= 0; ) {
          var P2 = true;
          for (E3 = 0;E3 < f2; E3++)
            Ee[E3] = M2[E3][S2] | 0, Ee[E3] !== 0 && (P2 = false);
          if (!P2)
            break;
          Ae++, S2--;
        }
        if (S2 >= 0 && Ae++, Re = Re.dblp(Ae), S2 < 0)
          break;
        for (E3 = 0;E3 < f2; E3++) {
          var Se = Ee[E3];
          Se !== 0 && (Se > 0 ? B3 = y3[E3][Se - 1 >> 1] : Se < 0 && (B3 = y3[E3][-Se - 1 >> 1].neg()), B3.type === "affine" ? Re = Re.mixedAdd(B3) : Re = Re.add(B3));
        }
      }
      for (S2 = 0;S2 < f2; S2++)
        y3[S2] = null;
      return p3 ? Re : Re.toP();
    };
    function _r(t, e) {
      this.curve = t, this.type = e, this.precomputed = null;
    }
    Xi.BasePoint = _r;
    _r.prototype.eq = function() {
      throw new Error("Not implemented");
    };
    _r.prototype.validate = function() {
      return this.curve.validate(this);
    };
    Xi.prototype.decodePoint = function(e, r) {
      e = Ca.toArray(e, r);
      var o = this.p.byteLength();
      if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o) {
        e[0] === 6 ? $s(e[e.length - 1] % 2 === 0) : e[0] === 7 && $s(e[e.length - 1] % 2 === 1);
        var f2 = this.point(e.slice(1, 1 + o), e.slice(1 + o, 1 + 2 * o));
        return f2;
      } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o)
        return this.pointFromX(e.slice(1, 1 + o), e[0] === 3);
      throw new Error("Unknown point format");
    };
    _r.prototype.encodeCompressed = function(e) {
      return this.encode(e, true);
    };
    _r.prototype._encode = function(e) {
      var r = this.curve.p.byteLength(), o = this.getX().toArray("be", r);
      return e ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", r));
    };
    _r.prototype.encode = function(e, r) {
      return Ca.encode(this._encode(r), e);
    };
    _r.prototype.precompute = function(e) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
    };
    _r.prototype._hasDoubles = function(e) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
    };
    _r.prototype._getDoubles = function(e, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var o = [this], f2 = this, p3 = 0;p3 < r; p3 += e) {
        for (var m2 = 0;m2 < e; m2++)
          f2 = f2.dbl();
        o.push(f2);
      }
      return { step: e, points: o };
    };
    _r.prototype._getNAFPoints = function(e) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], o = (1 << e) - 1, f2 = o === 1 ? null : this.dbl(), p3 = 1;p3 < o; p3++)
        r[p3] = r[p3 - 1].add(f2);
      return { wnd: e, points: r };
    };
    _r.prototype._getBeta = function() {
      return null;
    };
    _r.prototype.dblp = function(e) {
      for (var r = this, o = 0;o < e; o++)
        r = r.dbl();
      return r;
    };
  });
  b2 = T2((Sk, v2) => {
    var yA = or(), lt = ri(), Dl = Ie(), Bf = Oa(), wA = yA.assert;
    function xr(t) {
      Bf.call(this, "short", t), this.a = new lt(t.a, 16).toRed(this.red), this.b = new lt(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Dl(xr, Bf);
    v2.exports = xr;
    xr.prototype._getEndomorphism = function(e) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, o;
        if (e.beta)
          r = new lt(e.beta, 16).toRed(this.red);
        else {
          var f2 = this._getEndoRoots(this.p);
          r = f2[0].cmp(f2[1]) < 0 ? f2[0] : f2[1], r = r.toRed(this.red);
        }
        if (e.lambda)
          o = new lt(e.lambda, 16);
        else {
          var p2 = this._getEndoRoots(this.n);
          this.g.mul(p2[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o = p2[0] : (o = p2[1], wA(this.g.mul(o).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var m2;
        return e.basis ? m2 = e.basis.map(function(y3) {
          return { a: new lt(y3.a, 16), b: new lt(y3.b, 16) };
        }) : m2 = this._getEndoBasis(o), { beta: r, lambda: o, basis: m2 };
      }
    };
    xr.prototype._getEndoRoots = function(e) {
      var r = e === this.p ? this.red : lt.mont(e), o = new lt(2).toRed(r).redInvm(), f2 = o.redNeg(), p2 = new lt(3).toRed(r).redNeg().redSqrt().redMul(o), m2 = f2.redAdd(p2).fromRed(), y3 = f2.redSub(p2).fromRed();
      return [m2, y3];
    };
    xr.prototype._getEndoBasis = function(e) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o = e, f2 = this.n.clone(), p2 = new lt(1), m2 = new lt(0), y3 = new lt(0), M2 = new lt(1), x3, S2, E3, B3, q2, L3, ge, _e = 0, N3, we;o.cmpn(0) !== 0; ) {
        var ye = f2.div(o);
        N3 = f2.sub(ye.mul(o)), we = y3.sub(ye.mul(p2));
        var xe = M2.sub(ye.mul(m2));
        if (!E3 && N3.cmp(r) < 0)
          x3 = ge.neg(), S2 = p2, E3 = N3.neg(), B3 = we;
        else if (E3 && ++_e === 2)
          break;
        ge = N3, f2 = o, o = N3, y3 = p2, p2 = we, M2 = m2, m2 = xe;
      }
      q2 = N3.neg(), L3 = we;
      var Re = E3.sqr().add(B3.sqr()), Ee = q2.sqr().add(L3.sqr());
      return Ee.cmp(Re) >= 0 && (q2 = x3, L3 = S2), E3.negative && (E3 = E3.neg(), B3 = B3.neg()), q2.negative && (q2 = q2.neg(), L3 = L3.neg()), [{ a: E3, b: B3 }, { a: q2, b: L3 }];
    };
    xr.prototype._endoSplit = function(e) {
      var r = this.endo.basis, o = r[0], f2 = r[1], p2 = f2.b.mul(e).divRound(this.n), m2 = o.b.neg().mul(e).divRound(this.n), y3 = p2.mul(o.a), M2 = m2.mul(f2.a), x3 = p2.mul(o.b), S2 = m2.mul(f2.b), E3 = e.sub(y3).sub(M2), B3 = x3.add(S2).neg();
      return { k1: E3, k2: B3 };
    };
    xr.prototype.pointFromX = function(e, r) {
      e = new lt(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), f2 = o.redSqrt();
      if (f2.redSqr().redSub(o).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var p2 = f2.fromRed().isOdd();
      return (r && !p2 || !r && p2) && (f2 = f2.redNeg()), this.point(e, f2);
    };
    xr.prototype.validate = function(e) {
      if (e.inf)
        return true;
      var { x: r, y: o } = e, f2 = this.a.redMul(r), p2 = r.redSqr().redMul(r).redIAdd(f2).redIAdd(this.b);
      return o.redSqr().redISub(p2).cmpn(0) === 0;
    };
    xr.prototype._endoWnafMulAdd = function(e, r, o) {
      for (var f2 = this._endoWnafT1, p2 = this._endoWnafT2, m2 = 0;m2 < e.length; m2++) {
        var y3 = this._endoSplit(r[m2]), M2 = e[m2], x3 = M2._getBeta();
        y3.k1.negative && (y3.k1.ineg(), M2 = M2.neg(true)), y3.k2.negative && (y3.k2.ineg(), x3 = x3.neg(true)), f2[m2 * 2] = M2, f2[m2 * 2 + 1] = x3, p2[m2 * 2] = y3.k1, p2[m2 * 2 + 1] = y3.k2;
      }
      for (var S2 = this._wnafMulAdd(1, f2, p2, m2 * 2, o), E3 = 0;E3 < m2 * 2; E3++)
        f2[E3] = null, p2[E3] = null;
      return S2;
    };
    function Ct(t, e, r, o) {
      Bf.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt(e, 16), this.y = new lt(r, 16), o && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Dl(Ct, Bf.BasePoint);
    xr.prototype.point = function(e, r, o) {
      return new Ct(this, e, r, o);
    };
    xr.prototype.pointFromJSON = function(e, r) {
      return Ct.fromJSON(this, e, r);
    };
    Ct.prototype._getBeta = function() {
      if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta)
          return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
          var o = this.curve, f2 = function(p2) {
            return o.point(p2.x.redMul(o.endo.beta), p2.y);
          };
          e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(f2) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(f2) } };
        }
        return r;
      }
    };
    Ct.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    };
    Ct.fromJSON = function(e, r, o) {
      typeof r == "string" && (r = JSON.parse(r));
      var f2 = e.point(r[0], r[1], o);
      if (!r[2])
        return f2;
      function p2(y3) {
        return e.point(y3[0], y3[1], o);
      }
      var m2 = r[2];
      return f2.precomputed = { beta: null, doubles: m2.doubles && { step: m2.doubles.step, points: [f2].concat(m2.doubles.points.map(p2)) }, naf: m2.naf && { wnd: m2.naf.wnd, points: [f2].concat(m2.naf.points.map(p2)) } }, f2;
    };
    Ct.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Ct.prototype.isInfinity = function() {
      return this.inf;
    };
    Ct.prototype.add = function(e) {
      if (this.inf)
        return e;
      if (e.inf)
        return this;
      if (this.eq(e))
        return this.dbl();
      if (this.neg().eq(e))
        return this.curve.point(null, null);
      if (this.x.cmp(e.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(e.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
      var o = r.redSqr().redISub(this.x).redISub(e.x), f2 = r.redMul(this.x.redSub(o)).redISub(this.y);
      return this.curve.point(o, f2);
    };
    Ct.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e = this.y.redAdd(this.y);
      if (e.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, o = this.x.redSqr(), f2 = e.redInvm(), p2 = o.redAdd(o).redIAdd(o).redIAdd(r).redMul(f2), m2 = p2.redSqr().redISub(this.x.redAdd(this.x)), y3 = p2.redMul(this.x.redSub(m2)).redISub(this.y);
      return this.curve.point(m2, y3);
    };
    Ct.prototype.getX = function() {
      return this.x.fromRed();
    };
    Ct.prototype.getY = function() {
      return this.y.fromRed();
    };
    Ct.prototype.mul = function(e) {
      return e = new lt(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
    };
    Ct.prototype.mulAdd = function(e, r, o) {
      var f2 = [this, r], p2 = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f2, p2) : this.curve._wnafMulAdd(1, f2, p2, 2);
    };
    Ct.prototype.jmulAdd = function(e, r, o) {
      var f2 = [this, r], p2 = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f2, p2, true) : this.curve._wnafMulAdd(1, f2, p2, 2, true);
    };
    Ct.prototype.eq = function(e) {
      return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    Ct.prototype.neg = function(e) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (e && this.precomputed) {
        var o = this.precomputed, f2 = function(p2) {
          return p2.neg();
        };
        r.precomputed = { naf: o.naf && { wnd: o.naf.wnd, points: o.naf.points.map(f2) }, doubles: o.doubles && { step: o.doubles.step, points: o.doubles.points.map(f2) } };
      }
      return r;
    };
    Ct.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var e = this.curve.jpoint(this.x, this.y, this.curve.one);
      return e;
    };
    function Wt(t, e, r, o) {
      Bf.BasePoint.call(this, t, "jacobian"), e === null && r === null && o === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt(0)) : (this.x = new lt(e, 16), this.y = new lt(r, 16), this.z = new lt(o, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Dl(Wt, Bf.BasePoint);
    xr.prototype.jpoint = function(e, r, o) {
      return new Wt(this, e, r, o);
    };
    Wt.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e = this.z.redInvm(), r = e.redSqr(), o = this.x.redMul(r), f2 = this.y.redMul(r).redMul(e);
      return this.curve.point(o, f2);
    };
    Wt.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    Wt.prototype.add = function(e) {
      if (this.isInfinity())
        return e;
      if (e.isInfinity())
        return this;
      var r = e.z.redSqr(), o = this.z.redSqr(), f2 = this.x.redMul(r), p2 = e.x.redMul(o), m2 = this.y.redMul(r.redMul(e.z)), y3 = e.y.redMul(o.redMul(this.z)), M2 = f2.redSub(p2), x3 = m2.redSub(y3);
      if (M2.cmpn(0) === 0)
        return x3.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var S2 = M2.redSqr(), E3 = S2.redMul(M2), B3 = f2.redMul(S2), q2 = x3.redSqr().redIAdd(E3).redISub(B3).redISub(B3), L3 = x3.redMul(B3.redISub(q2)).redISub(m2.redMul(E3)), ge = this.z.redMul(e.z).redMul(M2);
      return this.curve.jpoint(q2, L3, ge);
    };
    Wt.prototype.mixedAdd = function(e) {
      if (this.isInfinity())
        return e.toJ();
      if (e.isInfinity())
        return this;
      var r = this.z.redSqr(), o = this.x, f2 = e.x.redMul(r), p2 = this.y, m2 = e.y.redMul(r).redMul(this.z), y3 = o.redSub(f2), M2 = p2.redSub(m2);
      if (y3.cmpn(0) === 0)
        return M2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var x3 = y3.redSqr(), S2 = x3.redMul(y3), E3 = o.redMul(x3), B3 = M2.redSqr().redIAdd(S2).redISub(E3).redISub(E3), q2 = M2.redMul(E3.redISub(B3)).redISub(p2.redMul(S2)), L3 = this.z.redMul(y3);
      return this.curve.jpoint(B3, q2, L3);
    };
    Wt.prototype.dblp = function(e) {
      if (e === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var o = this;
        for (r = 0;r < e; r++)
          o = o.dbl();
        return o;
      }
      var f2 = this.curve.a, p2 = this.curve.tinv, m2 = this.x, y3 = this.y, M2 = this.z, x3 = M2.redSqr().redSqr(), S2 = y3.redAdd(y3);
      for (r = 0;r < e; r++) {
        var E3 = m2.redSqr(), B3 = S2.redSqr(), q2 = B3.redSqr(), L3 = E3.redAdd(E3).redIAdd(E3).redIAdd(f2.redMul(x3)), ge = m2.redMul(B3), _e = L3.redSqr().redISub(ge.redAdd(ge)), N3 = ge.redISub(_e), we = L3.redMul(N3);
        we = we.redIAdd(we).redISub(q2);
        var ye = S2.redMul(M2);
        r + 1 < e && (x3 = x3.redMul(q2)), m2 = _e, M2 = ye, S2 = we;
      }
      return this.curve.jpoint(m2, S2.redMul(p2), M2);
    };
    Wt.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    Wt.prototype._zeroDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f2 = this.x.redSqr(), p2 = this.y.redSqr(), m2 = p2.redSqr(), y3 = this.x.redAdd(p2).redSqr().redISub(f2).redISub(m2);
        y3 = y3.redIAdd(y3);
        var M2 = f2.redAdd(f2).redIAdd(f2), x3 = M2.redSqr().redISub(y3).redISub(y3), S2 = m2.redIAdd(m2);
        S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2), e = x3, r = M2.redMul(y3.redISub(x3)).redISub(S2), o = this.y.redAdd(this.y);
      } else {
        var E3 = this.x.redSqr(), B3 = this.y.redSqr(), q2 = B3.redSqr(), L3 = this.x.redAdd(B3).redSqr().redISub(E3).redISub(q2);
        L3 = L3.redIAdd(L3);
        var ge = E3.redAdd(E3).redIAdd(E3), _e = ge.redSqr(), N3 = q2.redIAdd(q2);
        N3 = N3.redIAdd(N3), N3 = N3.redIAdd(N3), e = _e.redISub(L3).redISub(L3), r = ge.redMul(L3.redISub(e)).redISub(N3), o = this.y.redMul(this.z), o = o.redIAdd(o);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._threeDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f2 = this.x.redSqr(), p2 = this.y.redSqr(), m2 = p2.redSqr(), y3 = this.x.redAdd(p2).redSqr().redISub(f2).redISub(m2);
        y3 = y3.redIAdd(y3);
        var M2 = f2.redAdd(f2).redIAdd(f2).redIAdd(this.curve.a), x3 = M2.redSqr().redISub(y3).redISub(y3);
        e = x3;
        var S2 = m2.redIAdd(m2);
        S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2), r = M2.redMul(y3.redISub(x3)).redISub(S2), o = this.y.redAdd(this.y);
      } else {
        var E3 = this.z.redSqr(), B3 = this.y.redSqr(), q2 = this.x.redMul(B3), L3 = this.x.redSub(E3).redMul(this.x.redAdd(E3));
        L3 = L3.redAdd(L3).redIAdd(L3);
        var ge = q2.redIAdd(q2);
        ge = ge.redIAdd(ge);
        var _e = ge.redAdd(ge);
        e = L3.redSqr().redISub(_e), o = this.y.redAdd(this.z).redSqr().redISub(B3).redISub(E3);
        var N3 = B3.redSqr();
        N3 = N3.redIAdd(N3), N3 = N3.redIAdd(N3), N3 = N3.redIAdd(N3), r = L3.redMul(ge.redISub(e)).redISub(N3);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._dbl = function() {
      var e = this.curve.a, r = this.x, o = this.y, f2 = this.z, p2 = f2.redSqr().redSqr(), m2 = r.redSqr(), y3 = o.redSqr(), M2 = m2.redAdd(m2).redIAdd(m2).redIAdd(e.redMul(p2)), x3 = r.redAdd(r);
      x3 = x3.redIAdd(x3);
      var S2 = x3.redMul(y3), E3 = M2.redSqr().redISub(S2.redAdd(S2)), B3 = S2.redISub(E3), q2 = y3.redSqr();
      q2 = q2.redIAdd(q2), q2 = q2.redIAdd(q2), q2 = q2.redIAdd(q2);
      var L3 = M2.redMul(B3).redISub(q2), ge = o.redAdd(o).redMul(f2);
      return this.curve.jpoint(E3, L3, ge);
    };
    Wt.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr(), f2 = r.redSqr(), p2 = e.redAdd(e).redIAdd(e), m2 = p2.redSqr(), y3 = this.x.redAdd(r).redSqr().redISub(e).redISub(f2);
      y3 = y3.redIAdd(y3), y3 = y3.redAdd(y3).redIAdd(y3), y3 = y3.redISub(m2);
      var M2 = y3.redSqr(), x3 = f2.redIAdd(f2);
      x3 = x3.redIAdd(x3), x3 = x3.redIAdd(x3), x3 = x3.redIAdd(x3);
      var S2 = p2.redIAdd(y3).redSqr().redISub(m2).redISub(M2).redISub(x3), E3 = r.redMul(S2);
      E3 = E3.redIAdd(E3), E3 = E3.redIAdd(E3);
      var B3 = this.x.redMul(M2).redISub(E3);
      B3 = B3.redIAdd(B3), B3 = B3.redIAdd(B3);
      var q2 = this.y.redMul(S2.redMul(x3.redISub(S2)).redISub(y3.redMul(M2)));
      q2 = q2.redIAdd(q2), q2 = q2.redIAdd(q2), q2 = q2.redIAdd(q2);
      var L3 = this.z.redAdd(y3).redSqr().redISub(o).redISub(M2);
      return this.curve.jpoint(B3, q2, L3);
    };
    Wt.prototype.mul = function(e, r) {
      return e = new lt(e, r), this.curve._wnafMul(this, e);
    };
    Wt.prototype.eq = function(e) {
      if (e.type === "affine")
        return this.eq(e.toJ());
      if (this === e)
        return true;
      var r = this.z.redSqr(), o = e.z.redSqr();
      if (this.x.redMul(o).redISub(e.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var f2 = r.redMul(this.z), p2 = o.redMul(e.z);
      return this.y.redMul(p2).redISub(e.y.redMul(f2)).cmpn(0) === 0;
    };
    Wt.prototype.eqXToP = function(e) {
      var r = this.z.redSqr(), o = e.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(o) === 0)
        return true;
      for (var f2 = e.clone(), p2 = this.curve.redN.redMul(r);; ) {
        if (f2.iadd(this.curve.n), f2.cmp(this.curve.p) >= 0)
          return false;
        if (o.redIAdd(p2), this.x.cmp(o) === 0)
          return true;
      }
    };
    Wt.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    Wt.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  });
  y22 = T2((Ek, g22) => {
    var qf = ri(), m2 = Ie(), Gs = Oa(), MA = or();
    function If(t) {
      Gs.call(this, "mont", t), this.a = new qf(t.a, 16).toRed(this.red), this.b = new qf(t.b, 16).toRed(this.red), this.i4 = new qf(4).toRed(this.red).redInvm(), this.two = new qf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    m2(If, Gs);
    g22.exports = If;
    If.prototype.validate = function(e) {
      var r = e.normalize().x, o = r.redSqr(), f2 = o.redMul(r).redAdd(o.redMul(this.a)).redAdd(r), p2 = f2.redSqrt();
      return p2.redSqr().cmp(f2) === 0;
    };
    function Ot(t, e, r) {
      Gs.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new qf(e, 16), this.z = new qf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    m2(Ot, Gs.BasePoint);
    If.prototype.decodePoint = function(e, r) {
      return this.point(MA.toArray(e, r), 1);
    };
    If.prototype.point = function(e, r) {
      return new Ot(this, e, r);
    };
    If.prototype.pointFromJSON = function(e) {
      return Ot.fromJSON(this, e);
    };
    Ot.prototype.precompute = function() {
    };
    Ot.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Ot.fromJSON = function(e, r) {
      return new Ot(e, r[0], r[1] || e.one);
    };
    Ot.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Ot.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    Ot.prototype.dbl = function() {
      var e = this.x.redAdd(this.z), r = e.redSqr(), o = this.x.redSub(this.z), f2 = o.redSqr(), p2 = r.redSub(f2), m3 = r.redMul(f2), y3 = p2.redMul(f2.redAdd(this.curve.a24.redMul(p2)));
      return this.curve.point(m3, y3);
    };
    Ot.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.diffAdd = function(e, r) {
      var o = this.x.redAdd(this.z), f2 = this.x.redSub(this.z), p2 = e.x.redAdd(e.z), m3 = e.x.redSub(e.z), y3 = m3.redMul(o), M2 = p2.redMul(f2), x3 = r.z.redMul(y3.redAdd(M2).redSqr()), S2 = r.x.redMul(y3.redISub(M2).redSqr());
      return this.curve.point(x3, S2);
    };
    Ot.prototype.mul = function(e) {
      for (var r = e.clone(), o = this, f2 = this.curve.point(null, null), p2 = this, m3 = [];r.cmpn(0) !== 0; r.iushrn(1))
        m3.push(r.andln(1));
      for (var y3 = m3.length - 1;y3 >= 0; y3--)
        m3[y3] === 0 ? (o = o.diffAdd(f2, p2), f2 = f2.dbl()) : (f2 = o.diffAdd(f2, p2), o = o.dbl());
      return f2;
    };
    Ot.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.eq = function(e) {
      return this.getX().cmp(e.getX()) === 0;
    };
    Ot.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Ot.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  });
  _22 = T2((Ak, M2) => {
    var _A = or(), Ai = ri(), w2 = Ie(), Ys = Oa(), xA = _A.assert;
    function ii(t) {
      this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Ys.call(this, "edwards", t), this.a = new Ai(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ai(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ai(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), xA(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
    }
    w2(ii, Ys);
    M2.exports = ii;
    ii.prototype._mulA = function(e) {
      return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    ii.prototype._mulC = function(e) {
      return this.oneC ? e : this.c.redMul(e);
    };
    ii.prototype.jpoint = function(e, r, o, f2) {
      return this.point(e, r, o, f2);
    };
    ii.prototype.pointFromX = function(e, r) {
      e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f2 = this.c2.redSub(this.a.redMul(o)), p2 = this.one.redSub(this.c2.redMul(this.d).redMul(o)), m2 = f2.redMul(p2.redInvm()), y3 = m2.redSqrt();
      if (y3.redSqr().redSub(m2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var M3 = y3.fromRed().isOdd();
      return (r && !M3 || !r && M3) && (y3 = y3.redNeg()), this.point(e, y3);
    };
    ii.prototype.pointFromY = function(e, r) {
      e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f2 = o.redSub(this.c2), p2 = o.redMul(this.d).redMul(this.c2).redSub(this.a), m2 = f2.redMul(p2.redInvm());
      if (m2.cmp(this.zero) === 0) {
        if (r)
          throw new Error("invalid point");
        return this.point(this.zero, e);
      }
      var y3 = m2.redSqrt();
      if (y3.redSqr().redSub(m2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      return y3.fromRed().isOdd() !== r && (y3 = y3.redNeg()), this.point(y3, e);
    };
    ii.prototype.validate = function(e) {
      if (e.isInfinity())
        return true;
      e.normalize();
      var r = e.x.redSqr(), o = e.y.redSqr(), f2 = r.redMul(this.a).redAdd(o), p2 = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o)));
      return f2.cmp(p2) === 0;
    };
    function at(t, e, r, o, f2) {
      Ys.BasePoint.call(this, t, "projective"), e === null && r === null && o === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ai(e, 16), this.y = new Ai(r, 16), this.z = o ? new Ai(o, 16) : this.curve.one, this.t = f2 && new Ai(f2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    w2(at, Ys.BasePoint);
    ii.prototype.pointFromJSON = function(e) {
      return at.fromJSON(this, e);
    };
    ii.prototype.point = function(e, r, o, f2) {
      return new at(this, e, r, o, f2);
    };
    at.fromJSON = function(e, r) {
      return new at(e, r[0], r[1], r[2]);
    };
    at.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    at.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    at.prototype._extDbl = function() {
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr();
      o = o.redIAdd(o);
      var f2 = this.curve._mulA(e), p2 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), m2 = f2.redAdd(r), y3 = m2.redSub(o), M3 = f2.redSub(r), x3 = p2.redMul(y3), S2 = m2.redMul(M3), E3 = p2.redMul(M3), B3 = y3.redMul(m2);
      return this.curve.point(x3, S2, B3, E3);
    };
    at.prototype._projDbl = function() {
      var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o = this.y.redSqr(), f2, p2, m2, y3, M3, x3;
      if (this.curve.twisted) {
        y3 = this.curve._mulA(r);
        var S2 = y3.redAdd(o);
        this.zOne ? (f2 = e.redSub(r).redSub(o).redMul(S2.redSub(this.curve.two)), p2 = S2.redMul(y3.redSub(o)), m2 = S2.redSqr().redSub(S2).redSub(S2)) : (M3 = this.z.redSqr(), x3 = S2.redSub(M3).redISub(M3), f2 = e.redSub(r).redISub(o).redMul(x3), p2 = S2.redMul(y3.redSub(o)), m2 = S2.redMul(x3));
      } else
        y3 = r.redAdd(o), M3 = this.curve._mulC(this.z).redSqr(), x3 = y3.redSub(M3).redSub(M3), f2 = this.curve._mulC(e.redISub(y3)).redMul(x3), p2 = this.curve._mulC(y3).redMul(r.redISub(o)), m2 = y3.redMul(x3);
      return this.curve.point(f2, p2, m2);
    };
    at.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    at.prototype._extAdd = function(e) {
      var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), f2 = this.t.redMul(this.curve.dd).redMul(e.t), p2 = this.z.redMul(e.z.redAdd(e.z)), m2 = o.redSub(r), y3 = p2.redSub(f2), M3 = p2.redAdd(f2), x3 = o.redAdd(r), S2 = m2.redMul(y3), E3 = M3.redMul(x3), B3 = m2.redMul(x3), q2 = y3.redMul(M3);
      return this.curve.point(S2, E3, q2, B3);
    };
    at.prototype._projAdd = function(e) {
      var r = this.z.redMul(e.z), o = r.redSqr(), f2 = this.x.redMul(e.x), p2 = this.y.redMul(e.y), m2 = this.curve.d.redMul(f2).redMul(p2), y3 = o.redSub(m2), M3 = o.redAdd(m2), x3 = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f2).redISub(p2), S2 = r.redMul(y3).redMul(x3), E3, B3;
      return this.curve.twisted ? (E3 = r.redMul(M3).redMul(p2.redSub(this.curve._mulA(f2))), B3 = y3.redMul(M3)) : (E3 = r.redMul(M3).redMul(p2.redSub(f2)), B3 = this.curve._mulC(y3).redMul(M3)), this.curve.point(S2, E3, B3);
    };
    at.prototype.add = function(e) {
      return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    at.prototype.mul = function(e) {
      return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    at.prototype.mulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, false);
    };
    at.prototype.jmulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, true);
    };
    at.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e = this.z.redInvm();
      return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
    };
    at.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    at.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    at.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    };
    at.prototype.eq = function(e) {
      return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    at.prototype.eqXToP = function(e) {
      var r = e.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(r) === 0)
        return true;
      for (var o = e.clone(), f2 = this.curve.redN.redMul(this.z);; ) {
        if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
          return false;
        if (r.redIAdd(f2), this.x.cmp(r) === 0)
          return true;
      }
    };
    at.prototype.toP = at.prototype.normalize;
    at.prototype.mixedAdd = at.prototype.add;
  });
  Pl = T2((x22) => {
    var Xs = x22;
    Xs.base = Oa();
    Xs.short = b2();
    Xs.mont = y22();
    Xs.edwards = _22();
  });
  Cr = T2((it) => {
    var SA = ar(), EA = Ie();
    it.inherits = EA;
    function AA(t, e) {
      return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
    }
    function RA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t == "string")
        if (e) {
          if (e === "hex")
            for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f2 = 0;f2 < t.length; f2 += 2)
              r.push(parseInt(t[f2] + t[f2 + 1], 16));
        } else
          for (var o = 0, f2 = 0;f2 < t.length; f2++) {
            var p2 = t.charCodeAt(f2);
            p2 < 128 ? r[o++] = p2 : p2 < 2048 ? (r[o++] = p2 >> 6 | 192, r[o++] = p2 & 63 | 128) : AA(t, f2) ? (p2 = 65536 + ((p2 & 1023) << 10) + (t.charCodeAt(++f2) & 1023), r[o++] = p2 >> 18 | 240, r[o++] = p2 >> 12 & 63 | 128, r[o++] = p2 >> 6 & 63 | 128, r[o++] = p2 & 63 | 128) : (r[o++] = p2 >> 12 | 224, r[o++] = p2 >> 6 & 63 | 128, r[o++] = p2 & 63 | 128);
          }
      else
        for (f2 = 0;f2 < t.length; f2++)
          r[f2] = t[f2] | 0;
      return r;
    }
    it.toArray = RA;
    function BA(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += E22(t[r].toString(16));
      return e;
    }
    it.toHex = BA;
    function S2(t) {
      var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
      return e >>> 0;
    }
    it.htonl = S2;
    function qA(t, e) {
      for (var r = "", o = 0;o < t.length; o++) {
        var f2 = t[o];
        e === "little" && (f2 = S2(f2)), r += A2(f2.toString(16));
      }
      return r;
    }
    it.toHex32 = qA;
    function E22(t) {
      return t.length === 1 ? "0" + t : t;
    }
    it.zero2 = E22;
    function A2(t) {
      return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
    }
    it.zero8 = A2;
    function IA(t, e, r, o) {
      var f2 = r - e;
      SA(f2 % 4 === 0);
      for (var p2 = new Array(f2 / 4), m2 = 0, y3 = e;m2 < p2.length; m2++, y3 += 4) {
        var M2;
        o === "big" ? M2 = t[y3] << 24 | t[y3 + 1] << 16 | t[y3 + 2] << 8 | t[y3 + 3] : M2 = t[y3 + 3] << 24 | t[y3 + 2] << 16 | t[y3 + 1] << 8 | t[y3], p2[m2] = M2 >>> 0;
      }
      return p2;
    }
    it.join32 = IA;
    function TA(t, e) {
      for (var r = new Array(t.length * 4), o = 0, f2 = 0;o < t.length; o++, f2 += 4) {
        var p2 = t[o];
        e === "big" ? (r[f2] = p2 >>> 24, r[f2 + 1] = p2 >>> 16 & 255, r[f2 + 2] = p2 >>> 8 & 255, r[f2 + 3] = p2 & 255) : (r[f2 + 3] = p2 >>> 24, r[f2 + 2] = p2 >>> 16 & 255, r[f2 + 1] = p2 >>> 8 & 255, r[f2] = p2 & 255);
      }
      return r;
    }
    it.split32 = TA;
    function kA(t, e) {
      return t >>> e | t << 32 - e;
    }
    it.rotr32 = kA;
    function LA(t, e) {
      return t << e | t >>> 32 - e;
    }
    it.rotl32 = LA;
    function NA(t, e) {
      return t + e >>> 0;
    }
    it.sum32 = NA;
    function DA(t, e, r) {
      return t + e + r >>> 0;
    }
    it.sum32_3 = DA;
    function PA(t, e, r, o) {
      return t + e + r + o >>> 0;
    }
    it.sum32_4 = PA;
    function CA(t, e, r, o, f2) {
      return t + e + r + o + f2 >>> 0;
    }
    it.sum32_5 = CA;
    function OA(t, e, r, o) {
      var f2 = t[e], p2 = t[e + 1], m2 = o + p2 >>> 0, y3 = (m2 < o ? 1 : 0) + r + f2;
      t[e] = y3 >>> 0, t[e + 1] = m2;
    }
    it.sum64 = OA;
    function FA(t, e, r, o) {
      var f2 = e + o >>> 0, p2 = (f2 < e ? 1 : 0) + t + r;
      return p2 >>> 0;
    }
    it.sum64_hi = FA;
    function UA(t, e, r, o) {
      var f2 = e + o;
      return f2 >>> 0;
    }
    it.sum64_lo = UA;
    function zA(t, e, r, o, f2, p2, m2, y3) {
      var M2 = 0, x3 = e;
      x3 = x3 + o >>> 0, M2 += x3 < e ? 1 : 0, x3 = x3 + p2 >>> 0, M2 += x3 < p2 ? 1 : 0, x3 = x3 + y3 >>> 0, M2 += x3 < y3 ? 1 : 0;
      var S3 = t + r + f2 + m2 + M2;
      return S3 >>> 0;
    }
    it.sum64_4_hi = zA;
    function HA(t, e, r, o, f2, p2, m2, y3) {
      var M2 = e + o + p2 + y3;
      return M2 >>> 0;
    }
    it.sum64_4_lo = HA;
    function WA(t, e, r, o, f2, p2, m2, y3, M2, x3) {
      var S3 = 0, E3 = e;
      E3 = E3 + o >>> 0, S3 += E3 < e ? 1 : 0, E3 = E3 + p2 >>> 0, S3 += E3 < p2 ? 1 : 0, E3 = E3 + y3 >>> 0, S3 += E3 < y3 ? 1 : 0, E3 = E3 + x3 >>> 0, S3 += E3 < x3 ? 1 : 0;
      var B3 = t + r + f2 + m2 + M2 + S3;
      return B3 >>> 0;
    }
    it.sum64_5_hi = WA;
    function KA(t, e, r, o, f2, p2, m2, y3, M2, x3) {
      var S3 = e + o + p2 + y3 + x3;
      return S3 >>> 0;
    }
    it.sum64_5_lo = KA;
    function jA(t, e, r) {
      var o = e << 32 - r | t >>> r;
      return o >>> 0;
    }
    it.rotr64_hi = jA;
    function ZA(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.rotr64_lo = ZA;
    function VA(t, e, r) {
      return t >>> r;
    }
    it.shr64_hi = VA;
    function $A(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.shr64_lo = $A;
  });
  Tf = T2((B22) => {
    var R2 = Cr(), GA = ar();
    function Js() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    B22.BlockHash = Js;
    Js.prototype.update = function(e, r) {
      if (e = R2.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var o = e.length % this._delta8;
        this.pending = e.slice(e.length - o, e.length), this.pending.length === 0 && (this.pending = null), e = R2.join32(e, 0, e.length - o, this.endian);
        for (var f2 = 0;f2 < e.length; f2 += this._delta32)
          this._update(e, f2, f2 + this._delta32);
      }
      return this;
    };
    Js.prototype.digest = function(e) {
      return this.update(this._pad()), GA(this.pending === null), this._digest(e);
    };
    Js.prototype._pad = function() {
      var e = this.pendingTotal, r = this._delta8, o = r - (e + this.padLength) % r, f2 = new Array(o + this.padLength);
      f2[0] = 128;
      for (var p2 = 1;p2 < o; p2++)
        f2[p2] = 0;
      if (e <<= 3, this.endian === "big") {
        for (var m2 = 8;m2 < this.padLength; m2++)
          f2[p2++] = 0;
        f2[p2++] = 0, f2[p2++] = 0, f2[p2++] = 0, f2[p2++] = 0, f2[p2++] = e >>> 24 & 255, f2[p2++] = e >>> 16 & 255, f2[p2++] = e >>> 8 & 255, f2[p2++] = e & 255;
      } else
        for (f2[p2++] = e & 255, f2[p2++] = e >>> 8 & 255, f2[p2++] = e >>> 16 & 255, f2[p2++] = e >>> 24 & 255, f2[p2++] = 0, f2[p2++] = 0, f2[p2++] = 0, f2[p2++] = 0, m2 = 8;m2 < this.padLength; m2++)
          f2[p2++] = 0;
      return f2;
    };
  });
  Cl = T2((Ri) => {
    var YA = Cr(), ni = YA.rotr32;
    function XA(t, e, r, o) {
      if (t === 0)
        return q2(e, r, o);
      if (t === 1 || t === 3)
        return T22(e, r, o);
      if (t === 2)
        return I22(e, r, o);
    }
    Ri.ft_1 = XA;
    function q2(t, e, r) {
      return t & e ^ ~t & r;
    }
    Ri.ch32 = q2;
    function I22(t, e, r) {
      return t & e ^ t & r ^ e & r;
    }
    Ri.maj32 = I22;
    function T22(t, e, r) {
      return t ^ e ^ r;
    }
    Ri.p32 = T22;
    function JA(t) {
      return ni(t, 2) ^ ni(t, 13) ^ ni(t, 22);
    }
    Ri.s0_256 = JA;
    function QA(t) {
      return ni(t, 6) ^ ni(t, 11) ^ ni(t, 25);
    }
    Ri.s1_256 = QA;
    function eR(t) {
      return ni(t, 7) ^ ni(t, 18) ^ t >>> 3;
    }
    Ri.g0_256 = eR;
    function tR(t) {
      return ni(t, 17) ^ ni(t, 19) ^ t >>> 10;
    }
    Ri.g1_256 = tR;
  });
  N22 = T2((Tk, L22) => {
    var kf = Cr(), rR = Tf(), iR = Cl(), Ol = kf.rotl32, Fa = kf.sum32, nR = kf.sum32_5, fR = iR.ft_1, k22 = rR.BlockHash, aR = [1518500249, 1859775393, 2400959708, 3395469782];
    function fi() {
      if (!(this instanceof fi))
        return new fi;
      k22.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    kf.inherits(fi, k22);
    L22.exports = fi;
    fi.blockSize = 512;
    fi.outSize = 160;
    fi.hmacStrength = 80;
    fi.padLength = 64;
    fi.prototype._update = function(e, r) {
      for (var o = this.W, f2 = 0;f2 < 16; f2++)
        o[f2] = e[r + f2];
      for (;f2 < o.length; f2++)
        o[f2] = Ol(o[f2 - 3] ^ o[f2 - 8] ^ o[f2 - 14] ^ o[f2 - 16], 1);
      var p2 = this.h[0], m2 = this.h[1], y3 = this.h[2], M2 = this.h[3], x3 = this.h[4];
      for (f2 = 0;f2 < o.length; f2++) {
        var S2 = ~~(f2 / 20), E3 = nR(Ol(p2, 5), fR(S2, m2, y3, M2), x3, o[f2], aR[S2]);
        x3 = M2, M2 = y3, y3 = Ol(m2, 30), m2 = p2, p2 = E3;
      }
      this.h[0] = Fa(this.h[0], p2), this.h[1] = Fa(this.h[1], m2), this.h[2] = Fa(this.h[2], y3), this.h[3] = Fa(this.h[3], M2), this.h[4] = Fa(this.h[4], x3);
    };
    fi.prototype._digest = function(e) {
      return e === "hex" ? kf.toHex32(this.h, "big") : kf.split32(this.h, "big");
    };
  });
  Fl = T2((kk, P2) => {
    var Lf = Cr(), oR = Tf(), Nf = Cl(), sR = ar(), Or = Lf.sum32, hR = Lf.sum32_4, uR = Lf.sum32_5, lR = Nf.ch32, dR = Nf.maj32, cR = Nf.s0_256, pR = Nf.s1_256, vR = Nf.g0_256, bR = Nf.g1_256, D2 = oR.BlockHash, mR = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function ai() {
      if (!(this instanceof ai))
        return new ai;
      D2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = mR, this.W = new Array(64);
    }
    Lf.inherits(ai, D2);
    P2.exports = ai;
    ai.blockSize = 512;
    ai.outSize = 256;
    ai.hmacStrength = 192;
    ai.padLength = 64;
    ai.prototype._update = function(e, r) {
      for (var o = this.W, f2 = 0;f2 < 16; f2++)
        o[f2] = e[r + f2];
      for (;f2 < o.length; f2++)
        o[f2] = hR(bR(o[f2 - 2]), o[f2 - 7], vR(o[f2 - 15]), o[f2 - 16]);
      var p2 = this.h[0], m2 = this.h[1], y3 = this.h[2], M2 = this.h[3], x3 = this.h[4], S2 = this.h[5], E3 = this.h[6], B3 = this.h[7];
      for (sR(this.k.length === o.length), f2 = 0;f2 < o.length; f2++) {
        var q2 = uR(B3, pR(x3), lR(x3, S2, E3), this.k[f2], o[f2]), L3 = Or(cR(p2), dR(p2, m2, y3));
        B3 = E3, E3 = S2, S2 = x3, x3 = Or(M2, q2), M2 = y3, y3 = m2, m2 = p2, p2 = Or(q2, L3);
      }
      this.h[0] = Or(this.h[0], p2), this.h[1] = Or(this.h[1], m2), this.h[2] = Or(this.h[2], y3), this.h[3] = Or(this.h[3], M2), this.h[4] = Or(this.h[4], x3), this.h[5] = Or(this.h[5], S2), this.h[6] = Or(this.h[6], E3), this.h[7] = Or(this.h[7], B3);
    };
    ai.prototype._digest = function(e) {
      return e === "hex" ? Lf.toHex32(this.h, "big") : Lf.split32(this.h, "big");
    };
  });
  F2 = T2((Lk, O22) => {
    var Ul = Cr(), C2 = Fl();
    function Bi() {
      if (!(this instanceof Bi))
        return new Bi;
      C2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Ul.inherits(Bi, C2);
    O22.exports = Bi;
    Bi.blockSize = 512;
    Bi.outSize = 224;
    Bi.hmacStrength = 192;
    Bi.padLength = 64;
    Bi.prototype._digest = function(e) {
      return e === "hex" ? Ul.toHex32(this.h.slice(0, 7), "big") : Ul.split32(this.h.slice(0, 7), "big");
    };
  });
  Wl = T2((Nk, W2) => {
    var ir = Cr(), gR = Tf(), yR = ar(), oi = ir.rotr64_hi, si = ir.rotr64_lo, U22 = ir.shr64_hi, z2 = ir.shr64_lo, Ji = ir.sum64, zl = ir.sum64_hi, Hl = ir.sum64_lo, wR = ir.sum64_4_hi, MR = ir.sum64_4_lo, _R = ir.sum64_5_hi, xR = ir.sum64_5_lo, H2 = gR.BlockHash, SR = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Fr() {
      if (!(this instanceof Fr))
        return new Fr;
      H2.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = SR, this.W = new Array(160);
    }
    ir.inherits(Fr, H2);
    W2.exports = Fr;
    Fr.blockSize = 1024;
    Fr.outSize = 512;
    Fr.hmacStrength = 192;
    Fr.padLength = 128;
    Fr.prototype._prepareBlock = function(e, r) {
      for (var o = this.W, f2 = 0;f2 < 32; f2++)
        o[f2] = e[r + f2];
      for (;f2 < o.length; f2 += 2) {
        var p2 = DR(o[f2 - 4], o[f2 - 3]), m2 = PR(o[f2 - 4], o[f2 - 3]), y3 = o[f2 - 14], M2 = o[f2 - 13], x3 = LR(o[f2 - 30], o[f2 - 29]), S2 = NR(o[f2 - 30], o[f2 - 29]), E3 = o[f2 - 32], B3 = o[f2 - 31];
        o[f2] = wR(p2, m2, y3, M2, x3, S2, E3, B3), o[f2 + 1] = MR(p2, m2, y3, M2, x3, S2, E3, B3);
      }
    };
    Fr.prototype._update = function(e, r) {
      this._prepareBlock(e, r);
      var o = this.W, f2 = this.h[0], p2 = this.h[1], m2 = this.h[2], y3 = this.h[3], M2 = this.h[4], x3 = this.h[5], S2 = this.h[6], E3 = this.h[7], B3 = this.h[8], q2 = this.h[9], L3 = this.h[10], ge = this.h[11], _e = this.h[12], N3 = this.h[13], we = this.h[14], ye = this.h[15];
      yR(this.k.length === o.length);
      for (var xe = 0;xe < o.length; xe += 2) {
        var Re = we, Ee = ye, Ae = TR(B3, q2), P2 = kR(B3, q2), Se = ER(B3, q2, L3, ge, _e, N3), v = AR(B3, q2, L3, ge, _e, N3), i = this.k[xe], a2 = this.k[xe + 1], h3 = o[xe], s3 = o[xe + 1], u3 = _R(Re, Ee, Ae, P2, Se, v, i, a2, h3, s3), c2 = xR(Re, Ee, Ae, P2, Se, v, i, a2, h3, s3);
        Re = qR(f2, p2), Ee = IR(f2, p2), Ae = RR(f2, p2, m2, y3, M2, x3), P2 = BR(f2, p2, m2, y3, M2, x3);
        var b3 = zl(Re, Ee, Ae, P2), l2 = Hl(Re, Ee, Ae, P2);
        we = _e, ye = N3, _e = L3, N3 = ge, L3 = B3, ge = q2, B3 = zl(S2, E3, u3, c2), q2 = Hl(E3, E3, u3, c2), S2 = M2, E3 = x3, M2 = m2, x3 = y3, m2 = f2, y3 = p2, f2 = zl(u3, c2, b3, l2), p2 = Hl(u3, c2, b3, l2);
      }
      Ji(this.h, 0, f2, p2), Ji(this.h, 2, m2, y3), Ji(this.h, 4, M2, x3), Ji(this.h, 6, S2, E3), Ji(this.h, 8, B3, q2), Ji(this.h, 10, L3, ge), Ji(this.h, 12, _e, N3), Ji(this.h, 14, we, ye);
    };
    Fr.prototype._digest = function(e) {
      return e === "hex" ? ir.toHex32(this.h, "big") : ir.split32(this.h, "big");
    };
    function ER(t, e, r, o, f2) {
      var p2 = t & r ^ ~t & f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function AR(t, e, r, o, f2, p2) {
      var m2 = e & o ^ ~e & p2;
      return m2 < 0 && (m2 += 4294967296), m2;
    }
    function RR(t, e, r, o, f2) {
      var p2 = t & r ^ t & f2 ^ r & f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function BR(t, e, r, o, f2, p2) {
      var m2 = e & o ^ e & p2 ^ o & p2;
      return m2 < 0 && (m2 += 4294967296), m2;
    }
    function qR(t, e) {
      var r = oi(t, e, 28), o = oi(e, t, 2), f2 = oi(e, t, 7), p2 = r ^ o ^ f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function IR(t, e) {
      var r = si(t, e, 28), o = si(e, t, 2), f2 = si(e, t, 7), p2 = r ^ o ^ f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function TR(t, e) {
      var r = oi(t, e, 14), o = oi(t, e, 18), f2 = oi(e, t, 9), p2 = r ^ o ^ f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function kR(t, e) {
      var r = si(t, e, 14), o = si(t, e, 18), f2 = si(e, t, 9), p2 = r ^ o ^ f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function LR(t, e) {
      var r = oi(t, e, 1), o = oi(t, e, 8), f2 = U22(t, e, 7), p2 = r ^ o ^ f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function NR(t, e) {
      var r = si(t, e, 1), o = si(t, e, 8), f2 = z2(t, e, 7), p2 = r ^ o ^ f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function DR(t, e) {
      var r = oi(t, e, 19), o = oi(e, t, 29), f2 = U22(t, e, 6), p2 = r ^ o ^ f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function PR(t, e) {
      var r = si(t, e, 19), o = si(e, t, 29), f2 = z2(t, e, 6), p2 = r ^ o ^ f2;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
  });
  Z2 = T2((Dk, j22) => {
    var Kl = Cr(), K2 = Wl();
    function qi() {
      if (!(this instanceof qi))
        return new qi;
      K2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Kl.inherits(qi, K2);
    j22.exports = qi;
    qi.blockSize = 1024;
    qi.outSize = 384;
    qi.hmacStrength = 192;
    qi.padLength = 128;
    qi.prototype._digest = function(e) {
      return e === "hex" ? Kl.toHex32(this.h.slice(0, 12), "big") : Kl.split32(this.h.slice(0, 12), "big");
    };
  });
  V22 = T2((Df) => {
    Df.sha1 = N22();
    Df.sha224 = F2();
    Df.sha256 = Fl();
    Df.sha384 = Z2();
    Df.sha512 = Wl();
  });
  Q2 = T2((J2) => {
    var On = Cr(), CR = Tf(), Qs = On.rotl32, $2 = On.sum32, Ua = On.sum32_3, G2 = On.sum32_4, X22 = CR.BlockHash;
    function hi() {
      if (!(this instanceof hi))
        return new hi;
      X22.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    On.inherits(hi, X22);
    J2.ripemd160 = hi;
    hi.blockSize = 512;
    hi.outSize = 160;
    hi.hmacStrength = 192;
    hi.padLength = 64;
    hi.prototype._update = function(e, r) {
      for (var o = this.h[0], f2 = this.h[1], p2 = this.h[2], m2 = this.h[3], y3 = this.h[4], M2 = o, x3 = f2, S2 = p2, E3 = m2, B3 = y3, q2 = 0;q2 < 80; q2++) {
        var L3 = $2(Qs(G2(o, Y2(q2, f2, p2, m2), e[UR[q2] + r], OR(q2)), HR[q2]), y3);
        o = y3, y3 = m2, m2 = Qs(p2, 10), p2 = f2, f2 = L3, L3 = $2(Qs(G2(M2, Y2(79 - q2, x3, S2, E3), e[zR[q2] + r], FR(q2)), WR[q2]), B3), M2 = B3, B3 = E3, E3 = Qs(S2, 10), S2 = x3, x3 = L3;
      }
      L3 = Ua(this.h[1], p2, E3), this.h[1] = Ua(this.h[2], m2, B3), this.h[2] = Ua(this.h[3], y3, M2), this.h[3] = Ua(this.h[4], o, x3), this.h[4] = Ua(this.h[0], f2, S2), this.h[0] = L3;
    };
    hi.prototype._digest = function(e) {
      return e === "hex" ? On.toHex32(this.h, "little") : On.split32(this.h, "little");
    };
    function Y2(t, e, r, o) {
      return t <= 15 ? e ^ r ^ o : t <= 31 ? e & r | ~e & o : t <= 47 ? (e | ~r) ^ o : t <= 63 ? e & o | r & ~o : e ^ (r | ~o);
    }
    function OR(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
    }
    function FR(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
    }
    var UR = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], zR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], HR = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], WR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  ty = T2((Ok, ey) => {
    var KR = Cr(), jR = ar();
    function Pf(t, e, r) {
      if (!(this instanceof Pf))
        return new Pf(t, e, r);
      this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(KR.toArray(e, r));
    }
    ey.exports = Pf;
    Pf.prototype._init = function(e) {
      e.length > this.blockSize && (e = new this.Hash().update(e).digest()), jR(e.length <= this.blockSize);
      for (var r = e.length;r < this.blockSize; r++)
        e.push(0);
      for (r = 0;r < e.length; r++)
        e[r] ^= 54;
      for (this.inner = new this.Hash().update(e), r = 0;r < e.length; r++)
        e[r] ^= 106;
      this.outer = new this.Hash().update(e);
    };
    Pf.prototype.update = function(e, r) {
      return this.inner.update(e, r), this;
    };
    Pf.prototype.digest = function(e) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e);
    };
  });
  e0 = T2((ry) => {
    var Kt = ry;
    Kt.utils = Cr();
    Kt.common = Tf();
    Kt.sha = V22();
    Kt.ripemd = Q2();
    Kt.hmac = ty();
    Kt.sha1 = Kt.sha.sha1;
    Kt.sha256 = Kt.sha.sha256;
    Kt.sha224 = Kt.sha.sha224;
    Kt.sha384 = Kt.sha.sha384;
    Kt.sha512 = Kt.sha.sha512;
    Kt.ripemd160 = Kt.ripemd.ripemd160;
  });
  ny = T2((Uk, iy) => {
    iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  t0 = T2((oy) => {
    var Zl = oy, Qi = e0(), jl = Pl(), ZR = or(), fy = ZR.assert;
    function ay(t) {
      t.type === "short" ? this.curve = new jl.short(t) : t.type === "edwards" ? this.curve = new jl.edwards(t) : this.curve = new jl.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, fy(this.g.validate(), "Invalid curve"), fy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    Zl.PresetCurve = ay;
    function en(t, e) {
      Object.defineProperty(Zl, t, { configurable: true, enumerable: true, get: function() {
        var r = new ay(e);
        return Object.defineProperty(Zl, t, { configurable: true, enumerable: true, value: r }), r;
      } });
    }
    en("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Qi.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    en("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Qi.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    en("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Qi.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    en("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Qi.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    en("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Qi.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    en("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["9"] });
    en("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var Vl;
    try {
      Vl = ny();
    } catch {
      Vl = undefined;
    }
    en("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Qi.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Vl] });
  });
  uy = T2((Hk, hy) => {
    var VR = e0(), Fn = Nl(), sy = ar();
    function tn(t) {
      if (!(this instanceof tn))
        return new tn(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e = Fn.toArray(t.entropy, t.entropyEnc || "hex"), r = Fn.toArray(t.nonce, t.nonceEnc || "hex"), o = Fn.toArray(t.pers, t.persEnc || "hex");
      sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, o);
    }
    hy.exports = tn;
    tn.prototype._init = function(e, r, o) {
      var f2 = e.concat(r).concat(o);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var p2 = 0;p2 < this.V.length; p2++)
        this.K[p2] = 0, this.V[p2] = 1;
      this._update(f2), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    tn.prototype._hmac = function() {
      return new VR.hmac(this.hash, this.K);
    };
    tn.prototype._update = function(e) {
      var r = this._hmac().update(this.V).update([0]);
      e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    tn.prototype.reseed = function(e, r, o, f2) {
      typeof r != "string" && (f2 = o, o = r, r = null), e = Fn.toArray(e, r), o = Fn.toArray(o, f2), sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(o || [])), this._reseed = 1;
    };
    tn.prototype.generate = function(e, r, o, f2) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (f2 = o, o = r, r = null), o && (o = Fn.toArray(o, f2 || "hex"), this._update(o));
      for (var p2 = [];p2.length < e; )
        this.V = this._hmac().update(this.V).digest(), p2 = p2.concat(this.V);
      var m2 = p2.slice(0, e);
      return this._update(o), this._reseed++, Fn.encode(m2, r);
    };
  });
  dy = T2((Wk, ly) => {
    var $R = ri(), GR = or(), $l = GR.assert;
    function Gt(t, e) {
      this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    ly.exports = Gt;
    Gt.fromPublic = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { pub: r, pubEnc: o });
    };
    Gt.fromPrivate = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { priv: r, privEnc: o });
    };
    Gt.prototype.validate = function() {
      var e = this.getPublic();
      return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    };
    Gt.prototype.getPublic = function(e, r) {
      return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
    };
    Gt.prototype.getPrivate = function(e) {
      return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    Gt.prototype._importPrivate = function(e, r) {
      this.priv = new $R(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    Gt.prototype._importPublic = function(e, r) {
      if (e.x || e.y) {
        this.ec.curve.type === "mont" ? $l(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $l(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(e, r);
    };
    Gt.prototype.derive = function(e) {
      return e.validate() || $l(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    Gt.prototype.sign = function(e, r, o) {
      return this.ec.sign(e, this, r, o);
    };
    Gt.prototype.verify = function(e, r) {
      return this.ec.verify(e, r, this);
    };
    Gt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  vy = T2((Kk, py) => {
    var r0 = ri(), Xl = or(), YR = Xl.assert;
    function i0(t, e) {
      if (t instanceof i0)
        return t;
      this._importDER(t, e) || (YR(t.r && t.s, "Signature without r or s"), this.r = new r0(t.r, 16), this.s = new r0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
    }
    py.exports = i0;
    function XR() {
      this.place = 0;
    }
    function Gl(t, e) {
      var r = t[e.place++];
      if (!(r & 128))
        return r;
      var o = r & 15;
      if (o === 0 || o > 4)
        return false;
      for (var f2 = 0, p2 = 0, m2 = e.place;p2 < o; p2++, m2++)
        f2 <<= 8, f2 |= t[m2], f2 >>>= 0;
      return f2 <= 127 ? false : (e.place = m2, f2);
    }
    function cy(t) {
      for (var e = 0, r = t.length - 1;!t[e] && !(t[e + 1] & 128) && e < r; )
        e++;
      return e === 0 ? t : t.slice(e);
    }
    i0.prototype._importDER = function(e, r) {
      e = Xl.toArray(e, r);
      var o = new XR;
      if (e[o.place++] !== 48)
        return false;
      var f2 = Gl(e, o);
      if (f2 === false || f2 + o.place !== e.length || e[o.place++] !== 2)
        return false;
      var p2 = Gl(e, o);
      if (p2 === false)
        return false;
      var m2 = e.slice(o.place, p2 + o.place);
      if (o.place += p2, e[o.place++] !== 2)
        return false;
      var y3 = Gl(e, o);
      if (y3 === false || e.length !== y3 + o.place)
        return false;
      var M2 = e.slice(o.place, y3 + o.place);
      if (m2[0] === 0)
        if (m2[1] & 128)
          m2 = m2.slice(1);
        else
          return false;
      if (M2[0] === 0)
        if (M2[1] & 128)
          M2 = M2.slice(1);
        else
          return false;
      return this.r = new r0(m2), this.s = new r0(M2), this.recoveryParam = null, true;
    };
    function Yl(t, e) {
      if (e < 128) {
        t.push(e);
        return;
      }
      var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
      for (t.push(r | 128);--r; )
        t.push(e >>> (r << 3) & 255);
      t.push(e);
    }
    i0.prototype.toDER = function(e) {
      var r = this.r.toArray(), o = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), o[0] & 128 && (o = [0].concat(o)), r = cy(r), o = cy(o);!o[0] && !(o[1] & 128); )
        o = o.slice(1);
      var f2 = [2];
      Yl(f2, r.length), f2 = f2.concat(r), f2.push(2), Yl(f2, o.length);
      var p2 = f2.concat(o), m2 = [48];
      return Yl(m2, p2.length), m2 = m2.concat(p2), Xl.encode(m2, e);
    };
  });
  yy = T2((jk, gy) => {
    var Un = ri(), by = uy(), JR = or(), Jl = t0(), QR = As(), my = JR.assert, Ql = dy(), n0 = vy();
    function Sr(t) {
      if (!(this instanceof Sr))
        return new Sr(t);
      typeof t == "string" && (my(Object.prototype.hasOwnProperty.call(Jl, t), "Unknown curve " + t), t = Jl[t]), t instanceof Jl.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
    }
    gy.exports = Sr;
    Sr.prototype.keyPair = function(e) {
      return new Ql(this, e);
    };
    Sr.prototype.keyFromPrivate = function(e, r) {
      return Ql.fromPrivate(this, e, r);
    };
    Sr.prototype.keyFromPublic = function(e, r) {
      return Ql.fromPublic(this, e, r);
    };
    Sr.prototype.genKeyPair = function(e) {
      e || (e = {});
      for (var r = new by({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || QR(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), o = this.n.byteLength(), f2 = this.n.sub(new Un(2));; ) {
        var p2 = new Un(r.generate(o));
        if (!(p2.cmp(f2) > 0))
          return p2.iaddn(1), this.keyFromPrivate(p2);
      }
    };
    Sr.prototype._truncateToN = function(e, r) {
      var o = e.byteLength() * 8 - this.n.bitLength();
      return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    Sr.prototype.sign = function(e, r, o, f2) {
      typeof o == "object" && (f2 = o, o = null), f2 || (f2 = {}), r = this.keyFromPrivate(r, o), e = this._truncateToN(new Un(e, 16));
      for (var p2 = this.n.byteLength(), m2 = r.getPrivate().toArray("be", p2), y3 = e.toArray("be", p2), M2 = new by({ hash: this.hash, entropy: m2, nonce: y3, pers: f2.pers, persEnc: f2.persEnc || "utf8" }), x3 = this.n.sub(new Un(1)), S2 = 0;; S2++) {
        var E3 = f2.k ? f2.k(S2) : new Un(M2.generate(this.n.byteLength()));
        if (E3 = this._truncateToN(E3, true), !(E3.cmpn(1) <= 0 || E3.cmp(x3) >= 0)) {
          var B3 = this.g.mul(E3);
          if (!B3.isInfinity()) {
            var q2 = B3.getX(), L3 = q2.umod(this.n);
            if (L3.cmpn(0) !== 0) {
              var ge = E3.invm(this.n).mul(L3.mul(r.getPrivate()).iadd(e));
              if (ge = ge.umod(this.n), ge.cmpn(0) !== 0) {
                var _e = (B3.getY().isOdd() ? 1 : 0) | (q2.cmp(L3) !== 0 ? 2 : 0);
                return f2.canonical && ge.cmp(this.nh) > 0 && (ge = this.n.sub(ge), _e ^= 1), new n0({ r: L3, s: ge, recoveryParam: _e });
              }
            }
          }
        }
      }
    };
    Sr.prototype.verify = function(e, r, o, f2) {
      e = this._truncateToN(new Un(e, 16)), o = this.keyFromPublic(o, f2), r = new n0(r, "hex");
      var { r: p2, s: m2 } = r;
      if (p2.cmpn(1) < 0 || p2.cmp(this.n) >= 0 || m2.cmpn(1) < 0 || m2.cmp(this.n) >= 0)
        return false;
      var y3 = m2.invm(this.n), M2 = y3.mul(e).umod(this.n), x3 = y3.mul(p2).umod(this.n), S2;
      return this.curve._maxwellTrick ? (S2 = this.g.jmulAdd(M2, o.getPublic(), x3), S2.isInfinity() ? false : S2.eqXToP(p2)) : (S2 = this.g.mulAdd(M2, o.getPublic(), x3), S2.isInfinity() ? false : S2.getX().umod(this.n).cmp(p2) === 0);
    };
    Sr.prototype.recoverPubKey = function(t, e, r, o) {
      my((3 & r) === r, "The recovery param is more than two bits"), e = new n0(e, o);
      var f2 = this.n, p2 = new Un(t), m2 = e.r, y3 = e.s, M2 = r & 1, x3 = r >> 1;
      if (m2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x3)
        throw new Error("Unable to find sencond key candinate");
      x3 ? m2 = this.curve.pointFromX(m2.add(this.curve.n), M2) : m2 = this.curve.pointFromX(m2, M2);
      var S2 = e.r.invm(f2), E3 = f2.sub(p2).mul(S2).umod(f2), B3 = y3.mul(S2).umod(f2);
      return this.g.mulAdd(E3, m2, B3);
    };
    Sr.prototype.getKeyRecoveryParam = function(t, e, r, o) {
      if (e = new n0(e, o), e.recoveryParam !== null)
        return e.recoveryParam;
      for (var f2 = 0;f2 < 4; f2++) {
        var p2;
        try {
          p2 = this.recoverPubKey(t, e, f2);
        } catch {
          continue;
        }
        if (p2.eq(r))
          return f2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  xy = T2((Zk, _y) => {
    var za = or(), My = za.assert, wy = za.parseBytes, Cf = za.cachedProperty;
    function Ft(t, e) {
      this.eddsa = t, this._secret = wy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = wy(e.pub);
    }
    Ft.fromPublic = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { pub: r });
    };
    Ft.fromSecret = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { secret: r });
    };
    Ft.prototype.secret = function() {
      return this._secret;
    };
    Cf(Ft, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    });
    Cf(Ft, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    Cf(Ft, "privBytes", function() {
      var e = this.eddsa, r = this.hash(), o = e.encodingLength - 1, f2 = r.slice(0, e.encodingLength);
      return f2[0] &= 248, f2[o] &= 127, f2[o] |= 64, f2;
    });
    Cf(Ft, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    Cf(Ft, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    Cf(Ft, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    Ft.prototype.sign = function(e) {
      return My(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    Ft.prototype.verify = function(e, r) {
      return this.eddsa.verify(e, r, this);
    };
    Ft.prototype.getSecret = function(e) {
      return My(this._secret, "KeyPair is public only"), za.encode(this.secret(), e);
    };
    Ft.prototype.getPublic = function(e) {
      return za.encode(this.pubBytes(), e);
    };
    _y.exports = Ft;
  });
  Ey = T2((Vk, Sy) => {
    var eB = ri(), f0 = or(), tB = f0.assert, a0 = f0.cachedProperty, rB = f0.parseBytes;
    function zn(t, e) {
      this.eddsa = t, typeof e != "object" && (e = rB(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), tB(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof eB && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    a0(zn, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    a0(zn, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    a0(zn, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    });
    a0(zn, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    });
    zn.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    };
    zn.prototype.toHex = function() {
      return f0.encode(this.toBytes(), "hex").toUpperCase();
    };
    Sy.exports = zn;
  });
  Iy = T2(($k, qy) => {
    var iB = e0(), nB = t0(), Of = or(), fB = Of.assert, Ry = Of.parseBytes, By = xy(), Ay = Ey();
    function nr(t) {
      if (fB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
        return new nr(t);
      t = nB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = iB.sha512;
    }
    qy.exports = nr;
    nr.prototype.sign = function(e, r) {
      e = Ry(e);
      var o = this.keyFromSecret(r), f2 = this.hashInt(o.messagePrefix(), e), p2 = this.g.mul(f2), m2 = this.encodePoint(p2), y3 = this.hashInt(m2, o.pubBytes(), e).mul(o.priv()), M2 = f2.add(y3).umod(this.curve.n);
      return this.makeSignature({ R: p2, S: M2, Rencoded: m2 });
    };
    nr.prototype.verify = function(e, r, o) {
      e = Ry(e), r = this.makeSignature(r);
      var f2 = this.keyFromPublic(o), p2 = this.hashInt(r.Rencoded(), f2.pubBytes(), e), m2 = this.g.mul(r.S()), y3 = r.R().add(f2.pub().mul(p2));
      return y3.eq(m2);
    };
    nr.prototype.hashInt = function() {
      for (var e = this.hash(), r = 0;r < arguments.length; r++)
        e.update(arguments[r]);
      return Of.intFromLE(e.digest()).umod(this.curve.n);
    };
    nr.prototype.keyFromPublic = function(e) {
      return By.fromPublic(this, e);
    };
    nr.prototype.keyFromSecret = function(e) {
      return By.fromSecret(this, e);
    };
    nr.prototype.makeSignature = function(e) {
      return e instanceof Ay ? e : new Ay(this, e);
    };
    nr.prototype.encodePoint = function(e) {
      var r = e.getY().toArray("le", this.encodingLength);
      return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
    };
    nr.prototype.decodePoint = function(e) {
      e = Of.parseBytes(e);
      var r = e.length - 1, o = e.slice(0, r).concat(e[r] & -129), f2 = (e[r] & 128) !== 0, p2 = Of.intFromLE(o);
      return this.curve.pointFromY(p2, f2);
    };
    nr.prototype.encodeInt = function(e) {
      return e.toArray("le", this.encodingLength);
    };
    nr.prototype.decodeInt = function(e) {
      return Of.intFromLE(e);
    };
    nr.prototype.isPoint = function(e) {
      return e instanceof this.pointClass;
    };
  });
  o0 = T2((Ty) => {
    var Hn = Ty;
    Hn.version = s2().version;
    Hn.utils = or();
    Hn.rand = As();
    Hn.curve = Pl();
    Hn.curves = t0();
    Hn.ec = yy();
    Hn.eddsa = Iy();
  });
  td = T2((ky, ed) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a2 = function() {
        };
        a2.prototype = i.prototype, v.prototype = new a2, v.prototype.constructor = v;
      }
      function f2(v, i, a2) {
        if (f2.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v || 0, i || 10, a2 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a2) {
        return i.cmp(a2) > 0 ? i : a2;
      }, f2.min = function(i, a2) {
        return i.cmp(a2) < 0 ? i : a2;
      }, f2.prototype._init = function(i, a2, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a2, h3);
        if (typeof i == "object")
          return this._initArray(i, a2, h3);
        a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a2 === 16 ? this._parseHex(i, s3, h3) : (this._parseBase(i, a2, s3), h3 === "le" && this._initArray(this.toArray(), a2, h3)));
      }, f2.prototype._initNumber = function(i, a2, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a2, h3);
      }, f2.prototype._initArray = function(i, a2, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3, c2, b3 = 0;
        if (h3 === "be")
          for (s3 = i.length - 1, u3 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u3] |= c2 << b3 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u3++);
        else if (h3 === "le")
          for (s3 = 0, u3 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u3] |= c2 << b3 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u3++);
        return this.strip();
      };
      function m2(v, i) {
        var a2 = v.charCodeAt(i);
        return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
      }
      function y3(v, i, a2) {
        var h3 = m2(v, a2);
        return a2 - 1 >= i && (h3 |= m2(v, a2 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a2, h3) {
        this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3 = 0, c2 = 0, b3;
        if (h3 === "be")
          for (s3 = i.length - 1;s3 >= a2; s3 -= 2)
            b3 = y3(i, a2, s3) << u3, this.words[c2] |= b3 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b3 >>> 26) : u3 += 8;
        else {
          var l2 = i.length - a2;
          for (s3 = l2 % 2 === 0 ? a2 + 1 : a2;s3 < i.length; s3 += 2)
            b3 = y3(i, a2, s3) << u3, this.words[c2] |= b3 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b3 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M2(v, i, a2, h3) {
        for (var s3 = 0, u3 = Math.min(v.length, a2), c2 = i;c2 < u3; c2++) {
          var b3 = v.charCodeAt(c2) - 48;
          s3 *= h3, b3 >= 49 ? s3 += b3 - 49 + 10 : b3 >= 17 ? s3 += b3 - 17 + 10 : s3 += b3;
        }
        return s3;
      }
      f2.prototype._parseBase = function(i, a2, h3) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u3 = 1;u3 <= 67108863; u3 *= a2)
          s3++;
        s3--, u3 = u3 / a2 | 0;
        for (var c2 = i.length - h3, b3 = c2 % s3, l2 = Math.min(c2, c2 - b3) + h3, n = 0, d2 = h3;d2 < l2; d2 += s3)
          n = M2(i, d2, d2 + s3, a2), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b3 !== 0) {
          var w = 1;
          for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
            w *= a2;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a2 = 0;a2 < this.length; a2++)
          i.words[a2] = this.words[a2];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a2) {
        i = i || 10, a2 = a2 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s3 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b3 = this.words[c2], l2 = ((b3 << s3 | u3) & 16777215).toString(16);
            u3 = b3 >>> 24 - s3 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l2.length] + l2 + h3 : h3 = l2 + h3, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u3 !== 0 && (h3 = u3.toString(16) + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d2 = E3[i];
          h3 = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g3 = w.modn(d2).toString(i);
            w = w.idivn(d2), w.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a2) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
      }, f2.prototype.toArray = function(i, a2) {
        return this.toArrayLike(Array, i, a2);
      }, f2.prototype.toArrayLike = function(i, a2, h3) {
        var s3 = this.byteLength(), u3 = h3 || Math.max(1, s3);
        r(s3 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a2 === "le", b3 = new i(u3), l2, n, d2 = this.clone();
        if (c2) {
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
          for (;n < u3; n++)
            b3[n] = 0;
        } else {
          for (n = 0;n < u3 - s3; n++)
            b3[n] = 0;
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b3[u3 - n - 1] = l2;
        }
        return b3;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a2 = i, h3 = 0;
        return a2 >= 4096 && (h3 += 13, a2 >>>= 13), a2 >= 64 && (h3 += 7, a2 >>>= 7), a2 >= 8 && (h3 += 4, a2 >>>= 4), a2 >= 2 && (h3 += 2, a2 >>>= 2), h3 + a2;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a2 = i, h3 = 0;
        return (a2 & 8191) === 0 && (h3 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h3 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h3 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h3 += 2, a2 >>>= 2), (a2 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a2 = this._countBits(i);
        return (this.length - 1) * 26 + a2;
      };
      function B3(v) {
        for (var i = new Array(v.bitLength()), a2 = 0;a2 < i.length; a2++) {
          var h3 = a2 / 26 | 0, s3 = a2 % 26;
          i[a2] = (v.words[h3] & 1 << s3) >>> s3;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a2 = 0;a2 < this.length; a2++) {
          var h3 = this._zeroBits(this.words[a2]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a2 = 0;a2 < i.length; a2++)
          this.words[a2] = this.words[a2] | i.words[a2];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a2;
        this.length > i.length ? a2 = i : a2 = this;
        for (var h3 = 0;h3 < a2.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a2, h3;
        this.length > i.length ? (a2 = this, h3 = i) : (a2 = i, h3 = this);
        for (var s3 = 0;s3 < h3.length; s3++)
          this.words[s3] = a2.words[s3] ^ h3.words[s3];
        if (this !== a2)
          for (;s3 < a2.length; s3++)
            this.words[s3] = a2.words[s3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a2), h3 > 0 && a2--;
        for (var s3 = 0;s3 < a2; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h3 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a2) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s3 = i % 26;
        return this._expand(h3 + 1), a2 ? this.words[h3] = this.words[h3] | 1 << s3 : this.words[h3] = this.words[h3] & ~(1 << s3), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a2;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
        var h3, s3;
        this.length > i.length ? (h3 = this, s3 = i) : (h3 = i, s3 = this);
        for (var u3 = 0, c2 = 0;c2 < s3.length; c2++)
          a2 = (h3.words[c2] | 0) + (s3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        for (;u3 !== 0 && c2 < h3.length; c2++)
          a2 = (h3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        if (this.length = h3.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a2;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a2 = this.iadd(i);
          return i.negative = 1, a2._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u3;
        h3 > 0 ? (s3 = this, u3 = i) : (s3 = i, u3 = this);
        for (var c2 = 0, b3 = 0;b3 < u3.length; b3++)
          a2 = (s3.words[b3] | 0) - (u3.words[b3] | 0) + c2, c2 = a2 >> 26, this.words[b3] = a2 & 67108863;
        for (;c2 !== 0 && b3 < s3.length; b3++)
          a2 = (s3.words[b3] | 0) + c2, c2 = a2 >> 26, this.words[b3] = a2 & 67108863;
        if (c2 === 0 && b3 < s3.length && s3 !== this)
          for (;b3 < s3.length; b3++)
            this.words[b3] = s3.words[b3];
        return this.length = Math.max(this.length, b3), s3 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q2(v, i, a2) {
        a2.negative = i.negative ^ v.negative;
        var h3 = v.length + i.length | 0;
        a2.length = h3, h3 = h3 - 1 | 0;
        var s3 = v.words[0] | 0, u3 = i.words[0] | 0, c2 = s3 * u3, b3 = c2 & 67108863, l2 = c2 / 67108864 | 0;
        a2.words[0] = b3;
        for (var n = 1;n < h3; n++) {
          for (var d2 = l2 >>> 26, w = l2 & 67108863, g3 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v.length + 1);_3 <= g3; _3++) {
            var A2 = n - _3 | 0;
            s3 = v.words[A2] | 0, u3 = i.words[_3] | 0, c2 = s3 * u3 + w, d2 += c2 / 67108864 | 0, w = c2 & 67108863;
          }
          a2.words[n] = w | 0, l2 = d2 | 0;
        }
        return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
      }
      var L3 = function(i, a2, h3) {
        var s3 = i.words, u3 = a2.words, c2 = h3.words, b3 = 0, l2, n, d2, w = s3[0] | 0, g3 = w & 8191, _3 = w >>> 13, A2 = s3[1] | 0, R2 = A2 & 8191, I3 = A2 >>> 13, Me = s3[2] | 0, k3 = Me & 8191, D2 = Me >>> 13, nt = s3[3] | 0, C = nt & 8191, O3 = nt >>> 13, vt = s3[4] | 0, F = vt & 8191, U3 = vt >>> 13, bt = s3[5] | 0, z = bt & 8191, H2 = bt >>> 13, mt = s3[6] | 0, W = mt & 8191, K2 = mt >>> 13, gt = s3[7] | 0, j3 = gt & 8191, Z3 = gt >>> 13, yt = s3[8] | 0, V3 = yt & 8191, $2 = yt >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y2 = wt >>> 13, Mt = u3[0] | 0, X3 = Mt & 8191, J2 = Mt >>> 13, _t = u3[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u3[2] | 0, te = xt & 8191, re = xt >>> 13, St = u3[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u3[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u3[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u3[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u3[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u3[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u3[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a2.negative, h3.length = 19, l2 = Math.imul(g3, X3), n = Math.imul(g3, J2), n = n + Math.imul(_3, X3) | 0, d2 = Math.imul(_3, J2);
        var ft = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l2 = Math.imul(R2, X3), n = Math.imul(R2, J2), n = n + Math.imul(I3, X3) | 0, d2 = Math.imul(I3, J2), l2 = l2 + Math.imul(g3, Q3) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_3, Q3) | 0, d2 = d2 + Math.imul(_3, ee) | 0;
        var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k3, X3), n = Math.imul(k3, J2), n = n + Math.imul(D2, X3) | 0, d2 = Math.imul(D2, J2), l2 = l2 + Math.imul(R2, Q3) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I3, Q3) | 0, d2 = d2 + Math.imul(I3, ee) | 0, l2 = l2 + Math.imul(g3, te) | 0, n = n + Math.imul(g3, re) | 0, n = n + Math.imul(_3, te) | 0, d2 = d2 + Math.imul(_3, re) | 0;
        var qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l2 = Math.imul(C, X3), n = Math.imul(C, J2), n = n + Math.imul(O3, X3) | 0, d2 = Math.imul(O3, J2), l2 = l2 + Math.imul(k3, Q3) | 0, n = n + Math.imul(k3, ee) | 0, n = n + Math.imul(D2, Q3) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R2, te) | 0, n = n + Math.imul(R2, re) | 0, n = n + Math.imul(I3, te) | 0, d2 = d2 + Math.imul(I3, re) | 0, l2 = l2 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_3, ie) | 0, d2 = d2 + Math.imul(_3, ne) | 0;
        var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F, X3), n = Math.imul(F, J2), n = n + Math.imul(U3, X3) | 0, d2 = Math.imul(U3, J2), l2 = l2 + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O3, Q3) | 0, d2 = d2 + Math.imul(O3, ee) | 0, l2 = l2 + Math.imul(k3, te) | 0, n = n + Math.imul(k3, re) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re) | 0, l2 = l2 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I3, ie) | 0, d2 = d2 + Math.imul(I3, ne) | 0, l2 = l2 + Math.imul(g3, fe) | 0, n = n + Math.imul(g3, ae) | 0, n = n + Math.imul(_3, fe) | 0, d2 = d2 + Math.imul(_3, ae) | 0;
        var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X3), n = Math.imul(z, J2), n = n + Math.imul(H2, X3) | 0, d2 = Math.imul(H2, J2), l2 = l2 + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U3, Q3) | 0, d2 = d2 + Math.imul(U3, ee) | 0, l2 = l2 + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O3, te) | 0, d2 = d2 + Math.imul(O3, re) | 0, l2 = l2 + Math.imul(k3, ie) | 0, n = n + Math.imul(k3, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R2, fe) | 0, n = n + Math.imul(R2, ae) | 0, n = n + Math.imul(I3, fe) | 0, d2 = d2 + Math.imul(I3, ae) | 0, l2 = l2 + Math.imul(g3, oe) | 0, n = n + Math.imul(g3, se) | 0, n = n + Math.imul(_3, oe) | 0, d2 = d2 + Math.imul(_3, se) | 0;
        var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X3), n = Math.imul(W, J2), n = n + Math.imul(K2, X3) | 0, d2 = Math.imul(K2, J2), l2 = l2 + Math.imul(z, Q3) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q3) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U3, te) | 0, d2 = d2 + Math.imul(U3, re) | 0, l2 = l2 + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O3, ie) | 0, d2 = d2 + Math.imul(O3, ne) | 0, l2 = l2 + Math.imul(k3, fe) | 0, n = n + Math.imul(k3, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R2, oe) | 0, n = n + Math.imul(R2, se) | 0, n = n + Math.imul(I3, oe) | 0, d2 = d2 + Math.imul(I3, se) | 0, l2 = l2 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue) | 0, n = n + Math.imul(_3, he) | 0, d2 = d2 + Math.imul(_3, ue) | 0;
        var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j3, X3), n = Math.imul(j3, J2), n = n + Math.imul(Z3, X3) | 0, d2 = Math.imul(Z3, J2), l2 = l2 + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q3) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re) | 0, l2 = l2 + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U3, ie) | 0, d2 = d2 + Math.imul(U3, ne) | 0, l2 = l2 + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O3, fe) | 0, d2 = d2 + Math.imul(O3, ae) | 0, l2 = l2 + Math.imul(k3, oe) | 0, n = n + Math.imul(k3, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue) | 0, n = n + Math.imul(I3, he) | 0, d2 = d2 + Math.imul(I3, ue) | 0, l2 = l2 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_3, le) | 0, d2 = d2 + Math.imul(_3, de) | 0;
        var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X3), n = Math.imul(V3, J2), n = n + Math.imul($2, X3) | 0, d2 = Math.imul($2, J2), l2 = l2 + Math.imul(j3, Q3) | 0, n = n + Math.imul(j3, ee) | 0, n = n + Math.imul(Z3, Q3) | 0, d2 = d2 + Math.imul(Z3, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U3, fe) | 0, d2 = d2 + Math.imul(U3, ae) | 0, l2 = l2 + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O3, oe) | 0, d2 = d2 + Math.imul(O3, se) | 0, l2 = l2 + Math.imul(k3, he) | 0, n = n + Math.imul(k3, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I3, le) | 0, d2 = d2 + Math.imul(I3, de) | 0, l2 = l2 + Math.imul(g3, ce) | 0, n = n + Math.imul(g3, pe) | 0, n = n + Math.imul(_3, ce) | 0, d2 = d2 + Math.imul(_3, pe) | 0;
        var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G2, X3), n = Math.imul(G2, J2), n = n + Math.imul(Y2, X3) | 0, d2 = Math.imul(Y2, J2), l2 = l2 + Math.imul(V3, Q3) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q3) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j3, te) | 0, n = n + Math.imul(j3, re) | 0, n = n + Math.imul(Z3, te) | 0, d2 = d2 + Math.imul(Z3, re) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U3, oe) | 0, d2 = d2 + Math.imul(U3, se) | 0, l2 = l2 + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O3, he) | 0, d2 = d2 + Math.imul(O3, ue) | 0, l2 = l2 + Math.imul(k3, le) | 0, n = n + Math.imul(k3, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R2, ce) | 0, n = n + Math.imul(R2, pe) | 0, n = n + Math.imul(I3, ce) | 0, d2 = d2 + Math.imul(I3, pe) | 0, l2 = l2 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_3, ve) | 0, d2 = d2 + Math.imul(_3, be) | 0;
        var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G2, Q3), n = Math.imul(G2, ee), n = n + Math.imul(Y2, Q3) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re) | 0, l2 = l2 + Math.imul(j3, ie) | 0, n = n + Math.imul(j3, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d2 = d2 + Math.imul(Z3, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U3, he) | 0, d2 = d2 + Math.imul(U3, ue) | 0, l2 = l2 + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O3, le) | 0, d2 = d2 + Math.imul(O3, de) | 0, l2 = l2 + Math.imul(k3, ce) | 0, n = n + Math.imul(k3, pe) | 0, n = n + Math.imul(D2, ce) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I3, ve) | 0, d2 = d2 + Math.imul(I3, be) | 0;
        var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G2, te), n = Math.imul(G2, re), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j3, fe) | 0, n = n + Math.imul(j3, ae) | 0, n = n + Math.imul(Z3, fe) | 0, d2 = d2 + Math.imul(Z3, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U3, le) | 0, d2 = d2 + Math.imul(U3, de) | 0, l2 = l2 + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O3, ce) | 0, d2 = d2 + Math.imul(O3, pe) | 0, l2 = l2 + Math.imul(k3, ve) | 0, n = n + Math.imul(k3, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
        var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j3, oe) | 0, n = n + Math.imul(j3, se) | 0, n = n + Math.imul(Z3, oe) | 0, d2 = d2 + Math.imul(Z3, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U3, ce) | 0, d2 = d2 + Math.imul(U3, pe) | 0, l2 = l2 + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O3, ve) | 0, d2 = d2 + Math.imul(O3, be) | 0;
        var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G2, fe), n = Math.imul(G2, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j3, he) | 0, n = n + Math.imul(j3, ue) | 0, n = n + Math.imul(Z3, he) | 0, d2 = d2 + Math.imul(Z3, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U3, ve) | 0, d2 = d2 + Math.imul(U3, be) | 0;
        var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G2, oe), n = Math.imul(G2, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j3, le) | 0, n = n + Math.imul(j3, de) | 0, n = n + Math.imul(Z3, le) | 0, d2 = d2 + Math.imul(Z3, de) | 0, l2 = l2 + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
        var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G2, he), n = Math.imul(G2, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j3, ce) | 0, n = n + Math.imul(j3, pe) | 0, n = n + Math.imul(Z3, ce) | 0, d2 = d2 + Math.imul(Z3, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
        var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j3, ve) | 0, n = n + Math.imul(j3, be) | 0, n = n + Math.imul(Z3, ve) | 0, d2 = d2 + Math.imul(Z3, be) | 0;
        var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G2, ce), n = Math.imul(G2, pe), n = n + Math.imul(Y2, ce) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
        var tt = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l2 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
        var rt = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        return b3 = (d2 + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe, c2[3] = ze, c2[4] = He, c2[5] = We, c2[6] = Ke, c2[7] = je, c2[8] = Ze, c2[9] = Ve, c2[10] = $e, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe, c2[16] = et, c2[17] = tt, c2[18] = rt, b3 !== 0 && (c2[19] = b3, h3.length++), h3;
      };
      Math.imul || (L3 = q2);
      function ge(v, i, a2) {
        a2.negative = i.negative ^ v.negative, a2.length = v.length + i.length;
        for (var h3 = 0, s3 = 0, u3 = 0;u3 < a2.length - 1; u3++) {
          var c2 = s3;
          s3 = 0;
          for (var b3 = h3 & 67108863, l2 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v.length + 1);n <= l2; n++) {
            var d2 = u3 - n, w = v.words[d2] | 0, g3 = i.words[n] | 0, _3 = w * g3, A2 = _3 & 67108863;
            c2 = c2 + (_3 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c2 = c2 + (A2 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a2.words[u3] = b3, h3 = c2, c2 = s3;
        }
        return h3 !== 0 ? a2.words[u3] = h3 : a2.length--, a2.strip();
      }
      function _e(v, i, a2) {
        var h3 = new N3;
        return h3.mulp(v, i, a2);
      }
      f2.prototype.mulTo = function(i, a2) {
        var h3, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a2) : s3 < 63 ? h3 = q2(this, i, a2) : s3 < 1024 ? h3 = ge(this, i, a2) : h3 = _e(this, i, a2), h3;
      };
      function N3(v, i) {
        this.x = v, this.y = i;
      }
      N3.prototype.makeRBT = function(i) {
        for (var a2 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a2[s3] = this.revBin(s3, h3, i);
        return a2;
      }, N3.prototype.revBin = function(i, a2, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s3 = 0, u3 = 0;u3 < a2; u3++)
          s3 |= (i & 1) << a2 - u3 - 1, i >>= 1;
        return s3;
      }, N3.prototype.permute = function(i, a2, h3, s3, u3, c2) {
        for (var b3 = 0;b3 < c2; b3++)
          s3[b3] = a2[i[b3]], u3[b3] = h3[i[b3]];
      }, N3.prototype.transform = function(i, a2, h3, s3, u3, c2) {
        this.permute(c2, i, a2, h3, s3, u3);
        for (var b3 = 1;b3 < u3; b3 <<= 1)
          for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w = 0;w < u3; w += l2)
            for (var g3 = n, _3 = d2, A2 = 0;A2 < b3; A2++) {
              var R2 = h3[w + A2], I3 = s3[w + A2], Me = h3[w + A2 + b3], k3 = s3[w + A2 + b3], D2 = g3 * Me - _3 * k3;
              k3 = g3 * k3 + _3 * Me, Me = D2, h3[w + A2] = R2 + Me, s3[w + A2] = I3 + k3, h3[w + A2 + b3] = R2 - Me, s3[w + A2 + b3] = I3 - k3, A2 !== l2 && (D2 = n * g3 - d2 * _3, _3 = n * _3 + d2 * g3, g3 = D2);
            }
      }, N3.prototype.guessLen13b = function(i, a2) {
        var h3 = Math.max(a2, i) | 1, s3 = h3 & 1, u3 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u3++;
        return 1 << u3 + 1 + s3;
      }, N3.prototype.conjugate = function(i, a2, h3) {
        if (!(h3 <= 1))
          for (var s3 = 0;s3 < h3 / 2; s3++) {
            var u3 = i[s3];
            i[s3] = i[h3 - s3 - 1], i[h3 - s3 - 1] = u3, u3 = a2[s3], a2[s3] = -a2[h3 - s3 - 1], a2[h3 - s3 - 1] = -u3;
          }
      }, N3.prototype.normalize13b = function(i, a2) {
        for (var h3 = 0, s3 = 0;s3 < a2 / 2; s3++) {
          var u3 = Math.round(i[2 * s3 + 1] / a2) * 8192 + Math.round(i[2 * s3] / a2) + h3;
          i[s3] = u3 & 67108863, u3 < 67108864 ? h3 = 0 : h3 = u3 / 67108864 | 0;
        }
        return i;
      }, N3.prototype.convert13b = function(i, a2, h3, s3) {
        for (var u3 = 0, c2 = 0;c2 < a2; c2++)
          u3 = u3 + (i[c2] | 0), h3[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h3[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a2;c2 < s3; ++c2)
          h3[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N3.prototype.stub = function(i) {
        for (var a2 = new Array(i), h3 = 0;h3 < i; h3++)
          a2[h3] = 0;
        return a2;
      }, N3.prototype.mulp = function(i, a2, h3) {
        var s3 = 2 * this.guessLen13b(i.length, a2.length), u3 = this.makeRBT(s3), c2 = this.stub(s3), b3 = new Array(s3), l2 = new Array(s3), n = new Array(s3), d2 = new Array(s3), w = new Array(s3), g3 = new Array(s3), _3 = h3.words;
        _3.length = s3, this.convert13b(i.words, i.length, b3, s3), this.convert13b(a2.words, a2.length, d2, s3), this.transform(b3, c2, l2, n, s3, u3), this.transform(d2, c2, w, g3, s3, u3);
        for (var A2 = 0;A2 < s3; A2++) {
          var R2 = l2[A2] * w[A2] - n[A2] * g3[A2];
          n[A2] = l2[A2] * g3[A2] + n[A2] * w[A2], l2[A2] = R2;
        }
        return this.conjugate(l2, n, s3), this.transform(l2, n, _3, c2, s3, u3), this.conjugate(_3, c2, s3), this.normalize13b(_3, s3), h3.negative = i.negative ^ a2.negative, h3.length = i.length + a2.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
      }, f2.prototype.mulf = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), _e(this, i, a2);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a2 = 0, h3 = 0;h3 < this.length; h3++) {
          var s3 = (this.words[h3] | 0) * i, u3 = (s3 & 67108863) + (a2 & 67108863);
          a2 >>= 26, a2 += s3 / 67108864 | 0, a2 += u3 >>> 26, this.words[h3] = u3 & 67108863;
        }
        return a2 !== 0 && (this.words[h3] = a2, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a2 = B3(i);
        if (a2.length === 0)
          return new f2(1);
        for (var h3 = this, s3 = 0;s3 < a2.length && a2[s3] === 0; s3++, h3 = h3.sqr())
          ;
        if (++s3 < a2.length)
          for (var u3 = h3.sqr();s3 < a2.length; s3++, u3 = u3.sqr())
            a2[s3] !== 0 && (h3 = h3.mul(u3));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 67108863 >>> 26 - a2 << 26 - a2, u3;
        if (a2 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b3 = this.words[u3] & s3, l2 = (this.words[u3] | 0) - b3 << a2;
            this.words[u3] = l2 | c2, c2 = b3 >>> 26 - a2;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h3] = this.words[u3];
          for (u3 = 0;u3 < h3; u3++)
            this.words[u3] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a2, h3) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a2 ? s3 = (a2 - a2 % 26) / 26 : s3 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u3 << u3, l2 = h3;
        if (s3 -= c2, s3 = Math.max(0, s3), l2) {
          for (var n = 0;n < c2; n++)
            l2.words[n] = this.words[n];
          l2.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d2 = 0;
        for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s3); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d2 << 26 - u3 | w >>> u3, d2 = w & b3;
        }
        return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a2, h3) {
        return r(this.negative === 0), this.iushrn(i, a2, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 1 << a2;
        if (this.length <= h3)
          return false;
        var u3 = this.words[h3];
        return !!(u3 & s3);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a2 !== 0 && h3++, this.length = Math.min(h3, this.length), a2 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a2 << a2;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
          this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
        return this.length = Math.max(this.length, a2 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
            this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a2, h3) {
        var s3 = i.length + h3, u3;
        this._expand(s3);
        var c2, b3 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h3] | 0) + b3;
          var l2 = (i.words[u3] | 0) * a2;
          c2 -= l2 & 67108863, b3 = (c2 >> 26) - (l2 / 67108864 | 0), this.words[u3 + h3] = c2 & 67108863;
        }
        for (;u3 < this.length - h3; u3++)
          c2 = (this.words[u3 + h3] | 0) + b3, b3 = c2 >> 26, this.words[u3 + h3] = c2 & 67108863;
        if (b3 === 0)
          return this.strip();
        for (r(b3 === -1), b3 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b3, b3 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a2) {
        var h3 = this.length - i.length, s3 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b3 = this._countBits(c2);
        h3 = 26 - b3, h3 !== 0 && (u3 = u3.ushln(h3), s3.iushln(h3), c2 = u3.words[u3.length - 1] | 0);
        var l2 = s3.length - u3.length, n;
        if (a2 !== "mod") {
          n = new f2(null), n.length = l2 + 1, n.words = new Array(n.length);
          for (var d2 = 0;d2 < n.length; d2++)
            n.words[d2] = 0;
        }
        var w = s3.clone()._ishlnsubmul(u3, 1, l2);
        w.negative === 0 && (s3 = w, n && (n.words[l2] = 1));
        for (var g3 = l2 - 1;g3 >= 0; g3--) {
          var _3 = (s3.words[u3.length + g3] | 0) * 67108864 + (s3.words[u3.length + g3 - 1] | 0);
          for (_3 = Math.min(_3 / c2 | 0, 67108863), s3._ishlnsubmul(u3, _3, g3);s3.negative !== 0; )
            _3--, s3.negative = 0, s3._ishlnsubmul(u3, 1, g3), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g3] = _3);
        }
        return n && n.strip(), s3.strip(), a2 !== "div" && h3 !== 0 && s3.iushrn(h3), { div: n || null, mod: s3 };
      }, f2.prototype.divmod = function(i, a2, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s3, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a2), a2 !== "mod" && (s3 = c2.div.neg()), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.iadd(i)), { div: s3, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a2), a2 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a2);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a2 = this.divmod(i);
        if (a2.mod.isZero())
          return a2.div;
        var h3 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s3 = i.ushrn(1), u3 = i.andln(1), c2 = h3.cmp(s3);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a2 = (1 << 26) % i, h3 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h3 = (a2 * h3 + (this.words[s3] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = (this.words[h3] | 0) + a2 * 67108864;
          this.words[h3] = s3 / i | 0, a2 = s3 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s3 = new f2(1), u3 = new f2(0), c2 = new f2(0), b3 = new f2(1), l2 = 0;a2.isEven() && h3.isEven(); )
          a2.iushrn(1), h3.iushrn(1), ++l2;
        for (var n = h3.clone(), d2 = a2.clone();!a2.isZero(); ) {
          for (var w = 0, g3 = 1;(a2.words[0] & g3) === 0 && w < 26; ++w, g3 <<= 1)
            ;
          if (w > 0)
            for (a2.iushrn(w);w-- > 0; )
              (s3.isOdd() || u3.isOdd()) && (s3.iadd(n), u3.isub(d2)), s3.iushrn(1), u3.iushrn(1);
          for (var _3 = 0, A2 = 1;(h3.words[0] & A2) === 0 && _3 < 26; ++_3, A2 <<= 1)
            ;
          if (_3 > 0)
            for (h3.iushrn(_3);_3-- > 0; )
              (c2.isOdd() || b3.isOdd()) && (c2.iadd(n), b3.isub(d2)), c2.iushrn(1), b3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s3.isub(c2), u3.isub(b3)) : (h3.isub(a2), c2.isub(s3), b3.isub(u3));
        }
        return { a: c2, b: b3, gcd: h3.iushln(l2) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s3 = new f2(1), u3 = new f2(0), c2 = h3.clone();a2.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
            ;
          if (b3 > 0)
            for (a2.iushrn(b3);b3-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d2 = 1;(h3.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s3.isub(u3)) : (h3.isub(a2), u3.isub(s3));
        }
        var w;
        return a2.cmpn(1) === 0 ? w = s3 : w = u3, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a2 = this.clone(), h3 = i.clone();
        a2.negative = 0, h3.negative = 0;
        for (var s3 = 0;a2.isEven() && h3.isEven(); s3++)
          a2.iushrn(1), h3.iushrn(1);
        do {
          for (;a2.isEven(); )
            a2.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u3 = a2.cmp(h3);
          if (u3 < 0) {
            var c2 = a2;
            a2 = h3, h3 = c2;
          } else if (u3 === 0 || h3.cmpn(1) === 0)
            break;
          a2.isub(h3);
        } while (true);
        return h3.iushln(s3);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 1 << a2;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s3, this;
        for (var u3 = s3, c2 = h3;u3 !== 0 && c2 < this.length; c2++) {
          var b3 = this.words[c2] | 0;
          b3 += u3, u3 = b3 >>> 26, b3 &= 67108863, this.words[c2] = b3;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a2 = i < 0;
        if (this.negative !== 0 && !a2)
          return -1;
        if (this.negative === 0 && a2)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a2 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h3 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a2 = this.ucmp(i);
        return this.negative !== 0 ? -a2 | 0 : a2;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = this.words[h3] | 0, u3 = i.words[h3] | 0;
          if (s3 !== u3) {
            s3 < u3 ? a2 = -1 : s3 > u3 && (a2 = 1);
            break;
          }
        }
        return a2;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a2 = i, h3;
        do
          this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h3 = a2.bitLength();
        while (h3 > this.n);
        var s3 = h3 < this.n ? -1 : a2.ucmp(this.p);
        return s3 === 0 ? (a2.words[0] = 0, a2.length = 1) : s3 > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
      }, ye.prototype.split = function(i, a2) {
        i.iushrn(this.n, 0, a2);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a2) {
        for (var h3 = 4194303, s3 = Math.min(i.length, 9), u3 = 0;u3 < s3; u3++)
          a2.words[u3] = i.words[u3];
        if (a2.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a2.words[a2.length++] = c2 & h3, u3 = 10;u3 < i.length; u3++) {
          var b3 = i.words[u3] | 0;
          i.words[u3 - 10] = (b3 & h3) << 4 | c2 >>> 22, c2 = b3;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = i.words[h3] | 0;
          a2 += s3 * 977, i.words[h3] = a2 & 67108863, a2 = s3 * 64 + (a2 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = (i.words[h3] | 0) * 19 + a2, u3 = s3 & 67108863;
          s3 >>>= 26, i.words[h3] = u3, a2 = s3;
        }
        return a2 !== 0 && (i.words[i.length++] = a2), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a2;
        if (i === "k256")
          a2 = new xe;
        else if (i === "p224")
          a2 = new Re;
        else if (i === "p192")
          a2 = new Ee;
        else if (i === "p25519")
          a2 = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a2, a2;
      };
      function P2(v) {
        if (typeof v == "string") {
          var i = f2._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a2) {
        r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.add(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.iadd(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.sub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.isub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a2) {
        return this._verify1(i), this.imod(i.ushln(a2));
      }, P2.prototype.imul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.imul(a2));
      }, P2.prototype.mul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.mul(a2));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a2 = this.m.andln(3);
        if (r(a2 % 2 === 1), a2 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s3 = this.m.subn(1), u3 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u3++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f2(1).toRed(this), b3 = c2.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
          n.redIAdd(b3);
        for (var d2 = this.pow(n, s3), w = this.pow(i, s3.addn(1).iushrn(1)), g3 = this.pow(i, s3), _3 = u3;g3.cmp(c2) !== 0; ) {
          for (var A2 = g3, R2 = 0;A2.cmp(c2) !== 0; R2++)
            A2 = A2.redSqr();
          r(R2 < _3);
          var I3 = this.pow(d2, new f2(1).iushln(_3 - R2 - 1));
          w = w.redMul(I3), d2 = I3.redSqr(), g3 = g3.redMul(d2), _3 = R2;
        }
        return w;
      }, P2.prototype.invm = function(i) {
        var a2 = i._invmp(this.m);
        return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
      }, P2.prototype.pow = function(i, a2) {
        if (a2.isZero())
          return new f2(1).toRed(this);
        if (a2.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s3 = new Array(1 << h3);
        s3[0] = new f2(1).toRed(this), s3[1] = i;
        for (var u3 = 2;u3 < s3.length; u3++)
          s3[u3] = this.mul(s3[u3 - 1], i);
        var c2 = s3[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a2.length - 1;u3 >= 0; u3--) {
          for (var d2 = a2.words[u3], w = n - 1;w >= 0; w--) {
            var g3 = d2 >> w & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g3 === 0 && b3 === 0) {
              l2 = 0;
              continue;
            }
            b3 <<= 1, b3 |= g3, l2++, !(l2 !== h3 && (u3 !== 0 || w !== 0)) && (c2 = this.mul(c2, s3[b3]), l2 = 0, b3 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a2 = i.umod(this.m);
        return a2 === i ? a2.clone() : a2;
      }, P2.prototype.convertFrom = function(i) {
        var a2 = i.clone();
        return a2.red = null, a2;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P2.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a2 = this.imod(i.mul(this.rinv));
        return a2.red = null, a2;
      }, Se.prototype.imul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a2), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.mul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a2), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a2 = this.imod(i._invmp(this.m).mul(this.r2));
        return a2._forceRed(this);
      };
    })(typeof ed > "u" || ed, ky);
  });
  h0 = T2((Yk, Ly) => {
    var s0 = Ut(), Ff = s0.Buffer, Er = {}, Ar;
    for (Ar in s0)
      !s0.hasOwnProperty(Ar) || Ar === "SlowBuffer" || Ar === "Buffer" || (Er[Ar] = s0[Ar]);
    var Uf = Er.Buffer = {};
    for (Ar in Ff)
      !Ff.hasOwnProperty(Ar) || Ar === "allocUnsafe" || Ar === "allocUnsafeSlow" || (Uf[Ar] = Ff[Ar]);
    Er.Buffer.prototype = Ff.prototype;
    (!Uf.from || Uf.from === Uint8Array.from) && (Uf.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
      if (t && typeof t.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      return Ff(t, e, r);
    });
    Uf.alloc || (Uf.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
      if (t < 0 || t >= 2 * (1 << 30))
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      var o = Ff(t);
      return !e || e.length === 0 ? o.fill(0) : typeof r == "string" ? o.fill(e, r) : o.fill(e), o;
    });
    if (!Er.kStringMaxLength)
      try {
        Er.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {
      }
    Er.constants || (Er.constants = { MAX_LENGTH: Er.kMaxLength }, Er.kStringMaxLength && (Er.constants.MAX_STRING_LENGTH = Er.kStringMaxLength));
    Ly.exports = Er;
  });
  u0 = T2((Ny) => {
    var aB = Ie();
    function Rr(t) {
      this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
    }
    Ny.Reporter = Rr;
    Rr.prototype.isError = function(e) {
      return e instanceof zf;
    };
    Rr.prototype.save = function() {
      let e = this._reporterState;
      return { obj: e.obj, pathLen: e.path.length };
    };
    Rr.prototype.restore = function(e) {
      let r = this._reporterState;
      r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
    };
    Rr.prototype.enterKey = function(e) {
      return this._reporterState.path.push(e);
    };
    Rr.prototype.exitKey = function(e) {
      let r = this._reporterState;
      r.path = r.path.slice(0, e - 1);
    };
    Rr.prototype.leaveKey = function(e, r, o) {
      let f2 = this._reporterState;
      this.exitKey(e), f2.obj !== null && (f2.obj[r] = o);
    };
    Rr.prototype.path = function() {
      return this._reporterState.path.join("/");
    };
    Rr.prototype.enterObject = function() {
      let e = this._reporterState, r = e.obj;
      return e.obj = {}, r;
    };
    Rr.prototype.leaveObject = function(e) {
      let r = this._reporterState, o = r.obj;
      return r.obj = e, o;
    };
    Rr.prototype.error = function(e) {
      let r, o = this._reporterState, f2 = e instanceof zf;
      if (f2 ? r = e : r = new zf(o.path.map(function(p2) {
        return "[" + JSON.stringify(p2) + "]";
      }).join(""), e.message || e, e.stack), !o.options.partial)
        throw r;
      return f2 || o.errors.push(r), r;
    };
    Rr.prototype.wrapResult = function(e) {
      let r = this._reporterState;
      return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
    };
    function zf(t, e) {
      this.path = t, this.rethrow(e);
    }
    aB(zf, Error);
    zf.prototype.rethrow = function(e) {
      if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, zf), !this.stack)
        try {
          throw new Error(this.message);
        } catch (r) {
          this.stack = r.stack;
        }
      return this;
    };
  });
  Kf = T2((rd) => {
    var oB = Ie(), l0 = u0().Reporter, Hf = h0().Buffer;
    function Br(t, e) {
      if (l0.call(this, e), !Hf.isBuffer(t)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = t, this.offset = 0, this.length = t.length;
    }
    oB(Br, l0);
    rd.DecoderBuffer = Br;
    Br.isDecoderBuffer = function(e) {
      return e instanceof Br ? true : typeof e == "object" && Hf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    Br.prototype.save = function() {
      return { offset: this.offset, reporter: l0.prototype.save.call(this) };
    };
    Br.prototype.restore = function(e) {
      let r = new Br(this.base);
      return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, l0.prototype.restore.call(this, e.reporter), r;
    };
    Br.prototype.isEmpty = function() {
      return this.offset === this.length;
    };
    Br.prototype.readUInt8 = function(e) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
    };
    Br.prototype.skip = function(e, r) {
      if (!(this.offset + e <= this.length))
        return this.error(r || "DecoderBuffer overrun");
      let o = new Br(this.base);
      return o._reporterState = this._reporterState, o.offset = this.offset, o.length = this.offset + e, this.offset += e, o;
    };
    Br.prototype.raw = function(e) {
      return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function Wf(t, e) {
      if (Array.isArray(t))
        this.length = 0, this.value = t.map(function(r) {
          return Wf.isEncoderBuffer(r) || (r = new Wf(r, e)), this.length += r.length, r;
        }, this);
      else if (typeof t == "number") {
        if (!(0 <= t && t <= 255))
          return e.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1;
      } else if (typeof t == "string")
        this.value = t, this.length = Hf.byteLength(t);
      else if (Hf.isBuffer(t))
        this.value = t, this.length = t.length;
      else
        return e.error("Unsupported type: " + typeof t);
    }
    rd.EncoderBuffer = Wf;
    Wf.isEncoderBuffer = function(e) {
      return e instanceof Wf ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    Wf.prototype.join = function(e, r) {
      return e || (e = Hf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o) {
        o.join(e, r), r += o.length;
      }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : Hf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
    };
  });
  d0 = T2((Qk, Py) => {
    var sB = u0().Reporter, hB = Kf().EncoderBuffer, uB = Kf().DecoderBuffer, Qt = ar(), Dy = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], lB = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Dy), dB = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Ue(t, e, r) {
      let o = {};
      this._baseState = o, o.name = r, o.enc = t, o.parent = e || null, o.children = null, o.tag = null, o.args = null, o.reverseArgs = null, o.choice = null, o.optional = false, o.any = false, o.obj = false, o.use = null, o.useDecoder = null, o.key = null, o.default = null, o.explicit = null, o.implicit = null, o.contains = null, o.parent || (o.children = [], this._wrap());
    }
    Py.exports = Ue;
    var cB = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Ue.prototype.clone = function() {
      let e = this._baseState, r = {};
      cB.forEach(function(f2) {
        r[f2] = e[f2];
      });
      let o = new this.constructor(r.parent);
      return o._baseState = r, o;
    };
    Ue.prototype._wrap = function() {
      let e = this._baseState;
      lB.forEach(function(r) {
        this[r] = function() {
          let f2 = new this.constructor(this);
          return e.children.push(f2), f2[r].apply(f2, arguments);
        };
      }, this);
    };
    Ue.prototype._init = function(e) {
      let r = this._baseState;
      Qt(r.parent === null), e.call(this), r.children = r.children.filter(function(o) {
        return o._baseState.parent === this;
      }, this), Qt.equal(r.children.length, 1, "Root node can have only one child");
    };
    Ue.prototype._useArgs = function(e) {
      let r = this._baseState, o = e.filter(function(f2) {
        return f2 instanceof this.constructor;
      }, this);
      e = e.filter(function(f2) {
        return !(f2 instanceof this.constructor);
      }, this), o.length !== 0 && (Qt(r.children === null), r.children = o, o.forEach(function(f2) {
        f2._baseState.parent = this;
      }, this)), e.length !== 0 && (Qt(r.args === null), r.args = e, r.reverseArgs = e.map(function(f2) {
        if (typeof f2 != "object" || f2.constructor !== Object)
          return f2;
        let p2 = {};
        return Object.keys(f2).forEach(function(m2) {
          m2 == (m2 | 0) && (m2 |= 0);
          let y3 = f2[m2];
          p2[y3] = m2;
        }), p2;
      }));
    };
    dB.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc);
      };
    });
    Dy.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState, o = Array.prototype.slice.call(arguments);
        return Qt(r.tag === null), r.tag = t, this._useArgs(o), this;
      };
    });
    Ue.prototype.use = function(e) {
      Qt(e);
      let r = this._baseState;
      return Qt(r.use === null), r.use = e, this;
    };
    Ue.prototype.optional = function() {
      let e = this._baseState;
      return e.optional = true, this;
    };
    Ue.prototype.def = function(e) {
      let r = this._baseState;
      return Qt(r.default === null), r.default = e, r.optional = true, this;
    };
    Ue.prototype.explicit = function(e) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.explicit = e, this;
    };
    Ue.prototype.implicit = function(e) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.implicit = e, this;
    };
    Ue.prototype.obj = function() {
      let e = this._baseState, r = Array.prototype.slice.call(arguments);
      return e.obj = true, r.length !== 0 && this._useArgs(r), this;
    };
    Ue.prototype.key = function(e) {
      let r = this._baseState;
      return Qt(r.key === null), r.key = e, this;
    };
    Ue.prototype.any = function() {
      let e = this._baseState;
      return e.any = true, this;
    };
    Ue.prototype.choice = function(e) {
      let r = this._baseState;
      return Qt(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(o) {
        return e[o];
      })), this;
    };
    Ue.prototype.contains = function(e) {
      let r = this._baseState;
      return Qt(r.use === null), r.contains = e, this;
    };
    Ue.prototype._decode = function(e, r) {
      let o = this._baseState;
      if (o.parent === null)
        return e.wrapResult(o.children[0]._decode(e, r));
      let f2 = o.default, p2 = true, m2 = null;
      if (o.key !== null && (m2 = e.enterKey(o.key)), o.optional) {
        let M2 = null;
        if (o.explicit !== null ? M2 = o.explicit : o.implicit !== null ? M2 = o.implicit : o.tag !== null && (M2 = o.tag), M2 === null && !o.any) {
          let x3 = e.save();
          try {
            o.choice === null ? this._decodeGeneric(o.tag, e, r) : this._decodeChoice(e, r), p2 = true;
          } catch {
            p2 = false;
          }
          e.restore(x3);
        } else if (p2 = this._peekTag(e, M2, o.any), e.isError(p2))
          return p2;
      }
      let y3;
      if (o.obj && p2 && (y3 = e.enterObject()), p2) {
        if (o.explicit !== null) {
          let x3 = this._decodeTag(e, o.explicit);
          if (e.isError(x3))
            return x3;
          e = x3;
        }
        let M2 = e.offset;
        if (o.use === null && o.choice === null) {
          let x3;
          o.any && (x3 = e.save());
          let S2 = this._decodeTag(e, o.implicit !== null ? o.implicit : o.tag, o.any);
          if (e.isError(S2))
            return S2;
          o.any ? f2 = e.raw(x3) : e = S2;
        }
        if (r && r.track && o.tag !== null && r.track(e.path(), M2, e.length, "tagged"), r && r.track && o.tag !== null && r.track(e.path(), e.offset, e.length, "content"), o.any || (o.choice === null ? f2 = this._decodeGeneric(o.tag, e, r) : f2 = this._decodeChoice(e, r)), e.isError(f2))
          return f2;
        if (!o.any && o.choice === null && o.children !== null && o.children.forEach(function(S2) {
          S2._decode(e, r);
        }), o.contains && (o.tag === "octstr" || o.tag === "bitstr")) {
          let x3 = new uB(f2);
          f2 = this._getUse(o.contains, e._reporterState.obj)._decode(x3, r);
        }
      }
      return o.obj && p2 && (f2 = e.leaveObject(y3)), o.key !== null && (f2 !== null || p2 === true) ? e.leaveKey(m2, o.key, f2) : m2 !== null && e.exitKey(m2), f2;
    };
    Ue.prototype._decodeGeneric = function(e, r, o) {
      let f2 = this._baseState;
      return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, f2.args[0], o) : /str$/.test(e) ? this._decodeStr(r, e, o) : e === "objid" && f2.args ? this._decodeObjid(r, f2.args[0], f2.args[1], o) : e === "objid" ? this._decodeObjid(r, null, null, o) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, o) : e === "null_" ? this._decodeNull(r, o) : e === "bool" ? this._decodeBool(r, o) : e === "objDesc" ? this._decodeStr(r, e, o) : e === "int" || e === "enum" ? this._decodeInt(r, f2.args && f2.args[0], o) : f2.use !== null ? this._getUse(f2.use, r._reporterState.obj)._decode(r, o) : r.error("unknown tag: " + e);
    };
    Ue.prototype._getUse = function(e, r) {
      let o = this._baseState;
      return o.useDecoder = this._use(e, r), Qt(o.useDecoder._baseState.parent === null), o.useDecoder = o.useDecoder._baseState.children[0], o.implicit !== o.useDecoder._baseState.implicit && (o.useDecoder = o.useDecoder.clone(), o.useDecoder._baseState.implicit = o.implicit), o.useDecoder;
    };
    Ue.prototype._decodeChoice = function(e, r) {
      let o = this._baseState, f2 = null, p2 = false;
      return Object.keys(o.choice).some(function(m2) {
        let y3 = e.save(), M2 = o.choice[m2];
        try {
          let x3 = M2._decode(e, r);
          if (e.isError(x3))
            return false;
          f2 = { type: m2, value: x3 }, p2 = true;
        } catch {
          return e.restore(y3), false;
        }
        return true;
      }, this), p2 ? f2 : e.error("Choice not matched");
    };
    Ue.prototype._createEncoderBuffer = function(e) {
      return new hB(e, this.reporter);
    };
    Ue.prototype._encode = function(e, r, o) {
      let f2 = this._baseState;
      if (f2.default !== null && f2.default === e)
        return;
      let p2 = this._encodeValue(e, r, o);
      if (p2 !== undefined && !this._skipDefault(p2, r, o))
        return p2;
    };
    Ue.prototype._encodeValue = function(e, r, o) {
      let f2 = this._baseState;
      if (f2.parent === null)
        return f2.children[0]._encode(e, r || new sB);
      let p2 = null;
      if (this.reporter = r, f2.optional && e === undefined)
        if (f2.default !== null)
          e = f2.default;
        else
          return;
      let m2 = null, y3 = false;
      if (f2.any)
        p2 = this._createEncoderBuffer(e);
      else if (f2.choice)
        p2 = this._encodeChoice(e, r);
      else if (f2.contains)
        m2 = this._getUse(f2.contains, o)._encode(e, r), y3 = true;
      else if (f2.children)
        m2 = f2.children.map(function(M2) {
          if (M2._baseState.tag === "null_")
            return M2._encode(null, r, e);
          if (M2._baseState.key === null)
            return r.error("Child should have a key");
          let x3 = r.enterKey(M2._baseState.key);
          if (typeof e != "object")
            return r.error("Child expected, but input is not object");
          let S2 = M2._encode(e[M2._baseState.key], r, e);
          return r.leaveKey(x3), S2;
        }, this).filter(function(M2) {
          return M2;
        }), m2 = this._createEncoderBuffer(m2);
      else if (f2.tag === "seqof" || f2.tag === "setof") {
        if (!(f2.args && f2.args.length === 1))
          return r.error("Too many args for : " + f2.tag);
        if (!Array.isArray(e))
          return r.error("seqof/setof, but data is not Array");
        let M2 = this.clone();
        M2._baseState.implicit = null, m2 = this._createEncoderBuffer(e.map(function(x3) {
          let S2 = this._baseState;
          return this._getUse(S2.args[0], e)._encode(x3, r);
        }, M2));
      } else
        f2.use !== null ? p2 = this._getUse(f2.use, o)._encode(e, r) : (m2 = this._encodePrimitive(f2.tag, e), y3 = true);
      if (!f2.any && f2.choice === null) {
        let M2 = f2.implicit !== null ? f2.implicit : f2.tag, x3 = f2.implicit === null ? "universal" : "context";
        M2 === null ? f2.use === null && r.error("Tag could be omitted only for .use()") : f2.use === null && (p2 = this._encodeComposite(M2, y3, x3, m2));
      }
      return f2.explicit !== null && (p2 = this._encodeComposite(f2.explicit, false, "context", p2)), p2;
    };
    Ue.prototype._encodeChoice = function(e, r) {
      let o = this._baseState, f2 = o.choice[e.type];
      return f2 || Qt(false, e.type + " not found in " + JSON.stringify(Object.keys(o.choice))), f2._encode(e.value, r);
    };
    Ue.prototype._encodePrimitive = function(e, r) {
      let o = this._baseState;
      if (/str$/.test(e))
        return this._encodeStr(r, e);
      if (e === "objid" && o.args)
        return this._encodeObjid(r, o.reverseArgs[0], o.args[1]);
      if (e === "objid")
        return this._encodeObjid(r, null, null);
      if (e === "gentime" || e === "utctime")
        return this._encodeTime(r, e);
      if (e === "null_")
        return this._encodeNull();
      if (e === "int" || e === "enum")
        return this._encodeInt(r, o.args && o.reverseArgs[0]);
      if (e === "bool")
        return this._encodeBool(r);
      if (e === "objDesc")
        return this._encodeStr(r, e);
      throw new Error("Unsupported tag: " + e);
    };
    Ue.prototype._isNumstr = function(e) {
      return /^[0-9 ]*$/.test(e);
    };
    Ue.prototype._isPrintstr = function(e) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
  });
  c0 = T2((Wn) => {
    function Cy(t) {
      let e = {};
      return Object.keys(t).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        let o = t[r];
        e[o] = r;
      }), e;
    }
    Wn.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    Wn.tagClassByName = Cy(Wn.tagClass);
    Wn.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    Wn.tagByName = Cy(Wn.tag);
  });
  nd = T2((tL, Uy) => {
    var pB = Ie(), Ii = h0().Buffer, Oy = d0(), id = c0();
    function Fy(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur, this.tree._init(t.body);
    }
    Uy.exports = Fy;
    Fy.prototype.encode = function(e, r) {
      return this.tree._encode(e, r).join();
    };
    function Ur(t) {
      Oy.call(this, "der", t);
    }
    pB(Ur, Oy);
    Ur.prototype._encodeComposite = function(e, r, o, f2) {
      let p2 = vB(e, r, o, this.reporter);
      if (f2.length < 128) {
        let M2 = Ii.alloc(2);
        return M2[0] = p2, M2[1] = f2.length, this._createEncoderBuffer([M2, f2]);
      }
      let m2 = 1;
      for (let M2 = f2.length;M2 >= 256; M2 >>= 8)
        m2++;
      let y3 = Ii.alloc(1 + 1 + m2);
      y3[0] = p2, y3[1] = 128 | m2;
      for (let M2 = 1 + m2, x3 = f2.length;x3 > 0; M2--, x3 >>= 8)
        y3[M2] = x3 & 255;
      return this._createEncoderBuffer([y3, f2]);
    };
    Ur.prototype._encodeStr = function(e, r) {
      if (r === "bitstr")
        return this._createEncoderBuffer([e.unused | 0, e.data]);
      if (r === "bmpstr") {
        let o = Ii.alloc(e.length * 2);
        for (let f2 = 0;f2 < e.length; f2++)
          o.writeUInt16BE(e.charCodeAt(f2), f2 * 2);
        return this._createEncoderBuffer(o);
      } else
        return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
    };
    Ur.prototype._encodeObjid = function(e, r, o) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let y3 = 0;y3 < e.length; y3++)
          e[y3] |= 0;
      } else if (Array.isArray(e)) {
        e = e.slice();
        for (let y3 = 0;y3 < e.length; y3++)
          e[y3] |= 0;
      }
      if (!Array.isArray(e))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
      if (!o) {
        if (e[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, e[0] * 40 + e[1]);
      }
      let f2 = 0;
      for (let y3 = 0;y3 < e.length; y3++) {
        let M2 = e[y3];
        for (f2++;M2 >= 128; M2 >>= 7)
          f2++;
      }
      let p2 = Ii.alloc(f2), m2 = p2.length - 1;
      for (let y3 = e.length - 1;y3 >= 0; y3--) {
        let M2 = e[y3];
        for (p2[m2--] = M2 & 127;(M2 >>= 7) > 0; )
          p2[m2--] = 128 | M2 & 127;
      }
      return this._createEncoderBuffer(p2);
    };
    function qr(t) {
      return t < 10 ? "0" + t : t;
    }
    Ur.prototype._encodeTime = function(e, r) {
      let o, f2 = new Date(e);
      return r === "gentime" ? o = [qr(f2.getUTCFullYear()), qr(f2.getUTCMonth() + 1), qr(f2.getUTCDate()), qr(f2.getUTCHours()), qr(f2.getUTCMinutes()), qr(f2.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o = [qr(f2.getUTCFullYear() % 100), qr(f2.getUTCMonth() + 1), qr(f2.getUTCDate()), qr(f2.getUTCHours()), qr(f2.getUTCMinutes()), qr(f2.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o, "octstr");
    };
    Ur.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    };
    Ur.prototype._encodeInt = function(e, r) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e];
      }
      if (typeof e != "number" && !Ii.isBuffer(e)) {
        let p2 = e.toArray();
        !e.sign && p2[0] & 128 && p2.unshift(0), e = Ii.from(p2);
      }
      if (Ii.isBuffer(e)) {
        let p2 = e.length;
        e.length === 0 && p2++;
        let m2 = Ii.alloc(p2);
        return e.copy(m2), e.length === 0 && (m2[0] = 0), this._createEncoderBuffer(m2);
      }
      if (e < 128)
        return this._createEncoderBuffer(e);
      if (e < 256)
        return this._createEncoderBuffer([0, e]);
      let o = 1;
      for (let p2 = e;p2 >= 256; p2 >>= 8)
        o++;
      let f2 = new Array(o);
      for (let p2 = f2.length - 1;p2 >= 0; p2--)
        f2[p2] = e & 255, e >>= 8;
      return f2[0] & 128 && f2.unshift(0), this._createEncoderBuffer(Ii.from(f2));
    };
    Ur.prototype._encodeBool = function(e) {
      return this._createEncoderBuffer(e ? 255 : 0);
    };
    Ur.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
    };
    Ur.prototype._skipDefault = function(e, r, o) {
      let f2 = this._baseState, p2;
      if (f2.default === null)
        return false;
      let m2 = e.join();
      if (f2.defaultBuffer === undefined && (f2.defaultBuffer = this._encodeValue(f2.default, r, o).join()), m2.length !== f2.defaultBuffer.length)
        return false;
      for (p2 = 0;p2 < m2.length; p2++)
        if (m2[p2] !== f2.defaultBuffer[p2])
          return false;
      return true;
    };
    function vB(t, e, r, o) {
      let f2;
      if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), id.tagByName.hasOwnProperty(t))
        f2 = id.tagByName[t];
      else if (typeof t == "number" && (t | 0) === t)
        f2 = t;
      else
        return o.error("Unknown tag: " + t);
      return f2 >= 31 ? o.error("Multi-octet tag encoding unsupported") : (e || (f2 |= 32), f2 |= id.tagClassByName[r || "universal"] << 6, f2);
    }
  });
  Hy = T2((rL, zy) => {
    var bB = Ie(), fd = nd();
    function ad(t) {
      fd.call(this, t), this.enc = "pem";
    }
    bB(ad, fd);
    zy.exports = ad;
    ad.prototype.encode = function(e, r) {
      let f2 = fd.prototype.encode.call(this, e).toString("base64"), p2 = ["-----BEGIN " + r.label + "-----"];
      for (let m2 = 0;m2 < f2.length; m2 += 64)
        p2.push(f2.slice(m2, m2 + 64));
      return p2.push("-----END " + r.label + "-----"), p2.join(`
`);
    };
  });
  od = T2((Ky) => {
    var Wy = Ky;
    Wy.der = nd();
    Wy.pem = Hy();
  });
  hd = T2((nL, Yy) => {
    var mB = Ie(), gB = td(), jy = Kf().DecoderBuffer, Vy = d0(), Zy = c0();
    function $y(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
    }
    Yy.exports = $y;
    $y.prototype.decode = function(e, r) {
      return jy.isDecoderBuffer(e) || (e = new jy(e, r)), this.tree._decode(e, r);
    };
    function sr(t) {
      Vy.call(this, "der", t);
    }
    mB(sr, Vy);
    sr.prototype._peekTag = function(e, r, o) {
      if (e.isEmpty())
        return false;
      let f2 = e.save(), p2 = sd(e, 'Failed to peek tag: "' + r + '"');
      return e.isError(p2) ? p2 : (e.restore(f2), p2.tag === r || p2.tagStr === r || p2.tagStr + "of" === r || o);
    };
    sr.prototype._decodeTag = function(e, r, o) {
      let f2 = sd(e, 'Failed to decode tag of "' + r + '"');
      if (e.isError(f2))
        return f2;
      let p2 = Gy(e, f2.primitive, 'Failed to get length of "' + r + '"');
      if (e.isError(p2))
        return p2;
      if (!o && f2.tag !== r && f2.tagStr !== r && f2.tagStr + "of" !== r)
        return e.error('Failed to match tag: "' + r + '"');
      if (f2.primitive || p2 !== null)
        return e.skip(p2, 'Failed to match body of: "' + r + '"');
      let m2 = e.save(), y3 = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return e.isError(y3) ? y3 : (p2 = e.offset - m2.offset, e.restore(m2), e.skip(p2, 'Failed to match body of: "' + r + '"'));
    };
    sr.prototype._skipUntilEnd = function(e, r) {
      for (;; ) {
        let o = sd(e, r);
        if (e.isError(o))
          return o;
        let f2 = Gy(e, o.primitive, r);
        if (e.isError(f2))
          return f2;
        let p2;
        if (o.primitive || f2 !== null ? p2 = e.skip(f2) : p2 = this._skipUntilEnd(e, r), e.isError(p2))
          return p2;
        if (o.tagStr === "end")
          break;
      }
    };
    sr.prototype._decodeList = function(e, r, o, f2) {
      let p2 = [];
      for (;!e.isEmpty(); ) {
        let m2 = this._peekTag(e, "end");
        if (e.isError(m2))
          return m2;
        let y3 = o.decode(e, "der", f2);
        if (e.isError(y3) && m2)
          break;
        p2.push(y3);
      }
      return p2;
    };
    sr.prototype._decodeStr = function(e, r) {
      if (r === "bitstr") {
        let o = e.readUInt8();
        return e.isError(o) ? o : { unused: o, data: e.raw() };
      } else if (r === "bmpstr") {
        let o = e.raw();
        if (o.length % 2 === 1)
          return e.error("Decoding of string type: bmpstr length mismatch");
        let f2 = "";
        for (let p2 = 0;p2 < o.length / 2; p2++)
          f2 += String.fromCharCode(o.readUInt16BE(p2 * 2));
        return f2;
      } else if (r === "numstr") {
        let o = e.raw().toString("ascii");
        return this._isNumstr(o) ? o : e.error("Decoding of string type: numstr unsupported characters");
      } else {
        if (r === "octstr")
          return e.raw();
        if (r === "objDesc")
          return e.raw();
        if (r === "printstr") {
          let o = e.raw().toString("ascii");
          return this._isPrintstr(o) ? o : e.error("Decoding of string type: printstr unsupported characters");
        } else
          return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
      }
    };
    sr.prototype._decodeObjid = function(e, r, o) {
      let f2, p2 = [], m2 = 0, y3 = 0;
      for (;!e.isEmpty(); )
        y3 = e.readUInt8(), m2 <<= 7, m2 |= y3 & 127, (y3 & 128) === 0 && (p2.push(m2), m2 = 0);
      y3 & 128 && p2.push(m2);
      let M2 = p2[0] / 40 | 0, x3 = p2[0] % 40;
      if (o ? f2 = p2 : f2 = [M2, x3].concat(p2.slice(1)), r) {
        let S2 = r[f2.join(" ")];
        S2 === undefined && (S2 = r[f2.join(".")]), S2 !== undefined && (f2 = S2);
      }
      return f2;
    };
    sr.prototype._decodeTime = function(e, r) {
      let o = e.raw().toString(), f2, p2, m2, y3, M2, x3;
      if (r === "gentime")
        f2 = o.slice(0, 4) | 0, p2 = o.slice(4, 6) | 0, m2 = o.slice(6, 8) | 0, y3 = o.slice(8, 10) | 0, M2 = o.slice(10, 12) | 0, x3 = o.slice(12, 14) | 0;
      else if (r === "utctime")
        f2 = o.slice(0, 2) | 0, p2 = o.slice(2, 4) | 0, m2 = o.slice(4, 6) | 0, y3 = o.slice(6, 8) | 0, M2 = o.slice(8, 10) | 0, x3 = o.slice(10, 12) | 0, f2 < 70 ? f2 = 2000 + f2 : f2 = 1900 + f2;
      else
        return e.error("Decoding " + r + " time is not supported yet");
      return Date.UTC(f2, p2 - 1, m2, y3, M2, x3, 0);
    };
    sr.prototype._decodeNull = function() {
      return null;
    };
    sr.prototype._decodeBool = function(e) {
      let r = e.readUInt8();
      return e.isError(r) ? r : r !== 0;
    };
    sr.prototype._decodeInt = function(e, r) {
      let o = e.raw(), f2 = new gB(o);
      return r && (f2 = r[f2.toString(10)] || f2), f2;
    };
    sr.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
    };
    function sd(t, e) {
      let r = t.readUInt8(e);
      if (t.isError(r))
        return r;
      let o = Zy.tagClass[r >> 6], f2 = (r & 32) === 0;
      if ((r & 31) === 31) {
        let m2 = r;
        for (r = 0;(m2 & 128) === 128; ) {
          if (m2 = t.readUInt8(e), t.isError(m2))
            return m2;
          r <<= 7, r |= m2 & 127;
        }
      } else
        r &= 31;
      let p2 = Zy.tag[r];
      return { cls: o, primitive: f2, tag: r, tagStr: p2 };
    }
    function Gy(t, e, r) {
      let o = t.readUInt8(r);
      if (t.isError(o))
        return o;
      if (!e && o === 128)
        return null;
      if ((o & 128) === 0)
        return o;
      let f2 = o & 127;
      if (f2 > 4)
        return t.error("length octect is too long");
      o = 0;
      for (let p2 = 0;p2 < f2; p2++) {
        o <<= 8;
        let m2 = t.readUInt8(r);
        if (t.isError(m2))
          return m2;
        o |= m2;
      }
      return o;
    }
  });
  Jy = T2((fL, Xy) => {
    var yB = Ie(), wB = h0().Buffer, ud = hd();
    function ld(t) {
      ud.call(this, t), this.enc = "pem";
    }
    yB(ld, ud);
    Xy.exports = ld;
    ld.prototype.decode = function(e, r) {
      let o = e.toString().split(/[\r\n]+/g), f2 = r.label.toUpperCase(), p2 = /^-----(BEGIN|END) ([^-]+)-----$/, m2 = -1, y3 = -1;
      for (let S2 = 0;S2 < o.length; S2++) {
        let E3 = o[S2].match(p2);
        if (E3 !== null && E3[2] === f2)
          if (m2 === -1) {
            if (E3[1] !== "BEGIN")
              break;
            m2 = S2;
          } else {
            if (E3[1] !== "END")
              break;
            y3 = S2;
            break;
          }
      }
      if (m2 === -1 || y3 === -1)
        throw new Error("PEM section not found for: " + f2);
      let M2 = o.slice(m2 + 1, y3).join("");
      M2.replace(/[^a-z0-9+/=]+/gi, "");
      let x3 = wB.from(M2, "base64");
      return ud.prototype.decode.call(this, x3, r);
    };
  });
  dd = T2((e3) => {
    var Qy = e3;
    Qy.der = hd();
    Qy.pem = Jy();
  });
  r3 = T2((t3) => {
    var MB = od(), _B = dd(), xB = Ie(), SB = t3;
    SB.define = function(e, r) {
      return new jf(e, r);
    };
    function jf(t, e) {
      this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
    }
    jf.prototype._createNamed = function(e) {
      let r = this.name;
      function o(f2) {
        this._initNamed(f2, r);
      }
      return xB(o, e), o.prototype._initNamed = function(p2, m2) {
        e.call(this, p2, m2);
      }, new o(this);
    };
    jf.prototype._getDecoder = function(e) {
      return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(_B[e])), this.decoders[e];
    };
    jf.prototype.decode = function(e, r, o) {
      return this._getDecoder(r).decode(e, o);
    };
    jf.prototype._getEncoder = function(e) {
      return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(MB[e])), this.encoders[e];
    };
    jf.prototype.encode = function(e, r, o) {
      return this._getEncoder(r).encode(e, o);
    };
  });
  n3 = T2((i3) => {
    var p0 = i3;
    p0.Reporter = u0().Reporter;
    p0.DecoderBuffer = Kf().DecoderBuffer;
    p0.EncoderBuffer = Kf().EncoderBuffer;
    p0.Node = d0();
  });
  o3 = T2((a3) => {
    var f3 = a3;
    f3._reverse = function(e) {
      let r = {};
      return Object.keys(e).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        let f2 = e[o];
        r[f2] = o;
      }), r;
    };
    f3.der = c0();
  });
  cd = T2((s3) => {
    var Zf = s3;
    Zf.bignum = td();
    Zf.define = r3().define;
    Zf.base = n3();
    Zf.constants = o3();
    Zf.decoders = dd();
    Zf.encoders = od();
  });
  d3 = T2((lL, l3) => {
    var zr = cd(), h3 = zr.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), EB = zr.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), pd = zr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), AB = zr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(pd), this.key("subjectPublicKey").bitstr());
    }), RB = zr.define("RelativeDistinguishedName", function() {
      this.setof(EB);
    }), BB = zr.define("RDNSequence", function() {
      this.seqof(RB);
    }), u3 = zr.define("Name", function() {
      this.choice({ rdnSequence: this.use(BB) });
    }), qB = zr.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(h3), this.key("notAfter").use(h3));
    }), IB = zr.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TB = zr.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(pd), this.key("issuer").use(u3), this.key("validity").use(qB), this.key("subject").use(u3), this.key("subjectPublicKeyInfo").use(AB), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(IB).optional());
    }), kB = zr.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TB), this.key("signatureAlgorithm").use(pd), this.key("signatureValue").bitstr());
    });
    l3.exports = kB;
  });
  p3 = T2((Wr) => {
    var Hr = cd();
    Wr.certificate = d3();
    var LB = Hr.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Wr.RSAPrivateKey = LB;
    var NB = Hr.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Wr.RSAPublicKey = NB;
    var DB = Hr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(c3), this.key("subjectPublicKey").bitstr());
    });
    Wr.PublicKey = DB;
    var c3 = Hr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PB = Hr.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(c3), this.key("subjectPrivateKey").octstr());
    });
    Wr.PrivateKey = PB;
    var CB = Hr.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Wr.EncryptedPrivateKey = CB;
    var OB = Hr.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Wr.DSAPrivateKey = OB;
    Wr.DSAparam = Hr.define("DSAparam", function() {
      this.int();
    });
    var FB = Hr.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(UB), this.key("publicKey").optional().explicit(1).bitstr());
    });
    Wr.ECPrivateKey = FB;
    var UB = Hr.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    });
    Wr.signature = Hr.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  v3 = T2((cL, zB) => {
    zB.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  m3 = T2((pL, b3) => {
    var HB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, WB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, KB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, jB = Ba(), ZB = Es(), v0 = Te().Buffer;
    b3.exports = function(t, e) {
      var r = t.toString(), o = r.match(HB), f2;
      if (o) {
        var m2 = "aes" + o[1], y3 = v0.from(o[2], "hex"), M2 = v0.from(o[3].replace(/[\r\n]/g, ""), "base64"), x3 = jB(e, y3.slice(0, 8), parseInt(o[1], 10)).key, S2 = [], E3 = ZB.createDecipheriv(m2, x3, y3);
        S2.push(E3.update(M2)), S2.push(E3.final()), f2 = v0.concat(S2);
      } else {
        var p2 = r.match(KB);
        f2 = v0.from(p2[2].replace(/[\r\n]/g, ""), "base64");
      }
      var B3 = r.match(WB)[1];
      return { tag: B3, data: f2 };
    };
  });
  Ha = T2((vL, y3) => {
    var fr = p3(), VB = v3(), $B = m3(), GB = Es(), YB = Iu(), vd = Te().Buffer;
    y3.exports = g3;
    function g3(t) {
      var e;
      typeof t == "object" && !vd.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = vd.from(t));
      var r = $B(t, e), o = r.tag, f2 = r.data, p2, m2;
      switch (o) {
        case "CERTIFICATE":
          m2 = fr.certificate.decode(f2, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (m2 || (m2 = fr.PublicKey.decode(f2, "der")), p2 = m2.algorithm.algorithm.join("."), p2) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPublicKey.decode(m2.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return m2.subjectPrivateKey = m2.subjectPublicKey, { type: "ec", data: m2 };
            case "1.2.840.10040.4.1":
              return m2.algorithm.params.pub_key = fr.DSAparam.decode(m2.subjectPublicKey.data, "der"), { type: "dsa", data: m2.algorithm.params };
            default:
              throw new Error("unknown key id " + p2);
          }
        case "ENCRYPTED PRIVATE KEY":
          f2 = fr.EncryptedPrivateKey.decode(f2, "der"), f2 = XB(f2, e);
        case "PRIVATE KEY":
          switch (m2 = fr.PrivateKey.decode(f2, "der"), p2 = m2.algorithm.algorithm.join("."), p2) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPrivateKey.decode(m2.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: m2.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m2.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return m2.algorithm.params.priv_key = fr.DSAparam.decode(m2.subjectPrivateKey, "der"), { type: "dsa", params: m2.algorithm.params };
            default:
              throw new Error("unknown key id " + p2);
          }
        case "RSA PUBLIC KEY":
          return fr.RSAPublicKey.decode(f2, "der");
        case "RSA PRIVATE KEY":
          return fr.RSAPrivateKey.decode(f2, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: fr.DSAPrivateKey.decode(f2, "der") };
        case "EC PRIVATE KEY":
          return f2 = fr.ECPrivateKey.decode(f2, "der"), { curve: f2.parameters.value, privateKey: f2.privateKey };
        default:
          throw new Error("unknown key type " + o);
      }
    }
    g3.signature = fr.signature;
    function XB(t, e) {
      var r = t.algorithm.decrypt.kde.kdeparams.salt, o = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f2 = VB[t.algorithm.decrypt.cipher.algo.join(".")], p2 = t.algorithm.decrypt.cipher.iv, m2 = t.subjectPrivateKey, y4 = parseInt(f2.split("-")[1], 10) / 8, M2 = YB.pbkdf2Sync(e, r, o, y4, "sha1"), x3 = GB.createDecipheriv(f2, M2, p2), S2 = [];
      return S2.push(x3.update(m2)), S2.push(x3.final()), vd.concat(S2);
    }
  });
  bd = T2((bL, JB) => {
    JB.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
  });
  _3 = T2((mL, m0) => {
    var Yt = Te().Buffer, Kn = wu(), QB = Ks(), eq = o0().ec, b0 = Ws(), tq = Ha(), rq = bd();
    function iq(t, e, r, o, f2) {
      var p2 = tq(e);
      if (p2.curve) {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return nq(t, p2);
      } else if (p2.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong private key type");
        return fq(t, p2, r);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      t = Yt.concat([f2, t]);
      for (var m2 = p2.modulus.byteLength(), y3 = [0, 1];t.length + y3.length + 1 < m2; )
        y3.push(255);
      y3.push(0);
      for (var M2 = -1;++M2 < t.length; )
        y3.push(t[M2]);
      var x3 = QB(y3, p2);
      return x3;
    }
    function nq(t, e) {
      var r = rq[e.curve.join(".")];
      if (!r)
        throw new Error("unknown curve " + e.curve.join("."));
      var o = new eq(r), f2 = o.keyFromPrivate(e.privateKey), p2 = f2.sign(t);
      return Yt.from(p2.toDER());
    }
    function fq(t, e, r) {
      for (var o = e.params.priv_key, f2 = e.params.p, p2 = e.params.q, m2 = e.params.g, y3 = new b0(0), M2, x3 = md(t, p2).mod(p2), S2 = false, E3 = w3(o, p2, t, r);S2 === false; )
        M2 = M3(p2, E3, r), y3 = sq(m2, M2, f2, p2), S2 = M2.invm(p2).imul(x3.add(o.mul(y3))).mod(p2), S2.cmpn(0) === 0 && (S2 = false, y3 = new b0(0));
      return aq(y3, S2);
    }
    function aq(t, e) {
      t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
      var r = t.length + e.length + 4, o = [48, r, 2, t.length];
      return o = o.concat(t, [2, e.length], e), Yt.from(o);
    }
    function w3(t, e, r, o) {
      if (t = Yt.from(t.toArray()), t.length < e.byteLength()) {
        var f2 = Yt.alloc(e.byteLength() - t.length);
        t = Yt.concat([f2, t]);
      }
      var p2 = r.length, m2 = oq(r, e), y3 = Yt.alloc(p2);
      y3.fill(1);
      var M2 = Yt.alloc(p2);
      return M2 = Kn(o, M2).update(y3).update(Yt.from([0])).update(t).update(m2).digest(), y3 = Kn(o, M2).update(y3).digest(), M2 = Kn(o, M2).update(y3).update(Yt.from([1])).update(t).update(m2).digest(), y3 = Kn(o, M2).update(y3).digest(), { k: M2, v: y3 };
    }
    function md(t, e) {
      var r = new b0(t), o = (t.length << 3) - e.bitLength();
      return o > 0 && r.ishrn(o), r;
    }
    function oq(t, e) {
      t = md(t, e), t = t.mod(e);
      var r = Yt.from(t.toArray());
      if (r.length < e.byteLength()) {
        var o = Yt.alloc(e.byteLength() - r.length);
        r = Yt.concat([o, r]);
      }
      return r;
    }
    function M3(t, e, r) {
      var o, f2;
      do {
        for (o = Yt.alloc(0);o.length * 8 < t.bitLength(); )
          e.v = Kn(r, e.k).update(e.v).digest(), o = Yt.concat([o, e.v]);
        f2 = md(o, t), e.k = Kn(r, e.k).update(e.v).update(Yt.from([0])).digest(), e.v = Kn(r, e.k).update(e.v).digest();
      } while (f2.cmp(t) !== -1);
      return f2;
    }
    function sq(t, e, r, o) {
      return t.toRed(b0.mont(r)).redPow(e).fromRed().mod(o);
    }
    m0.exports = iq;
    m0.exports.getKey = w3;
    m0.exports.makeKey = M3;
  });
  A3 = T2((gL, E3) => {
    var gd = Te().Buffer, Wa = Ws(), hq = o0().ec, S3 = Ha(), uq = bd();
    function lq(t, e, r, o, f2) {
      var p2 = S3(r);
      if (p2.type === "ec") {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return dq(t, e, p2);
      } else if (p2.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong public key type");
        return cq(t, e, p2);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      e = gd.concat([f2, e]);
      for (var m2 = p2.modulus.byteLength(), y3 = [1], M2 = 0;e.length + y3.length + 2 < m2; )
        y3.push(255), M2++;
      y3.push(0);
      for (var x4 = -1;++x4 < e.length; )
        y3.push(e[x4]);
      y3 = gd.from(y3);
      var S2 = Wa.mont(p2.modulus);
      t = new Wa(t).toRed(S2), t = t.redPow(new Wa(p2.publicExponent)), t = gd.from(t.fromRed().toArray());
      var E4 = M2 < 8 ? 1 : 0;
      for (m2 = Math.min(t.length, y3.length), t.length !== y3.length && (E4 = 1), x4 = -1;++x4 < m2; )
        E4 |= t[x4] ^ y3[x4];
      return E4 === 0;
    }
    function dq(t, e, r) {
      var o = uq[r.data.algorithm.curve.join(".")];
      if (!o)
        throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
      var f2 = new hq(o), p2 = r.data.subjectPrivateKey.data;
      return f2.verify(e, t, p2);
    }
    function cq(t, e, r) {
      var o = r.data.p, f2 = r.data.q, p2 = r.data.g, m2 = r.data.pub_key, y3 = S3.signature.decode(t, "der"), M2 = y3.s, x4 = y3.r;
      x3(M2, f2), x3(x4, f2);
      var S2 = Wa.mont(o), E4 = M2.invm(f2), B3 = p2.toRed(S2).redPow(new Wa(e).mul(E4).mod(f2)).fromRed().mul(m2.toRed(S2).redPow(x4.mul(E4).mod(f2)).fromRed()).mod(o).mod(f2);
      return B3.cmp(x4) === 0;
    }
    function x3(t, e) {
      if (t.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (t.cmp(e) >= e)
        throw new Error("invalid sig");
    }
    E3.exports = lq;
  });
  k3 = T2((yL, T3) => {
    var g0 = Te().Buffer, q3 = bf(), y0 = i2(), I3 = Ie(), pq = _3(), vq = A3(), jn = Mu();
    Object.keys(jn).forEach(function(t) {
      jn[t].id = g0.from(jn[t].id, "hex"), jn[t.toLowerCase()] = jn[t];
    });
    function Ka(t) {
      y0.Writable.call(this);
      var e = jn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hashType = e.hash, this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I3(Ka, y0.Writable);
    Ka.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    Ka.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    Ka.prototype.sign = function(e, r) {
      this.end();
      var o = this._hash.digest(), f2 = pq(o, e, this._hashType, this._signType, this._tag);
      return r ? f2.toString(r) : f2;
    };
    function ja(t) {
      y0.Writable.call(this);
      var e = jn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I3(ja, y0.Writable);
    ja.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    ja.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    ja.prototype.verify = function(e, r, o) {
      typeof r == "string" && (r = g0.from(r, o)), this.end();
      var f2 = this._hash.digest();
      return vq(r, f2, e, this._signType, this._tag);
    };
    function R3(t) {
      return new Ka(t);
    }
    function B3(t) {
      return new ja(t);
    }
    T3.exports = { Sign: R3, Verify: B3, createSign: R3, createVerify: B3 };
  });
  N3 = T2((L3, yd) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a2 = function() {
        };
        a2.prototype = i.prototype, v.prototype = new a2, v.prototype.constructor = v;
      }
      function f2(v, i, a2) {
        if (f2.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v || 0, i || 10, a2 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a2) {
        return i.cmp(a2) > 0 ? i : a2;
      }, f2.min = function(i, a2) {
        return i.cmp(a2) < 0 ? i : a2;
      }, f2.prototype._init = function(i, a2, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a2, h3);
        if (typeof i == "object")
          return this._initArray(i, a2, h3);
        a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a2 === 16 ? this._parseHex(i, s3, h3) : (this._parseBase(i, a2, s3), h3 === "le" && this._initArray(this.toArray(), a2, h3)));
      }, f2.prototype._initNumber = function(i, a2, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a2, h3);
      }, f2.prototype._initArray = function(i, a2, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3, c2, b3 = 0;
        if (h3 === "be")
          for (s3 = i.length - 1, u3 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u3] |= c2 << b3 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u3++);
        else if (h3 === "le")
          for (s3 = 0, u3 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u3] |= c2 << b3 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u3++);
        return this.strip();
      };
      function m2(v, i) {
        var a2 = v.charCodeAt(i);
        return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
      }
      function y3(v, i, a2) {
        var h3 = m2(v, a2);
        return a2 - 1 >= i && (h3 |= m2(v, a2 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a2, h3) {
        this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3 = 0, c2 = 0, b3;
        if (h3 === "be")
          for (s3 = i.length - 1;s3 >= a2; s3 -= 2)
            b3 = y3(i, a2, s3) << u3, this.words[c2] |= b3 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b3 >>> 26) : u3 += 8;
        else {
          var l2 = i.length - a2;
          for (s3 = l2 % 2 === 0 ? a2 + 1 : a2;s3 < i.length; s3 += 2)
            b3 = y3(i, a2, s3) << u3, this.words[c2] |= b3 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b3 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M2(v, i, a2, h3) {
        for (var s3 = 0, u3 = Math.min(v.length, a2), c2 = i;c2 < u3; c2++) {
          var b3 = v.charCodeAt(c2) - 48;
          s3 *= h3, b3 >= 49 ? s3 += b3 - 49 + 10 : b3 >= 17 ? s3 += b3 - 17 + 10 : s3 += b3;
        }
        return s3;
      }
      f2.prototype._parseBase = function(i, a2, h3) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u3 = 1;u3 <= 67108863; u3 *= a2)
          s3++;
        s3--, u3 = u3 / a2 | 0;
        for (var c2 = i.length - h3, b3 = c2 % s3, l2 = Math.min(c2, c2 - b3) + h3, n = 0, d2 = h3;d2 < l2; d2 += s3)
          n = M2(i, d2, d2 + s3, a2), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b3 !== 0) {
          var w = 1;
          for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
            w *= a2;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a2 = 0;a2 < this.length; a2++)
          i.words[a2] = this.words[a2];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a2) {
        i = i || 10, a2 = a2 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s3 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b3 = this.words[c2], l2 = ((b3 << s3 | u3) & 16777215).toString(16);
            u3 = b3 >>> 24 - s3 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l2.length] + l2 + h3 : h3 = l2 + h3, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u3 !== 0 && (h3 = u3.toString(16) + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d2 = E3[i];
          h3 = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g3 = w.modn(d2).toString(i);
            w = w.idivn(d2), w.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a2) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
      }, f2.prototype.toArray = function(i, a2) {
        return this.toArrayLike(Array, i, a2);
      }, f2.prototype.toArrayLike = function(i, a2, h3) {
        var s3 = this.byteLength(), u3 = h3 || Math.max(1, s3);
        r(s3 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a2 === "le", b3 = new i(u3), l2, n, d2 = this.clone();
        if (c2) {
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
          for (;n < u3; n++)
            b3[n] = 0;
        } else {
          for (n = 0;n < u3 - s3; n++)
            b3[n] = 0;
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b3[u3 - n - 1] = l2;
        }
        return b3;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a2 = i, h3 = 0;
        return a2 >= 4096 && (h3 += 13, a2 >>>= 13), a2 >= 64 && (h3 += 7, a2 >>>= 7), a2 >= 8 && (h3 += 4, a2 >>>= 4), a2 >= 2 && (h3 += 2, a2 >>>= 2), h3 + a2;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a2 = i, h3 = 0;
        return (a2 & 8191) === 0 && (h3 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h3 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h3 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h3 += 2, a2 >>>= 2), (a2 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a2 = this._countBits(i);
        return (this.length - 1) * 26 + a2;
      };
      function B3(v) {
        for (var i = new Array(v.bitLength()), a2 = 0;a2 < i.length; a2++) {
          var h3 = a2 / 26 | 0, s3 = a2 % 26;
          i[a2] = (v.words[h3] & 1 << s3) >>> s3;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a2 = 0;a2 < this.length; a2++) {
          var h3 = this._zeroBits(this.words[a2]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a2 = 0;a2 < i.length; a2++)
          this.words[a2] = this.words[a2] | i.words[a2];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a2;
        this.length > i.length ? a2 = i : a2 = this;
        for (var h3 = 0;h3 < a2.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a2, h3;
        this.length > i.length ? (a2 = this, h3 = i) : (a2 = i, h3 = this);
        for (var s3 = 0;s3 < h3.length; s3++)
          this.words[s3] = a2.words[s3] ^ h3.words[s3];
        if (this !== a2)
          for (;s3 < a2.length; s3++)
            this.words[s3] = a2.words[s3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a2), h3 > 0 && a2--;
        for (var s3 = 0;s3 < a2; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h3 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a2) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s3 = i % 26;
        return this._expand(h3 + 1), a2 ? this.words[h3] = this.words[h3] | 1 << s3 : this.words[h3] = this.words[h3] & ~(1 << s3), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a2;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
        var h3, s3;
        this.length > i.length ? (h3 = this, s3 = i) : (h3 = i, s3 = this);
        for (var u3 = 0, c2 = 0;c2 < s3.length; c2++)
          a2 = (h3.words[c2] | 0) + (s3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        for (;u3 !== 0 && c2 < h3.length; c2++)
          a2 = (h3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        if (this.length = h3.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a2;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a2 = this.iadd(i);
          return i.negative = 1, a2._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u3;
        h3 > 0 ? (s3 = this, u3 = i) : (s3 = i, u3 = this);
        for (var c2 = 0, b3 = 0;b3 < u3.length; b3++)
          a2 = (s3.words[b3] | 0) - (u3.words[b3] | 0) + c2, c2 = a2 >> 26, this.words[b3] = a2 & 67108863;
        for (;c2 !== 0 && b3 < s3.length; b3++)
          a2 = (s3.words[b3] | 0) + c2, c2 = a2 >> 26, this.words[b3] = a2 & 67108863;
        if (c2 === 0 && b3 < s3.length && s3 !== this)
          for (;b3 < s3.length; b3++)
            this.words[b3] = s3.words[b3];
        return this.length = Math.max(this.length, b3), s3 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q2(v, i, a2) {
        a2.negative = i.negative ^ v.negative;
        var h3 = v.length + i.length | 0;
        a2.length = h3, h3 = h3 - 1 | 0;
        var s3 = v.words[0] | 0, u3 = i.words[0] | 0, c2 = s3 * u3, b3 = c2 & 67108863, l2 = c2 / 67108864 | 0;
        a2.words[0] = b3;
        for (var n = 1;n < h3; n++) {
          for (var d2 = l2 >>> 26, w = l2 & 67108863, g3 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v.length + 1);_4 <= g3; _4++) {
            var A2 = n - _4 | 0;
            s3 = v.words[A2] | 0, u3 = i.words[_4] | 0, c2 = s3 * u3 + w, d2 += c2 / 67108864 | 0, w = c2 & 67108863;
          }
          a2.words[n] = w | 0, l2 = d2 | 0;
        }
        return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
      }
      var L4 = function(i, a2, h3) {
        var s3 = i.words, u3 = a2.words, c2 = h3.words, b3 = 0, l2, n, d2, w = s3[0] | 0, g3 = w & 8191, _4 = w >>> 13, A2 = s3[1] | 0, R2 = A2 & 8191, I3 = A2 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt = s3[3] | 0, C = nt & 8191, O3 = nt >>> 13, vt = s3[4] | 0, F = vt & 8191, U3 = vt >>> 13, bt = s3[5] | 0, z = bt & 8191, H2 = bt >>> 13, mt = s3[6] | 0, W = mt & 8191, K2 = mt >>> 13, gt = s3[7] | 0, j3 = gt & 8191, Z3 = gt >>> 13, yt = s3[8] | 0, V3 = yt & 8191, $2 = yt >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y2 = wt >>> 13, Mt = u3[0] | 0, X3 = Mt & 8191, J2 = Mt >>> 13, _t = u3[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u3[2] | 0, te = xt & 8191, re = xt >>> 13, St = u3[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u3[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u3[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u3[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u3[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u3[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u3[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a2.negative, h3.length = 19, l2 = Math.imul(g3, X3), n = Math.imul(g3, J2), n = n + Math.imul(_4, X3) | 0, d2 = Math.imul(_4, J2);
        var ft = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l2 = Math.imul(R2, X3), n = Math.imul(R2, J2), n = n + Math.imul(I3, X3) | 0, d2 = Math.imul(I3, J2), l2 = l2 + Math.imul(g3, Q3) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_4, Q3) | 0, d2 = d2 + Math.imul(_4, ee) | 0;
        var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k4, X3), n = Math.imul(k4, J2), n = n + Math.imul(D2, X3) | 0, d2 = Math.imul(D2, J2), l2 = l2 + Math.imul(R2, Q3) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I3, Q3) | 0, d2 = d2 + Math.imul(I3, ee) | 0, l2 = l2 + Math.imul(g3, te) | 0, n = n + Math.imul(g3, re) | 0, n = n + Math.imul(_4, te) | 0, d2 = d2 + Math.imul(_4, re) | 0;
        var qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l2 = Math.imul(C, X3), n = Math.imul(C, J2), n = n + Math.imul(O3, X3) | 0, d2 = Math.imul(O3, J2), l2 = l2 + Math.imul(k4, Q3) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D2, Q3) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R2, te) | 0, n = n + Math.imul(R2, re) | 0, n = n + Math.imul(I3, te) | 0, d2 = d2 + Math.imul(I3, re) | 0, l2 = l2 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_4, ie) | 0, d2 = d2 + Math.imul(_4, ne) | 0;
        var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F, X3), n = Math.imul(F, J2), n = n + Math.imul(U3, X3) | 0, d2 = Math.imul(U3, J2), l2 = l2 + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O3, Q3) | 0, d2 = d2 + Math.imul(O3, ee) | 0, l2 = l2 + Math.imul(k4, te) | 0, n = n + Math.imul(k4, re) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re) | 0, l2 = l2 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I3, ie) | 0, d2 = d2 + Math.imul(I3, ne) | 0, l2 = l2 + Math.imul(g3, fe) | 0, n = n + Math.imul(g3, ae) | 0, n = n + Math.imul(_4, fe) | 0, d2 = d2 + Math.imul(_4, ae) | 0;
        var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X3), n = Math.imul(z, J2), n = n + Math.imul(H2, X3) | 0, d2 = Math.imul(H2, J2), l2 = l2 + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U3, Q3) | 0, d2 = d2 + Math.imul(U3, ee) | 0, l2 = l2 + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O3, te) | 0, d2 = d2 + Math.imul(O3, re) | 0, l2 = l2 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R2, fe) | 0, n = n + Math.imul(R2, ae) | 0, n = n + Math.imul(I3, fe) | 0, d2 = d2 + Math.imul(I3, ae) | 0, l2 = l2 + Math.imul(g3, oe) | 0, n = n + Math.imul(g3, se) | 0, n = n + Math.imul(_4, oe) | 0, d2 = d2 + Math.imul(_4, se) | 0;
        var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X3), n = Math.imul(W, J2), n = n + Math.imul(K2, X3) | 0, d2 = Math.imul(K2, J2), l2 = l2 + Math.imul(z, Q3) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q3) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U3, te) | 0, d2 = d2 + Math.imul(U3, re) | 0, l2 = l2 + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O3, ie) | 0, d2 = d2 + Math.imul(O3, ne) | 0, l2 = l2 + Math.imul(k4, fe) | 0, n = n + Math.imul(k4, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R2, oe) | 0, n = n + Math.imul(R2, se) | 0, n = n + Math.imul(I3, oe) | 0, d2 = d2 + Math.imul(I3, se) | 0, l2 = l2 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue) | 0, n = n + Math.imul(_4, he) | 0, d2 = d2 + Math.imul(_4, ue) | 0;
        var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j3, X3), n = Math.imul(j3, J2), n = n + Math.imul(Z3, X3) | 0, d2 = Math.imul(Z3, J2), l2 = l2 + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q3) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re) | 0, l2 = l2 + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U3, ie) | 0, d2 = d2 + Math.imul(U3, ne) | 0, l2 = l2 + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O3, fe) | 0, d2 = d2 + Math.imul(O3, ae) | 0, l2 = l2 + Math.imul(k4, oe) | 0, n = n + Math.imul(k4, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue) | 0, n = n + Math.imul(I3, he) | 0, d2 = d2 + Math.imul(I3, ue) | 0, l2 = l2 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_4, le) | 0, d2 = d2 + Math.imul(_4, de) | 0;
        var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X3), n = Math.imul(V3, J2), n = n + Math.imul($2, X3) | 0, d2 = Math.imul($2, J2), l2 = l2 + Math.imul(j3, Q3) | 0, n = n + Math.imul(j3, ee) | 0, n = n + Math.imul(Z3, Q3) | 0, d2 = d2 + Math.imul(Z3, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U3, fe) | 0, d2 = d2 + Math.imul(U3, ae) | 0, l2 = l2 + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O3, oe) | 0, d2 = d2 + Math.imul(O3, se) | 0, l2 = l2 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I3, le) | 0, d2 = d2 + Math.imul(I3, de) | 0, l2 = l2 + Math.imul(g3, ce) | 0, n = n + Math.imul(g3, pe) | 0, n = n + Math.imul(_4, ce) | 0, d2 = d2 + Math.imul(_4, pe) | 0;
        var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G2, X3), n = Math.imul(G2, J2), n = n + Math.imul(Y2, X3) | 0, d2 = Math.imul(Y2, J2), l2 = l2 + Math.imul(V3, Q3) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q3) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j3, te) | 0, n = n + Math.imul(j3, re) | 0, n = n + Math.imul(Z3, te) | 0, d2 = d2 + Math.imul(Z3, re) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U3, oe) | 0, d2 = d2 + Math.imul(U3, se) | 0, l2 = l2 + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O3, he) | 0, d2 = d2 + Math.imul(O3, ue) | 0, l2 = l2 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R2, ce) | 0, n = n + Math.imul(R2, pe) | 0, n = n + Math.imul(I3, ce) | 0, d2 = d2 + Math.imul(I3, pe) | 0, l2 = l2 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_4, ve) | 0, d2 = d2 + Math.imul(_4, be) | 0;
        var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G2, Q3), n = Math.imul(G2, ee), n = n + Math.imul(Y2, Q3) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re) | 0, l2 = l2 + Math.imul(j3, ie) | 0, n = n + Math.imul(j3, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d2 = d2 + Math.imul(Z3, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U3, he) | 0, d2 = d2 + Math.imul(U3, ue) | 0, l2 = l2 + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O3, le) | 0, d2 = d2 + Math.imul(O3, de) | 0, l2 = l2 + Math.imul(k4, ce) | 0, n = n + Math.imul(k4, pe) | 0, n = n + Math.imul(D2, ce) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I3, ve) | 0, d2 = d2 + Math.imul(I3, be) | 0;
        var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G2, te), n = Math.imul(G2, re), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j3, fe) | 0, n = n + Math.imul(j3, ae) | 0, n = n + Math.imul(Z3, fe) | 0, d2 = d2 + Math.imul(Z3, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U3, le) | 0, d2 = d2 + Math.imul(U3, de) | 0, l2 = l2 + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O3, ce) | 0, d2 = d2 + Math.imul(O3, pe) | 0, l2 = l2 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
        var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j3, oe) | 0, n = n + Math.imul(j3, se) | 0, n = n + Math.imul(Z3, oe) | 0, d2 = d2 + Math.imul(Z3, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U3, ce) | 0, d2 = d2 + Math.imul(U3, pe) | 0, l2 = l2 + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O3, ve) | 0, d2 = d2 + Math.imul(O3, be) | 0;
        var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G2, fe), n = Math.imul(G2, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j3, he) | 0, n = n + Math.imul(j3, ue) | 0, n = n + Math.imul(Z3, he) | 0, d2 = d2 + Math.imul(Z3, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U3, ve) | 0, d2 = d2 + Math.imul(U3, be) | 0;
        var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G2, oe), n = Math.imul(G2, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j3, le) | 0, n = n + Math.imul(j3, de) | 0, n = n + Math.imul(Z3, le) | 0, d2 = d2 + Math.imul(Z3, de) | 0, l2 = l2 + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
        var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G2, he), n = Math.imul(G2, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j3, ce) | 0, n = n + Math.imul(j3, pe) | 0, n = n + Math.imul(Z3, ce) | 0, d2 = d2 + Math.imul(Z3, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
        var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j3, ve) | 0, n = n + Math.imul(j3, be) | 0, n = n + Math.imul(Z3, ve) | 0, d2 = d2 + Math.imul(Z3, be) | 0;
        var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G2, ce), n = Math.imul(G2, pe), n = n + Math.imul(Y2, ce) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
        var tt = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l2 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
        var rt = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        return b3 = (d2 + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe, c2[3] = ze, c2[4] = He, c2[5] = We, c2[6] = Ke, c2[7] = je, c2[8] = Ze, c2[9] = Ve, c2[10] = $e, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe, c2[16] = et, c2[17] = tt, c2[18] = rt, b3 !== 0 && (c2[19] = b3, h3.length++), h3;
      };
      Math.imul || (L4 = q2);
      function ge(v, i, a2) {
        a2.negative = i.negative ^ v.negative, a2.length = v.length + i.length;
        for (var h3 = 0, s3 = 0, u3 = 0;u3 < a2.length - 1; u3++) {
          var c2 = s3;
          s3 = 0;
          for (var b3 = h3 & 67108863, l2 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v.length + 1);n <= l2; n++) {
            var d2 = u3 - n, w = v.words[d2] | 0, g3 = i.words[n] | 0, _4 = w * g3, A2 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c2 = c2 + (A2 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a2.words[u3] = b3, h3 = c2, c2 = s3;
        }
        return h3 !== 0 ? a2.words[u3] = h3 : a2.length--, a2.strip();
      }
      function _e(v, i, a2) {
        var h3 = new N4;
        return h3.mulp(v, i, a2);
      }
      f2.prototype.mulTo = function(i, a2) {
        var h3, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L4(this, i, a2) : s3 < 63 ? h3 = q2(this, i, a2) : s3 < 1024 ? h3 = ge(this, i, a2) : h3 = _e(this, i, a2), h3;
      };
      function N4(v, i) {
        this.x = v, this.y = i;
      }
      N4.prototype.makeRBT = function(i) {
        for (var a2 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a2[s3] = this.revBin(s3, h3, i);
        return a2;
      }, N4.prototype.revBin = function(i, a2, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s3 = 0, u3 = 0;u3 < a2; u3++)
          s3 |= (i & 1) << a2 - u3 - 1, i >>= 1;
        return s3;
      }, N4.prototype.permute = function(i, a2, h3, s3, u3, c2) {
        for (var b3 = 0;b3 < c2; b3++)
          s3[b3] = a2[i[b3]], u3[b3] = h3[i[b3]];
      }, N4.prototype.transform = function(i, a2, h3, s3, u3, c2) {
        this.permute(c2, i, a2, h3, s3, u3);
        for (var b3 = 1;b3 < u3; b3 <<= 1)
          for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w = 0;w < u3; w += l2)
            for (var g3 = n, _4 = d2, A2 = 0;A2 < b3; A2++) {
              var R2 = h3[w + A2], I3 = s3[w + A2], Me = h3[w + A2 + b3], k4 = s3[w + A2 + b3], D2 = g3 * Me - _4 * k4;
              k4 = g3 * k4 + _4 * Me, Me = D2, h3[w + A2] = R2 + Me, s3[w + A2] = I3 + k4, h3[w + A2 + b3] = R2 - Me, s3[w + A2 + b3] = I3 - k4, A2 !== l2 && (D2 = n * g3 - d2 * _4, _4 = n * _4 + d2 * g3, g3 = D2);
            }
      }, N4.prototype.guessLen13b = function(i, a2) {
        var h3 = Math.max(a2, i) | 1, s3 = h3 & 1, u3 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u3++;
        return 1 << u3 + 1 + s3;
      }, N4.prototype.conjugate = function(i, a2, h3) {
        if (!(h3 <= 1))
          for (var s3 = 0;s3 < h3 / 2; s3++) {
            var u3 = i[s3];
            i[s3] = i[h3 - s3 - 1], i[h3 - s3 - 1] = u3, u3 = a2[s3], a2[s3] = -a2[h3 - s3 - 1], a2[h3 - s3 - 1] = -u3;
          }
      }, N4.prototype.normalize13b = function(i, a2) {
        for (var h3 = 0, s3 = 0;s3 < a2 / 2; s3++) {
          var u3 = Math.round(i[2 * s3 + 1] / a2) * 8192 + Math.round(i[2 * s3] / a2) + h3;
          i[s3] = u3 & 67108863, u3 < 67108864 ? h3 = 0 : h3 = u3 / 67108864 | 0;
        }
        return i;
      }, N4.prototype.convert13b = function(i, a2, h3, s3) {
        for (var u3 = 0, c2 = 0;c2 < a2; c2++)
          u3 = u3 + (i[c2] | 0), h3[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h3[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a2;c2 < s3; ++c2)
          h3[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N4.prototype.stub = function(i) {
        for (var a2 = new Array(i), h3 = 0;h3 < i; h3++)
          a2[h3] = 0;
        return a2;
      }, N4.prototype.mulp = function(i, a2, h3) {
        var s3 = 2 * this.guessLen13b(i.length, a2.length), u3 = this.makeRBT(s3), c2 = this.stub(s3), b3 = new Array(s3), l2 = new Array(s3), n = new Array(s3), d2 = new Array(s3), w = new Array(s3), g3 = new Array(s3), _4 = h3.words;
        _4.length = s3, this.convert13b(i.words, i.length, b3, s3), this.convert13b(a2.words, a2.length, d2, s3), this.transform(b3, c2, l2, n, s3, u3), this.transform(d2, c2, w, g3, s3, u3);
        for (var A2 = 0;A2 < s3; A2++) {
          var R2 = l2[A2] * w[A2] - n[A2] * g3[A2];
          n[A2] = l2[A2] * g3[A2] + n[A2] * w[A2], l2[A2] = R2;
        }
        return this.conjugate(l2, n, s3), this.transform(l2, n, _4, c2, s3, u3), this.conjugate(_4, c2, s3), this.normalize13b(_4, s3), h3.negative = i.negative ^ a2.negative, h3.length = i.length + a2.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
      }, f2.prototype.mulf = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), _e(this, i, a2);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a2 = 0, h3 = 0;h3 < this.length; h3++) {
          var s3 = (this.words[h3] | 0) * i, u3 = (s3 & 67108863) + (a2 & 67108863);
          a2 >>= 26, a2 += s3 / 67108864 | 0, a2 += u3 >>> 26, this.words[h3] = u3 & 67108863;
        }
        return a2 !== 0 && (this.words[h3] = a2, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a2 = B3(i);
        if (a2.length === 0)
          return new f2(1);
        for (var h3 = this, s3 = 0;s3 < a2.length && a2[s3] === 0; s3++, h3 = h3.sqr())
          ;
        if (++s3 < a2.length)
          for (var u3 = h3.sqr();s3 < a2.length; s3++, u3 = u3.sqr())
            a2[s3] !== 0 && (h3 = h3.mul(u3));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 67108863 >>> 26 - a2 << 26 - a2, u3;
        if (a2 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b3 = this.words[u3] & s3, l2 = (this.words[u3] | 0) - b3 << a2;
            this.words[u3] = l2 | c2, c2 = b3 >>> 26 - a2;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h3] = this.words[u3];
          for (u3 = 0;u3 < h3; u3++)
            this.words[u3] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a2, h3) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a2 ? s3 = (a2 - a2 % 26) / 26 : s3 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u3 << u3, l2 = h3;
        if (s3 -= c2, s3 = Math.max(0, s3), l2) {
          for (var n = 0;n < c2; n++)
            l2.words[n] = this.words[n];
          l2.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d2 = 0;
        for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s3); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d2 << 26 - u3 | w >>> u3, d2 = w & b3;
        }
        return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a2, h3) {
        return r(this.negative === 0), this.iushrn(i, a2, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 1 << a2;
        if (this.length <= h3)
          return false;
        var u3 = this.words[h3];
        return !!(u3 & s3);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a2 !== 0 && h3++, this.length = Math.min(h3, this.length), a2 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a2 << a2;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
          this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
        return this.length = Math.max(this.length, a2 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
            this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a2, h3) {
        var s3 = i.length + h3, u3;
        this._expand(s3);
        var c2, b3 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h3] | 0) + b3;
          var l2 = (i.words[u3] | 0) * a2;
          c2 -= l2 & 67108863, b3 = (c2 >> 26) - (l2 / 67108864 | 0), this.words[u3 + h3] = c2 & 67108863;
        }
        for (;u3 < this.length - h3; u3++)
          c2 = (this.words[u3 + h3] | 0) + b3, b3 = c2 >> 26, this.words[u3 + h3] = c2 & 67108863;
        if (b3 === 0)
          return this.strip();
        for (r(b3 === -1), b3 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b3, b3 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a2) {
        var h3 = this.length - i.length, s3 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b3 = this._countBits(c2);
        h3 = 26 - b3, h3 !== 0 && (u3 = u3.ushln(h3), s3.iushln(h3), c2 = u3.words[u3.length - 1] | 0);
        var l2 = s3.length - u3.length, n;
        if (a2 !== "mod") {
          n = new f2(null), n.length = l2 + 1, n.words = new Array(n.length);
          for (var d2 = 0;d2 < n.length; d2++)
            n.words[d2] = 0;
        }
        var w = s3.clone()._ishlnsubmul(u3, 1, l2);
        w.negative === 0 && (s3 = w, n && (n.words[l2] = 1));
        for (var g3 = l2 - 1;g3 >= 0; g3--) {
          var _4 = (s3.words[u3.length + g3] | 0) * 67108864 + (s3.words[u3.length + g3 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s3._ishlnsubmul(u3, _4, g3);s3.negative !== 0; )
            _4--, s3.negative = 0, s3._ishlnsubmul(u3, 1, g3), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g3] = _4);
        }
        return n && n.strip(), s3.strip(), a2 !== "div" && h3 !== 0 && s3.iushrn(h3), { div: n || null, mod: s3 };
      }, f2.prototype.divmod = function(i, a2, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s3, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a2), a2 !== "mod" && (s3 = c2.div.neg()), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.iadd(i)), { div: s3, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a2), a2 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a2);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a2 = this.divmod(i);
        if (a2.mod.isZero())
          return a2.div;
        var h3 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s3 = i.ushrn(1), u3 = i.andln(1), c2 = h3.cmp(s3);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a2 = (1 << 26) % i, h3 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h3 = (a2 * h3 + (this.words[s3] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = (this.words[h3] | 0) + a2 * 67108864;
          this.words[h3] = s3 / i | 0, a2 = s3 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s3 = new f2(1), u3 = new f2(0), c2 = new f2(0), b3 = new f2(1), l2 = 0;a2.isEven() && h3.isEven(); )
          a2.iushrn(1), h3.iushrn(1), ++l2;
        for (var n = h3.clone(), d2 = a2.clone();!a2.isZero(); ) {
          for (var w = 0, g3 = 1;(a2.words[0] & g3) === 0 && w < 26; ++w, g3 <<= 1)
            ;
          if (w > 0)
            for (a2.iushrn(w);w-- > 0; )
              (s3.isOdd() || u3.isOdd()) && (s3.iadd(n), u3.isub(d2)), s3.iushrn(1), u3.iushrn(1);
          for (var _4 = 0, A2 = 1;(h3.words[0] & A2) === 0 && _4 < 26; ++_4, A2 <<= 1)
            ;
          if (_4 > 0)
            for (h3.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b3.isOdd()) && (c2.iadd(n), b3.isub(d2)), c2.iushrn(1), b3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s3.isub(c2), u3.isub(b3)) : (h3.isub(a2), c2.isub(s3), b3.isub(u3));
        }
        return { a: c2, b: b3, gcd: h3.iushln(l2) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s3 = new f2(1), u3 = new f2(0), c2 = h3.clone();a2.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
            ;
          if (b3 > 0)
            for (a2.iushrn(b3);b3-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d2 = 1;(h3.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s3.isub(u3)) : (h3.isub(a2), u3.isub(s3));
        }
        var w;
        return a2.cmpn(1) === 0 ? w = s3 : w = u3, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a2 = this.clone(), h3 = i.clone();
        a2.negative = 0, h3.negative = 0;
        for (var s3 = 0;a2.isEven() && h3.isEven(); s3++)
          a2.iushrn(1), h3.iushrn(1);
        do {
          for (;a2.isEven(); )
            a2.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u3 = a2.cmp(h3);
          if (u3 < 0) {
            var c2 = a2;
            a2 = h3, h3 = c2;
          } else if (u3 === 0 || h3.cmpn(1) === 0)
            break;
          a2.isub(h3);
        } while (true);
        return h3.iushln(s3);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 1 << a2;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s3, this;
        for (var u3 = s3, c2 = h3;u3 !== 0 && c2 < this.length; c2++) {
          var b3 = this.words[c2] | 0;
          b3 += u3, u3 = b3 >>> 26, b3 &= 67108863, this.words[c2] = b3;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a2 = i < 0;
        if (this.negative !== 0 && !a2)
          return -1;
        if (this.negative === 0 && a2)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a2 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h3 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a2 = this.ucmp(i);
        return this.negative !== 0 ? -a2 | 0 : a2;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = this.words[h3] | 0, u3 = i.words[h3] | 0;
          if (s3 !== u3) {
            s3 < u3 ? a2 = -1 : s3 > u3 && (a2 = 1);
            break;
          }
        }
        return a2;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a2 = i, h3;
        do
          this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h3 = a2.bitLength();
        while (h3 > this.n);
        var s3 = h3 < this.n ? -1 : a2.ucmp(this.p);
        return s3 === 0 ? (a2.words[0] = 0, a2.length = 1) : s3 > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
      }, ye.prototype.split = function(i, a2) {
        i.iushrn(this.n, 0, a2);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a2) {
        for (var h3 = 4194303, s3 = Math.min(i.length, 9), u3 = 0;u3 < s3; u3++)
          a2.words[u3] = i.words[u3];
        if (a2.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a2.words[a2.length++] = c2 & h3, u3 = 10;u3 < i.length; u3++) {
          var b3 = i.words[u3] | 0;
          i.words[u3 - 10] = (b3 & h3) << 4 | c2 >>> 22, c2 = b3;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = i.words[h3] | 0;
          a2 += s3 * 977, i.words[h3] = a2 & 67108863, a2 = s3 * 64 + (a2 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = (i.words[h3] | 0) * 19 + a2, u3 = s3 & 67108863;
          s3 >>>= 26, i.words[h3] = u3, a2 = s3;
        }
        return a2 !== 0 && (i.words[i.length++] = a2), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a2;
        if (i === "k256")
          a2 = new xe;
        else if (i === "p224")
          a2 = new Re;
        else if (i === "p192")
          a2 = new Ee;
        else if (i === "p25519")
          a2 = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a2, a2;
      };
      function P2(v) {
        if (typeof v == "string") {
          var i = f2._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a2) {
        r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.add(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.iadd(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.sub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.isub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a2) {
        return this._verify1(i), this.imod(i.ushln(a2));
      }, P2.prototype.imul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.imul(a2));
      }, P2.prototype.mul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.mul(a2));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a2 = this.m.andln(3);
        if (r(a2 % 2 === 1), a2 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s3 = this.m.subn(1), u3 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u3++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f2(1).toRed(this), b3 = c2.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
          n.redIAdd(b3);
        for (var d2 = this.pow(n, s3), w = this.pow(i, s3.addn(1).iushrn(1)), g3 = this.pow(i, s3), _4 = u3;g3.cmp(c2) !== 0; ) {
          for (var A2 = g3, R2 = 0;A2.cmp(c2) !== 0; R2++)
            A2 = A2.redSqr();
          r(R2 < _4);
          var I3 = this.pow(d2, new f2(1).iushln(_4 - R2 - 1));
          w = w.redMul(I3), d2 = I3.redSqr(), g3 = g3.redMul(d2), _4 = R2;
        }
        return w;
      }, P2.prototype.invm = function(i) {
        var a2 = i._invmp(this.m);
        return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
      }, P2.prototype.pow = function(i, a2) {
        if (a2.isZero())
          return new f2(1).toRed(this);
        if (a2.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s3 = new Array(1 << h3);
        s3[0] = new f2(1).toRed(this), s3[1] = i;
        for (var u3 = 2;u3 < s3.length; u3++)
          s3[u3] = this.mul(s3[u3 - 1], i);
        var c2 = s3[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a2.length - 1;u3 >= 0; u3--) {
          for (var d2 = a2.words[u3], w = n - 1;w >= 0; w--) {
            var g3 = d2 >> w & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g3 === 0 && b3 === 0) {
              l2 = 0;
              continue;
            }
            b3 <<= 1, b3 |= g3, l2++, !(l2 !== h3 && (u3 !== 0 || w !== 0)) && (c2 = this.mul(c2, s3[b3]), l2 = 0, b3 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a2 = i.umod(this.m);
        return a2 === i ? a2.clone() : a2;
      }, P2.prototype.convertFrom = function(i) {
        var a2 = i.clone();
        return a2.red = null, a2;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P2.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a2 = this.imod(i.mul(this.rinv));
        return a2.red = null, a2;
      }, Se.prototype.imul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a2), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.mul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a2), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a2 = this.imod(i._invmp(this.m).mul(this.r2));
        return a2._forceRed(this);
      };
    })(typeof yd > "u" || yd, L3);
  });
  P3 = T2((wL, D3) => {
    var bq = o0(), mq = N3();
    D3.exports = function(e) {
      return new Zn(e);
    };
    var hr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    hr.p224 = hr.secp224r1;
    hr.p256 = hr.secp256r1 = hr.prime256v1;
    hr.p192 = hr.secp192r1 = hr.prime192v1;
    hr.p384 = hr.secp384r1;
    hr.p521 = hr.secp521r1;
    function Zn(t) {
      this.curveType = hr[t], this.curveType || (this.curveType = { name: t }), this.curve = new bq.ec(this.curveType.name), this.keys = undefined;
    }
    Zn.prototype.generateKeys = function(t, e) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
    };
    Zn.prototype.computeSecret = function(t, e, r) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var o = this.curve.keyFromPublic(t).getPublic(), f2 = o.mul(this.keys.getPrivate()).getX();
      return wd(f2, r, this.curveType.byteLength);
    };
    Zn.prototype.getPublicKey = function(t, e) {
      var r = this.keys.getPublic(e === "compressed", true);
      return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), wd(r, t);
    };
    Zn.prototype.getPrivateKey = function(t) {
      return wd(this.keys.getPrivate(), t);
    };
    Zn.prototype.setPublicKey = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this;
    };
    Zn.prototype.setPrivateKey = function(t, e) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var r = new mq(t);
      return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function wd(t, e, r) {
      Array.isArray(t) || (t = t.toArray());
      var o = new Buffer(t);
      if (r && o.length < r) {
        var f2 = new Buffer(r - o.length);
        f2.fill(0), o = Buffer.concat([f2, o]);
      }
      return e ? o.toString(e) : o;
    }
  });
  _d = T2((ML, C3) => {
    var gq = bf(), Md = Te().Buffer;
    C3.exports = function(t, e) {
      for (var r = Md.alloc(0), o = 0, f2;r.length < e; )
        f2 = yq(o++), r = Md.concat([r, gq("sha1").update(t).update(f2).digest()]);
      return r.slice(0, e);
    };
    function yq(t) {
      var e = Md.allocUnsafe(4);
      return e.writeUInt32BE(t, 0), e;
    }
  });
  xd = T2((_L, O3) => {
    O3.exports = function(e, r) {
      for (var o = e.length, f2 = -1;++f2 < o; )
        e[f2] ^= r[f2];
      return e;
    };
  });
  w0 = T2((F3, Sd) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a2 = function() {
        };
        a2.prototype = i.prototype, v.prototype = new a2, v.prototype.constructor = v;
      }
      function f2(v, i, a2) {
        if (f2.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a2 = i, i = 10), this._init(v || 0, i || 10, a2 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a2) {
        return i.cmp(a2) > 0 ? i : a2;
      }, f2.min = function(i, a2) {
        return i.cmp(a2) < 0 ? i : a2;
      }, f2.prototype._init = function(i, a2, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a2, h3);
        if (typeof i == "object")
          return this._initArray(i, a2, h3);
        a2 === "hex" && (a2 = 16), r(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a2 === 16 ? this._parseHex(i, s3, h3) : (this._parseBase(i, a2, s3), h3 === "le" && this._initArray(this.toArray(), a2, h3)));
      }, f2.prototype._initNumber = function(i, a2, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a2, h3);
      }, f2.prototype._initArray = function(i, a2, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3, c2, b3 = 0;
        if (h3 === "be")
          for (s3 = i.length - 1, u3 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u3] |= c2 << b3 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u3++);
        else if (h3 === "le")
          for (s3 = 0, u3 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u3] |= c2 << b3 & 67108863, this.words[u3 + 1] = c2 >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u3++);
        return this.strip();
      };
      function m2(v, i) {
        var a2 = v.charCodeAt(i);
        return a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : a2 - 48 & 15;
      }
      function y3(v, i, a2) {
        var h3 = m2(v, a2);
        return a2 - 1 >= i && (h3 |= m2(v, a2 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a2, h3) {
        this.length = Math.ceil((i.length - a2) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u3 = 0, c2 = 0, b3;
        if (h3 === "be")
          for (s3 = i.length - 1;s3 >= a2; s3 -= 2)
            b3 = y3(i, a2, s3) << u3, this.words[c2] |= b3 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b3 >>> 26) : u3 += 8;
        else {
          var l2 = i.length - a2;
          for (s3 = l2 % 2 === 0 ? a2 + 1 : a2;s3 < i.length; s3 += 2)
            b3 = y3(i, a2, s3) << u3, this.words[c2] |= b3 & 67108863, u3 >= 18 ? (u3 -= 18, c2 += 1, this.words[c2] |= b3 >>> 26) : u3 += 8;
        }
        this.strip();
      };
      function M2(v, i, a2, h3) {
        for (var s3 = 0, u3 = Math.min(v.length, a2), c2 = i;c2 < u3; c2++) {
          var b3 = v.charCodeAt(c2) - 48;
          s3 *= h3, b3 >= 49 ? s3 += b3 - 49 + 10 : b3 >= 17 ? s3 += b3 - 17 + 10 : s3 += b3;
        }
        return s3;
      }
      f2.prototype._parseBase = function(i, a2, h3) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u3 = 1;u3 <= 67108863; u3 *= a2)
          s3++;
        s3--, u3 = u3 / a2 | 0;
        for (var c2 = i.length - h3, b3 = c2 % s3, l2 = Math.min(c2, c2 - b3) + h3, n = 0, d2 = h3;d2 < l2; d2 += s3)
          n = M2(i, d2, d2 + s3, a2), this.imuln(u3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b3 !== 0) {
          var w = 1;
          for (n = M2(i, d2, i.length, a2), d2 = 0;d2 < b3; d2++)
            w *= a2;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a2 = 0;a2 < this.length; a2++)
          i.words[a2] = this.words[a2];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a2) {
        i = i || 10, a2 = a2 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s3 = 0, u3 = 0, c2 = 0;c2 < this.length; c2++) {
            var b3 = this.words[c2], l2 = ((b3 << s3 | u3) & 16777215).toString(16);
            u3 = b3 >>> 24 - s3 & 16777215, u3 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l2.length] + l2 + h3 : h3 = l2 + h3, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u3 !== 0 && (h3 = u3.toString(16) + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d2 = E3[i];
          h3 = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g3 = w.modn(d2).toString(i);
            w = w.idivn(d2), w.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a2 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a2) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a2);
      }, f2.prototype.toArray = function(i, a2) {
        return this.toArrayLike(Array, i, a2);
      }, f2.prototype.toArrayLike = function(i, a2, h3) {
        var s3 = this.byteLength(), u3 = h3 || Math.max(1, s3);
        r(s3 <= u3, "byte array longer than desired length"), r(u3 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a2 === "le", b3 = new i(u3), l2, n, d2 = this.clone();
        if (c2) {
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b3[n] = l2;
          for (;n < u3; n++)
            b3[n] = 0;
        } else {
          for (n = 0;n < u3 - s3; n++)
            b3[n] = 0;
          for (n = 0;!d2.isZero(); n++)
            l2 = d2.andln(255), d2.iushrn(8), b3[u3 - n - 1] = l2;
        }
        return b3;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a2 = i, h3 = 0;
        return a2 >= 4096 && (h3 += 13, a2 >>>= 13), a2 >= 64 && (h3 += 7, a2 >>>= 7), a2 >= 8 && (h3 += 4, a2 >>>= 4), a2 >= 2 && (h3 += 2, a2 >>>= 2), h3 + a2;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a2 = i, h3 = 0;
        return (a2 & 8191) === 0 && (h3 += 13, a2 >>>= 13), (a2 & 127) === 0 && (h3 += 7, a2 >>>= 7), (a2 & 15) === 0 && (h3 += 4, a2 >>>= 4), (a2 & 3) === 0 && (h3 += 2, a2 >>>= 2), (a2 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a2 = this._countBits(i);
        return (this.length - 1) * 26 + a2;
      };
      function B3(v) {
        for (var i = new Array(v.bitLength()), a2 = 0;a2 < i.length; a2++) {
          var h3 = a2 / 26 | 0, s3 = a2 % 26;
          i[a2] = (v.words[h3] & 1 << s3) >>> s3;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a2 = 0;a2 < this.length; a2++) {
          var h3 = this._zeroBits(this.words[a2]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a2 = 0;a2 < i.length; a2++)
          this.words[a2] = this.words[a2] | i.words[a2];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a2;
        this.length > i.length ? a2 = i : a2 = this;
        for (var h3 = 0;h3 < a2.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a2, h3;
        this.length > i.length ? (a2 = this, h3 = i) : (a2 = i, h3 = this);
        for (var s3 = 0;s3 < h3.length; s3++)
          this.words[s3] = a2.words[s3] ^ h3.words[s3];
        if (this !== a2)
          for (;s3 < a2.length; s3++)
            this.words[s3] = a2.words[s3];
        return this.length = a2.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a2), h3 > 0 && a2--;
        for (var s3 = 0;s3 < a2; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h3 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a2) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s3 = i % 26;
        return this._expand(h3 + 1), a2 ? this.words[h3] = this.words[h3] | 1 << s3 : this.words[h3] = this.words[h3] & ~(1 << s3), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a2;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a2 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a2 = this.isub(i), i.negative = 1, a2._normSign();
        var h3, s3;
        this.length > i.length ? (h3 = this, s3 = i) : (h3 = i, s3 = this);
        for (var u3 = 0, c2 = 0;c2 < s3.length; c2++)
          a2 = (h3.words[c2] | 0) + (s3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        for (;u3 !== 0 && c2 < h3.length; c2++)
          a2 = (h3.words[c2] | 0) + u3, this.words[c2] = a2 & 67108863, u3 = a2 >>> 26;
        if (this.length = h3.length, u3 !== 0)
          this.words[this.length] = u3, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a2;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a2 = this.sub(i), i.negative ^= 1, a2) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = i.sub(this), this.negative = 1, a2) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a2 = this.iadd(i);
          return i.negative = 1, a2._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u3;
        h3 > 0 ? (s3 = this, u3 = i) : (s3 = i, u3 = this);
        for (var c2 = 0, b3 = 0;b3 < u3.length; b3++)
          a2 = (s3.words[b3] | 0) - (u3.words[b3] | 0) + c2, c2 = a2 >> 26, this.words[b3] = a2 & 67108863;
        for (;c2 !== 0 && b3 < s3.length; b3++)
          a2 = (s3.words[b3] | 0) + c2, c2 = a2 >> 26, this.words[b3] = a2 & 67108863;
        if (c2 === 0 && b3 < s3.length && s3 !== this)
          for (;b3 < s3.length; b3++)
            this.words[b3] = s3.words[b3];
        return this.length = Math.max(this.length, b3), s3 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q2(v, i, a2) {
        a2.negative = i.negative ^ v.negative;
        var h3 = v.length + i.length | 0;
        a2.length = h3, h3 = h3 - 1 | 0;
        var s3 = v.words[0] | 0, u3 = i.words[0] | 0, c2 = s3 * u3, b3 = c2 & 67108863, l2 = c2 / 67108864 | 0;
        a2.words[0] = b3;
        for (var n = 1;n < h3; n++) {
          for (var d2 = l2 >>> 26, w = l2 & 67108863, g3 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v.length + 1);_4 <= g3; _4++) {
            var A2 = n - _4 | 0;
            s3 = v.words[A2] | 0, u3 = i.words[_4] | 0, c2 = s3 * u3 + w, d2 += c2 / 67108864 | 0, w = c2 & 67108863;
          }
          a2.words[n] = w | 0, l2 = d2 | 0;
        }
        return l2 !== 0 ? a2.words[n] = l2 | 0 : a2.length--, a2.strip();
      }
      var L3 = function(i, a2, h3) {
        var s3 = i.words, u3 = a2.words, c2 = h3.words, b3 = 0, l2, n, d2, w = s3[0] | 0, g3 = w & 8191, _4 = w >>> 13, A2 = s3[1] | 0, R2 = A2 & 8191, I3 = A2 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt = s3[3] | 0, C = nt & 8191, O3 = nt >>> 13, vt = s3[4] | 0, F = vt & 8191, U3 = vt >>> 13, bt = s3[5] | 0, z = bt & 8191, H2 = bt >>> 13, mt = s3[6] | 0, W = mt & 8191, K2 = mt >>> 13, gt = s3[7] | 0, j3 = gt & 8191, Z3 = gt >>> 13, yt = s3[8] | 0, V3 = yt & 8191, $2 = yt >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y2 = wt >>> 13, Mt = u3[0] | 0, X3 = Mt & 8191, J2 = Mt >>> 13, _t = u3[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u3[2] | 0, te = xt & 8191, re = xt >>> 13, St = u3[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u3[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u3[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u3[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u3[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u3[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u3[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a2.negative, h3.length = 19, l2 = Math.imul(g3, X3), n = Math.imul(g3, J2), n = n + Math.imul(_4, X3) | 0, d2 = Math.imul(_4, J2);
        var ft = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l2 = Math.imul(R2, X3), n = Math.imul(R2, J2), n = n + Math.imul(I3, X3) | 0, d2 = Math.imul(I3, J2), l2 = l2 + Math.imul(g3, Q3) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_4, Q3) | 0, d2 = d2 + Math.imul(_4, ee) | 0;
        var Be = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l2 = Math.imul(k4, X3), n = Math.imul(k4, J2), n = n + Math.imul(D2, X3) | 0, d2 = Math.imul(D2, J2), l2 = l2 + Math.imul(R2, Q3) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I3, Q3) | 0, d2 = d2 + Math.imul(I3, ee) | 0, l2 = l2 + Math.imul(g3, te) | 0, n = n + Math.imul(g3, re) | 0, n = n + Math.imul(_4, te) | 0, d2 = d2 + Math.imul(_4, re) | 0;
        var qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l2 = Math.imul(C, X3), n = Math.imul(C, J2), n = n + Math.imul(O3, X3) | 0, d2 = Math.imul(O3, J2), l2 = l2 + Math.imul(k4, Q3) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D2, Q3) | 0, d2 = d2 + Math.imul(D2, ee) | 0, l2 = l2 + Math.imul(R2, te) | 0, n = n + Math.imul(R2, re) | 0, n = n + Math.imul(I3, te) | 0, d2 = d2 + Math.imul(I3, re) | 0, l2 = l2 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_4, ie) | 0, d2 = d2 + Math.imul(_4, ne) | 0;
        var ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l2 = Math.imul(F, X3), n = Math.imul(F, J2), n = n + Math.imul(U3, X3) | 0, d2 = Math.imul(U3, J2), l2 = l2 + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O3, Q3) | 0, d2 = d2 + Math.imul(O3, ee) | 0, l2 = l2 + Math.imul(k4, te) | 0, n = n + Math.imul(k4, re) | 0, n = n + Math.imul(D2, te) | 0, d2 = d2 + Math.imul(D2, re) | 0, l2 = l2 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I3, ie) | 0, d2 = d2 + Math.imul(I3, ne) | 0, l2 = l2 + Math.imul(g3, fe) | 0, n = n + Math.imul(g3, ae) | 0, n = n + Math.imul(_4, fe) | 0, d2 = d2 + Math.imul(_4, ae) | 0;
        var He = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l2 = Math.imul(z, X3), n = Math.imul(z, J2), n = n + Math.imul(H2, X3) | 0, d2 = Math.imul(H2, J2), l2 = l2 + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U3, Q3) | 0, d2 = d2 + Math.imul(U3, ee) | 0, l2 = l2 + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O3, te) | 0, d2 = d2 + Math.imul(O3, re) | 0, l2 = l2 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne) | 0, n = n + Math.imul(D2, ie) | 0, d2 = d2 + Math.imul(D2, ne) | 0, l2 = l2 + Math.imul(R2, fe) | 0, n = n + Math.imul(R2, ae) | 0, n = n + Math.imul(I3, fe) | 0, d2 = d2 + Math.imul(I3, ae) | 0, l2 = l2 + Math.imul(g3, oe) | 0, n = n + Math.imul(g3, se) | 0, n = n + Math.imul(_4, oe) | 0, d2 = d2 + Math.imul(_4, se) | 0;
        var We = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l2 = Math.imul(W, X3), n = Math.imul(W, J2), n = n + Math.imul(K2, X3) | 0, d2 = Math.imul(K2, J2), l2 = l2 + Math.imul(z, Q3) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q3) | 0, d2 = d2 + Math.imul(H2, ee) | 0, l2 = l2 + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U3, te) | 0, d2 = d2 + Math.imul(U3, re) | 0, l2 = l2 + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O3, ie) | 0, d2 = d2 + Math.imul(O3, ne) | 0, l2 = l2 + Math.imul(k4, fe) | 0, n = n + Math.imul(k4, ae) | 0, n = n + Math.imul(D2, fe) | 0, d2 = d2 + Math.imul(D2, ae) | 0, l2 = l2 + Math.imul(R2, oe) | 0, n = n + Math.imul(R2, se) | 0, n = n + Math.imul(I3, oe) | 0, d2 = d2 + Math.imul(I3, se) | 0, l2 = l2 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue) | 0, n = n + Math.imul(_4, he) | 0, d2 = d2 + Math.imul(_4, ue) | 0;
        var Ke = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l2 = Math.imul(j3, X3), n = Math.imul(j3, J2), n = n + Math.imul(Z3, X3) | 0, d2 = Math.imul(Z3, J2), l2 = l2 + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K2, Q3) | 0, d2 = d2 + Math.imul(K2, ee) | 0, l2 = l2 + Math.imul(z, te) | 0, n = n + Math.imul(z, re) | 0, n = n + Math.imul(H2, te) | 0, d2 = d2 + Math.imul(H2, re) | 0, l2 = l2 + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U3, ie) | 0, d2 = d2 + Math.imul(U3, ne) | 0, l2 = l2 + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O3, fe) | 0, d2 = d2 + Math.imul(O3, ae) | 0, l2 = l2 + Math.imul(k4, oe) | 0, n = n + Math.imul(k4, se) | 0, n = n + Math.imul(D2, oe) | 0, d2 = d2 + Math.imul(D2, se) | 0, l2 = l2 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue) | 0, n = n + Math.imul(I3, he) | 0, d2 = d2 + Math.imul(I3, ue) | 0, l2 = l2 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_4, le) | 0, d2 = d2 + Math.imul(_4, de) | 0;
        var je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l2 = Math.imul(V3, X3), n = Math.imul(V3, J2), n = n + Math.imul($2, X3) | 0, d2 = Math.imul($2, J2), l2 = l2 + Math.imul(j3, Q3) | 0, n = n + Math.imul(j3, ee) | 0, n = n + Math.imul(Z3, Q3) | 0, d2 = d2 + Math.imul(Z3, ee) | 0, l2 = l2 + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K2, te) | 0, d2 = d2 + Math.imul(K2, re) | 0, l2 = l2 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d2 = d2 + Math.imul(H2, ne) | 0, l2 = l2 + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U3, fe) | 0, d2 = d2 + Math.imul(U3, ae) | 0, l2 = l2 + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O3, oe) | 0, d2 = d2 + Math.imul(O3, se) | 0, l2 = l2 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue) | 0, n = n + Math.imul(D2, he) | 0, d2 = d2 + Math.imul(D2, ue) | 0, l2 = l2 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I3, le) | 0, d2 = d2 + Math.imul(I3, de) | 0, l2 = l2 + Math.imul(g3, ce) | 0, n = n + Math.imul(g3, pe) | 0, n = n + Math.imul(_4, ce) | 0, d2 = d2 + Math.imul(_4, pe) | 0;
        var Ze = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l2 = Math.imul(G2, X3), n = Math.imul(G2, J2), n = n + Math.imul(Y2, X3) | 0, d2 = Math.imul(Y2, J2), l2 = l2 + Math.imul(V3, Q3) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($2, Q3) | 0, d2 = d2 + Math.imul($2, ee) | 0, l2 = l2 + Math.imul(j3, te) | 0, n = n + Math.imul(j3, re) | 0, n = n + Math.imul(Z3, te) | 0, d2 = d2 + Math.imul(Z3, re) | 0, l2 = l2 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K2, ie) | 0, d2 = d2 + Math.imul(K2, ne) | 0, l2 = l2 + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d2 = d2 + Math.imul(H2, ae) | 0, l2 = l2 + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U3, oe) | 0, d2 = d2 + Math.imul(U3, se) | 0, l2 = l2 + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O3, he) | 0, d2 = d2 + Math.imul(O3, ue) | 0, l2 = l2 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D2, le) | 0, d2 = d2 + Math.imul(D2, de) | 0, l2 = l2 + Math.imul(R2, ce) | 0, n = n + Math.imul(R2, pe) | 0, n = n + Math.imul(I3, ce) | 0, d2 = d2 + Math.imul(I3, pe) | 0, l2 = l2 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_4, ve) | 0, d2 = d2 + Math.imul(_4, be) | 0;
        var Ve = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l2 = Math.imul(G2, Q3), n = Math.imul(G2, ee), n = n + Math.imul(Y2, Q3) | 0, d2 = Math.imul(Y2, ee), l2 = l2 + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re) | 0, n = n + Math.imul($2, te) | 0, d2 = d2 + Math.imul($2, re) | 0, l2 = l2 + Math.imul(j3, ie) | 0, n = n + Math.imul(j3, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d2 = d2 + Math.imul(Z3, ne) | 0, l2 = l2 + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K2, fe) | 0, d2 = d2 + Math.imul(K2, ae) | 0, l2 = l2 + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d2 = d2 + Math.imul(H2, se) | 0, l2 = l2 + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U3, he) | 0, d2 = d2 + Math.imul(U3, ue) | 0, l2 = l2 + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O3, le) | 0, d2 = d2 + Math.imul(O3, de) | 0, l2 = l2 + Math.imul(k4, ce) | 0, n = n + Math.imul(k4, pe) | 0, n = n + Math.imul(D2, ce) | 0, d2 = d2 + Math.imul(D2, pe) | 0, l2 = l2 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I3, ve) | 0, d2 = d2 + Math.imul(I3, be) | 0;
        var $e = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l2 = Math.imul(G2, te), n = Math.imul(G2, re), n = n + Math.imul(Y2, te) | 0, d2 = Math.imul(Y2, re), l2 = l2 + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($2, ie) | 0, d2 = d2 + Math.imul($2, ne) | 0, l2 = l2 + Math.imul(j3, fe) | 0, n = n + Math.imul(j3, ae) | 0, n = n + Math.imul(Z3, fe) | 0, d2 = d2 + Math.imul(Z3, ae) | 0, l2 = l2 + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K2, oe) | 0, d2 = d2 + Math.imul(K2, se) | 0, l2 = l2 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d2 = d2 + Math.imul(H2, ue) | 0, l2 = l2 + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U3, le) | 0, d2 = d2 + Math.imul(U3, de) | 0, l2 = l2 + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O3, ce) | 0, d2 = d2 + Math.imul(O3, pe) | 0, l2 = l2 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be) | 0, n = n + Math.imul(D2, ve) | 0, d2 = d2 + Math.imul(D2, be) | 0;
        var Ge = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l2 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y2, ie) | 0, d2 = Math.imul(Y2, ne), l2 = l2 + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($2, fe) | 0, d2 = d2 + Math.imul($2, ae) | 0, l2 = l2 + Math.imul(j3, oe) | 0, n = n + Math.imul(j3, se) | 0, n = n + Math.imul(Z3, oe) | 0, d2 = d2 + Math.imul(Z3, se) | 0, l2 = l2 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K2, he) | 0, d2 = d2 + Math.imul(K2, ue) | 0, l2 = l2 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d2 = d2 + Math.imul(H2, de) | 0, l2 = l2 + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U3, ce) | 0, d2 = d2 + Math.imul(U3, pe) | 0, l2 = l2 + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O3, ve) | 0, d2 = d2 + Math.imul(O3, be) | 0;
        var Ye = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l2 = Math.imul(G2, fe), n = Math.imul(G2, ae), n = n + Math.imul(Y2, fe) | 0, d2 = Math.imul(Y2, ae), l2 = l2 + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($2, oe) | 0, d2 = d2 + Math.imul($2, se) | 0, l2 = l2 + Math.imul(j3, he) | 0, n = n + Math.imul(j3, ue) | 0, n = n + Math.imul(Z3, he) | 0, d2 = d2 + Math.imul(Z3, ue) | 0, l2 = l2 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K2, le) | 0, d2 = d2 + Math.imul(K2, de) | 0, l2 = l2 + Math.imul(z, ce) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce) | 0, d2 = d2 + Math.imul(H2, pe) | 0, l2 = l2 + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U3, ve) | 0, d2 = d2 + Math.imul(U3, be) | 0;
        var Xe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l2 = Math.imul(G2, oe), n = Math.imul(G2, se), n = n + Math.imul(Y2, oe) | 0, d2 = Math.imul(Y2, se), l2 = l2 + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($2, he) | 0, d2 = d2 + Math.imul($2, ue) | 0, l2 = l2 + Math.imul(j3, le) | 0, n = n + Math.imul(j3, de) | 0, n = n + Math.imul(Z3, le) | 0, d2 = d2 + Math.imul(Z3, de) | 0, l2 = l2 + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K2, ce) | 0, d2 = d2 + Math.imul(K2, pe) | 0, l2 = l2 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d2 = d2 + Math.imul(H2, be) | 0;
        var Je = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l2 = Math.imul(G2, he), n = Math.imul(G2, ue), n = n + Math.imul(Y2, he) | 0, d2 = Math.imul(Y2, ue), l2 = l2 + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($2, le) | 0, d2 = d2 + Math.imul($2, de) | 0, l2 = l2 + Math.imul(j3, ce) | 0, n = n + Math.imul(j3, pe) | 0, n = n + Math.imul(Z3, ce) | 0, d2 = d2 + Math.imul(Z3, pe) | 0, l2 = l2 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K2, ve) | 0, d2 = d2 + Math.imul(K2, be) | 0;
        var Qe = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l2 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y2, le) | 0, d2 = Math.imul(Y2, de), l2 = l2 + Math.imul(V3, ce) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($2, ce) | 0, d2 = d2 + Math.imul($2, pe) | 0, l2 = l2 + Math.imul(j3, ve) | 0, n = n + Math.imul(j3, be) | 0, n = n + Math.imul(Z3, ve) | 0, d2 = d2 + Math.imul(Z3, be) | 0;
        var et = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l2 = Math.imul(G2, ce), n = Math.imul(G2, pe), n = n + Math.imul(Y2, ce) | 0, d2 = Math.imul(Y2, pe), l2 = l2 + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($2, ve) | 0, d2 = d2 + Math.imul($2, be) | 0;
        var tt = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        b3 = (d2 + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l2 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y2, ve) | 0, d2 = Math.imul(Y2, be);
        var rt = (b3 + l2 | 0) + ((n & 8191) << 13) | 0;
        return b3 = (d2 + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe, c2[3] = ze, c2[4] = He, c2[5] = We, c2[6] = Ke, c2[7] = je, c2[8] = Ze, c2[9] = Ve, c2[10] = $e, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe, c2[16] = et, c2[17] = tt, c2[18] = rt, b3 !== 0 && (c2[19] = b3, h3.length++), h3;
      };
      Math.imul || (L3 = q2);
      function ge(v, i, a2) {
        a2.negative = i.negative ^ v.negative, a2.length = v.length + i.length;
        for (var h3 = 0, s3 = 0, u3 = 0;u3 < a2.length - 1; u3++) {
          var c2 = s3;
          s3 = 0;
          for (var b3 = h3 & 67108863, l2 = Math.min(u3, i.length - 1), n = Math.max(0, u3 - v.length + 1);n <= l2; n++) {
            var d2 = u3 - n, w = v.words[d2] | 0, g3 = i.words[n] | 0, _4 = w * g3, A2 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A2 = A2 + b3 | 0, b3 = A2 & 67108863, c2 = c2 + (A2 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a2.words[u3] = b3, h3 = c2, c2 = s3;
        }
        return h3 !== 0 ? a2.words[u3] = h3 : a2.length--, a2.strip();
      }
      function _e(v, i, a2) {
        var h3 = new N4;
        return h3.mulp(v, i, a2);
      }
      f2.prototype.mulTo = function(i, a2) {
        var h3, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a2) : s3 < 63 ? h3 = q2(this, i, a2) : s3 < 1024 ? h3 = ge(this, i, a2) : h3 = _e(this, i, a2), h3;
      };
      function N4(v, i) {
        this.x = v, this.y = i;
      }
      N4.prototype.makeRBT = function(i) {
        for (var a2 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a2[s3] = this.revBin(s3, h3, i);
        return a2;
      }, N4.prototype.revBin = function(i, a2, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s3 = 0, u3 = 0;u3 < a2; u3++)
          s3 |= (i & 1) << a2 - u3 - 1, i >>= 1;
        return s3;
      }, N4.prototype.permute = function(i, a2, h3, s3, u3, c2) {
        for (var b3 = 0;b3 < c2; b3++)
          s3[b3] = a2[i[b3]], u3[b3] = h3[i[b3]];
      }, N4.prototype.transform = function(i, a2, h3, s3, u3, c2) {
        this.permute(c2, i, a2, h3, s3, u3);
        for (var b3 = 1;b3 < u3; b3 <<= 1)
          for (var l2 = b3 << 1, n = Math.cos(2 * Math.PI / l2), d2 = Math.sin(2 * Math.PI / l2), w = 0;w < u3; w += l2)
            for (var g3 = n, _4 = d2, A2 = 0;A2 < b3; A2++) {
              var R2 = h3[w + A2], I3 = s3[w + A2], Me = h3[w + A2 + b3], k4 = s3[w + A2 + b3], D2 = g3 * Me - _4 * k4;
              k4 = g3 * k4 + _4 * Me, Me = D2, h3[w + A2] = R2 + Me, s3[w + A2] = I3 + k4, h3[w + A2 + b3] = R2 - Me, s3[w + A2 + b3] = I3 - k4, A2 !== l2 && (D2 = n * g3 - d2 * _4, _4 = n * _4 + d2 * g3, g3 = D2);
            }
      }, N4.prototype.guessLen13b = function(i, a2) {
        var h3 = Math.max(a2, i) | 1, s3 = h3 & 1, u3 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u3++;
        return 1 << u3 + 1 + s3;
      }, N4.prototype.conjugate = function(i, a2, h3) {
        if (!(h3 <= 1))
          for (var s3 = 0;s3 < h3 / 2; s3++) {
            var u3 = i[s3];
            i[s3] = i[h3 - s3 - 1], i[h3 - s3 - 1] = u3, u3 = a2[s3], a2[s3] = -a2[h3 - s3 - 1], a2[h3 - s3 - 1] = -u3;
          }
      }, N4.prototype.normalize13b = function(i, a2) {
        for (var h3 = 0, s3 = 0;s3 < a2 / 2; s3++) {
          var u3 = Math.round(i[2 * s3 + 1] / a2) * 8192 + Math.round(i[2 * s3] / a2) + h3;
          i[s3] = u3 & 67108863, u3 < 67108864 ? h3 = 0 : h3 = u3 / 67108864 | 0;
        }
        return i;
      }, N4.prototype.convert13b = function(i, a2, h3, s3) {
        for (var u3 = 0, c2 = 0;c2 < a2; c2++)
          u3 = u3 + (i[c2] | 0), h3[2 * c2] = u3 & 8191, u3 = u3 >>> 13, h3[2 * c2 + 1] = u3 & 8191, u3 = u3 >>> 13;
        for (c2 = 2 * a2;c2 < s3; ++c2)
          h3[c2] = 0;
        r(u3 === 0), r((u3 & -8192) === 0);
      }, N4.prototype.stub = function(i) {
        for (var a2 = new Array(i), h3 = 0;h3 < i; h3++)
          a2[h3] = 0;
        return a2;
      }, N4.prototype.mulp = function(i, a2, h3) {
        var s3 = 2 * this.guessLen13b(i.length, a2.length), u3 = this.makeRBT(s3), c2 = this.stub(s3), b3 = new Array(s3), l2 = new Array(s3), n = new Array(s3), d2 = new Array(s3), w = new Array(s3), g3 = new Array(s3), _4 = h3.words;
        _4.length = s3, this.convert13b(i.words, i.length, b3, s3), this.convert13b(a2.words, a2.length, d2, s3), this.transform(b3, c2, l2, n, s3, u3), this.transform(d2, c2, w, g3, s3, u3);
        for (var A2 = 0;A2 < s3; A2++) {
          var R2 = l2[A2] * w[A2] - n[A2] * g3[A2];
          n[A2] = l2[A2] * g3[A2] + n[A2] * w[A2], l2[A2] = R2;
        }
        return this.conjugate(l2, n, s3), this.transform(l2, n, _4, c2, s3, u3), this.conjugate(_4, c2, s3), this.normalize13b(_4, s3), h3.negative = i.negative ^ a2.negative, h3.length = i.length + a2.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), this.mulTo(i, a2);
      }, f2.prototype.mulf = function(i) {
        var a2 = new f2(null);
        return a2.words = new Array(this.length + i.length), _e(this, i, a2);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a2 = 0, h3 = 0;h3 < this.length; h3++) {
          var s3 = (this.words[h3] | 0) * i, u3 = (s3 & 67108863) + (a2 & 67108863);
          a2 >>= 26, a2 += s3 / 67108864 | 0, a2 += u3 >>> 26, this.words[h3] = u3 & 67108863;
        }
        return a2 !== 0 && (this.words[h3] = a2, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a2 = B3(i);
        if (a2.length === 0)
          return new f2(1);
        for (var h3 = this, s3 = 0;s3 < a2.length && a2[s3] === 0; s3++, h3 = h3.sqr())
          ;
        if (++s3 < a2.length)
          for (var u3 = h3.sqr();s3 < a2.length; s3++, u3 = u3.sqr())
            a2[s3] !== 0 && (h3 = h3.mul(u3));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 67108863 >>> 26 - a2 << 26 - a2, u3;
        if (a2 !== 0) {
          var c2 = 0;
          for (u3 = 0;u3 < this.length; u3++) {
            var b3 = this.words[u3] & s3, l2 = (this.words[u3] | 0) - b3 << a2;
            this.words[u3] = l2 | c2, c2 = b3 >>> 26 - a2;
          }
          c2 && (this.words[u3] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u3 = this.length - 1;u3 >= 0; u3--)
            this.words[u3 + h3] = this.words[u3];
          for (u3 = 0;u3 < h3; u3++)
            this.words[u3] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a2, h3) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a2 ? s3 = (a2 - a2 % 26) / 26 : s3 = 0;
        var u3 = i % 26, c2 = Math.min((i - u3) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u3 << u3, l2 = h3;
        if (s3 -= c2, s3 = Math.max(0, s3), l2) {
          for (var n = 0;n < c2; n++)
            l2.words[n] = this.words[n];
          l2.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d2 = 0;
        for (n = this.length - 1;n >= 0 && (d2 !== 0 || n >= s3); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d2 << 26 - u3 | w >>> u3, d2 = w & b3;
        }
        return l2 && d2 !== 0 && (l2.words[l2.length++] = d2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a2, h3) {
        return r(this.negative === 0), this.iushrn(i, a2, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 1 << a2;
        if (this.length <= h3)
          return false;
        var u3 = this.words[h3];
        return !!(u3 & s3);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a2 = i % 26, h3 = (i - a2) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a2 !== 0 && h3++, this.length = Math.min(h3, this.length), a2 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a2 << a2;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a2 = 0;a2 < this.length && this.words[a2] >= 67108864; a2++)
          this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
        return this.length = Math.max(this.length, a2 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a2 = 0;a2 < this.length && this.words[a2] < 0; a2++)
            this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a2, h3) {
        var s3 = i.length + h3, u3;
        this._expand(s3);
        var c2, b3 = 0;
        for (u3 = 0;u3 < i.length; u3++) {
          c2 = (this.words[u3 + h3] | 0) + b3;
          var l2 = (i.words[u3] | 0) * a2;
          c2 -= l2 & 67108863, b3 = (c2 >> 26) - (l2 / 67108864 | 0), this.words[u3 + h3] = c2 & 67108863;
        }
        for (;u3 < this.length - h3; u3++)
          c2 = (this.words[u3 + h3] | 0) + b3, b3 = c2 >> 26, this.words[u3 + h3] = c2 & 67108863;
        if (b3 === 0)
          return this.strip();
        for (r(b3 === -1), b3 = 0, u3 = 0;u3 < this.length; u3++)
          c2 = -(this.words[u3] | 0) + b3, b3 = c2 >> 26, this.words[u3] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a2) {
        var h3 = this.length - i.length, s3 = this.clone(), u3 = i, c2 = u3.words[u3.length - 1] | 0, b3 = this._countBits(c2);
        h3 = 26 - b3, h3 !== 0 && (u3 = u3.ushln(h3), s3.iushln(h3), c2 = u3.words[u3.length - 1] | 0);
        var l2 = s3.length - u3.length, n;
        if (a2 !== "mod") {
          n = new f2(null), n.length = l2 + 1, n.words = new Array(n.length);
          for (var d2 = 0;d2 < n.length; d2++)
            n.words[d2] = 0;
        }
        var w = s3.clone()._ishlnsubmul(u3, 1, l2);
        w.negative === 0 && (s3 = w, n && (n.words[l2] = 1));
        for (var g3 = l2 - 1;g3 >= 0; g3--) {
          var _4 = (s3.words[u3.length + g3] | 0) * 67108864 + (s3.words[u3.length + g3 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s3._ishlnsubmul(u3, _4, g3);s3.negative !== 0; )
            _4--, s3.negative = 0, s3._ishlnsubmul(u3, 1, g3), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g3] = _4);
        }
        return n && n.strip(), s3.strip(), a2 !== "div" && h3 !== 0 && s3.iushrn(h3), { div: n || null, mod: s3 };
      }, f2.prototype.divmod = function(i, a2, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s3, u3, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a2), a2 !== "mod" && (s3 = c2.div.neg()), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.iadd(i)), { div: s3, mod: u3 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a2), a2 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a2), a2 !== "div" && (u3 = c2.mod.neg(), h3 && u3.negative !== 0 && u3.isub(i)), { div: c2.div, mod: u3 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a2 === "div" ? { div: this.divn(i.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a2);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a2 = this.divmod(i);
        if (a2.mod.isZero())
          return a2.div;
        var h3 = a2.div.negative !== 0 ? a2.mod.isub(i) : a2.mod, s3 = i.ushrn(1), u3 = i.andln(1), c2 = h3.cmp(s3);
        return c2 < 0 || u3 === 1 && c2 === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a2 = (1 << 26) % i, h3 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h3 = (a2 * h3 + (this.words[s3] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = (this.words[h3] | 0) + a2 * 67108864;
          this.words[h3] = s3 / i | 0, a2 = s3 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s3 = new f2(1), u3 = new f2(0), c2 = new f2(0), b3 = new f2(1), l2 = 0;a2.isEven() && h3.isEven(); )
          a2.iushrn(1), h3.iushrn(1), ++l2;
        for (var n = h3.clone(), d2 = a2.clone();!a2.isZero(); ) {
          for (var w = 0, g3 = 1;(a2.words[0] & g3) === 0 && w < 26; ++w, g3 <<= 1)
            ;
          if (w > 0)
            for (a2.iushrn(w);w-- > 0; )
              (s3.isOdd() || u3.isOdd()) && (s3.iadd(n), u3.isub(d2)), s3.iushrn(1), u3.iushrn(1);
          for (var _4 = 0, A2 = 1;(h3.words[0] & A2) === 0 && _4 < 26; ++_4, A2 <<= 1)
            ;
          if (_4 > 0)
            for (h3.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b3.isOdd()) && (c2.iadd(n), b3.isub(d2)), c2.iushrn(1), b3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s3.isub(c2), u3.isub(b3)) : (h3.isub(a2), c2.isub(s3), b3.isub(u3));
        }
        return { a: c2, b: b3, gcd: h3.iushln(l2) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a2 = this, h3 = i.clone();
        a2.negative !== 0 ? a2 = a2.umod(i) : a2 = a2.clone();
        for (var s3 = new f2(1), u3 = new f2(0), c2 = h3.clone();a2.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b3 = 0, l2 = 1;(a2.words[0] & l2) === 0 && b3 < 26; ++b3, l2 <<= 1)
            ;
          if (b3 > 0)
            for (a2.iushrn(b3);b3-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d2 = 1;(h3.words[0] & d2) === 0 && n < 26; ++n, d2 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u3.isOdd() && u3.iadd(c2), u3.iushrn(1);
          a2.cmp(h3) >= 0 ? (a2.isub(h3), s3.isub(u3)) : (h3.isub(a2), u3.isub(s3));
        }
        var w;
        return a2.cmpn(1) === 0 ? w = s3 : w = u3, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a2 = this.clone(), h3 = i.clone();
        a2.negative = 0, h3.negative = 0;
        for (var s3 = 0;a2.isEven() && h3.isEven(); s3++)
          a2.iushrn(1), h3.iushrn(1);
        do {
          for (;a2.isEven(); )
            a2.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u3 = a2.cmp(h3);
          if (u3 < 0) {
            var c2 = a2;
            a2 = h3, h3 = c2;
          } else if (u3 === 0 || h3.cmpn(1) === 0)
            break;
          a2.isub(h3);
        } while (true);
        return h3.iushln(s3);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a2 = i % 26, h3 = (i - a2) / 26, s3 = 1 << a2;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s3, this;
        for (var u3 = s3, c2 = h3;u3 !== 0 && c2 < this.length; c2++) {
          var b3 = this.words[c2] | 0;
          b3 += u3, u3 = b3 >>> 26, b3 &= 67108863, this.words[c2] = b3;
        }
        return u3 !== 0 && (this.words[c2] = u3, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a2 = i < 0;
        if (this.negative !== 0 && !a2)
          return -1;
        if (this.negative === 0 && a2)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a2 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h3 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a2 = this.ucmp(i);
        return this.negative !== 0 ? -a2 | 0 : a2;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a2 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = this.words[h3] | 0, u3 = i.words[h3] | 0;
          if (s3 !== u3) {
            s3 < u3 ? a2 = -1 : s3 > u3 && (a2 = 1);
            break;
          }
        }
        return a2;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a2 = i, h3;
        do
          this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), h3 = a2.bitLength();
        while (h3 > this.n);
        var s3 = h3 < this.n ? -1 : a2.ucmp(this.p);
        return s3 === 0 ? (a2.words[0] = 0, a2.length = 1) : s3 > 0 ? a2.isub(this.p) : a2.strip !== undefined ? a2.strip() : a2._strip(), a2;
      }, ye.prototype.split = function(i, a2) {
        i.iushrn(this.n, 0, a2);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a2) {
        for (var h3 = 4194303, s3 = Math.min(i.length, 9), u3 = 0;u3 < s3; u3++)
          a2.words[u3] = i.words[u3];
        if (a2.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a2.words[a2.length++] = c2 & h3, u3 = 10;u3 < i.length; u3++) {
          var b3 = i.words[u3] | 0;
          i.words[u3 - 10] = (b3 & h3) << 4 | c2 >>> 22, c2 = b3;
        }
        c2 >>>= 22, i.words[u3 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = i.words[h3] | 0;
          a2 += s3 * 977, i.words[h3] = a2 & 67108863, a2 = s3 * 64 + (a2 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a2 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = (i.words[h3] | 0) * 19 + a2, u3 = s3 & 67108863;
          s3 >>>= 26, i.words[h3] = u3, a2 = s3;
        }
        return a2 !== 0 && (i.words[i.length++] = a2), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a2;
        if (i === "k256")
          a2 = new xe;
        else if (i === "p224")
          a2 = new Re;
        else if (i === "p192")
          a2 = new Ee;
        else if (i === "p25519")
          a2 = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a2, a2;
      };
      function P2(v) {
        if (typeof v == "string") {
          var i = f2._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a2) {
        r((i.negative | a2.negative) === 0, "red works only with positives"), r(i.red && i.red === a2.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.add(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.iadd(a2);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.sub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a2) {
        this._verify2(i, a2);
        var h3 = i.isub(a2);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a2) {
        return this._verify1(i), this.imod(i.ushln(a2));
      }, P2.prototype.imul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.imul(a2));
      }, P2.prototype.mul = function(i, a2) {
        return this._verify2(i, a2), this.imod(i.mul(a2));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a2 = this.m.andln(3);
        if (r(a2 % 2 === 1), a2 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s3 = this.m.subn(1), u3 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u3++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f2(1).toRed(this), b3 = c2.redNeg(), l2 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l2).cmp(b3) !== 0; )
          n.redIAdd(b3);
        for (var d2 = this.pow(n, s3), w = this.pow(i, s3.addn(1).iushrn(1)), g3 = this.pow(i, s3), _4 = u3;g3.cmp(c2) !== 0; ) {
          for (var A2 = g3, R2 = 0;A2.cmp(c2) !== 0; R2++)
            A2 = A2.redSqr();
          r(R2 < _4);
          var I3 = this.pow(d2, new f2(1).iushln(_4 - R2 - 1));
          w = w.redMul(I3), d2 = I3.redSqr(), g3 = g3.redMul(d2), _4 = R2;
        }
        return w;
      }, P2.prototype.invm = function(i) {
        var a2 = i._invmp(this.m);
        return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
      }, P2.prototype.pow = function(i, a2) {
        if (a2.isZero())
          return new f2(1).toRed(this);
        if (a2.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s3 = new Array(1 << h3);
        s3[0] = new f2(1).toRed(this), s3[1] = i;
        for (var u3 = 2;u3 < s3.length; u3++)
          s3[u3] = this.mul(s3[u3 - 1], i);
        var c2 = s3[0], b3 = 0, l2 = 0, n = a2.bitLength() % 26;
        for (n === 0 && (n = 26), u3 = a2.length - 1;u3 >= 0; u3--) {
          for (var d2 = a2.words[u3], w = n - 1;w >= 0; w--) {
            var g3 = d2 >> w & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g3 === 0 && b3 === 0) {
              l2 = 0;
              continue;
            }
            b3 <<= 1, b3 |= g3, l2++, !(l2 !== h3 && (u3 !== 0 || w !== 0)) && (c2 = this.mul(c2, s3[b3]), l2 = 0, b3 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a2 = i.umod(this.m);
        return a2 === i ? a2.clone() : a2;
      }, P2.prototype.convertFrom = function(i) {
        var a2 = i.clone();
        return a2.red = null, a2;
      }, f2.mont = function(i) {
        return new Se(i);
      };
      function Se(v) {
        P2.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P2), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a2 = this.imod(i.mul(this.rinv));
        return a2.red = null, a2;
      }, Se.prototype.imul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a2), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.mul = function(i, a2) {
        if (i.isZero() || a2.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a2), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u3 = h3.isub(s3).iushrn(this.shift), c2 = u3;
        return u3.cmp(this.m) >= 0 ? c2 = u3.isub(this.m) : u3.cmpn(0) < 0 && (c2 = u3.iadd(this.m)), c2._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a2 = this.imod(i._invmp(this.m).mul(this.r2));
        return a2._forceRed(this);
      };
    })(typeof Sd > "u" || Sd, F3);
  });
  Ed = T2((xL, z3) => {
    var U3 = w0(), wq = Te().Buffer;
    function Mq(t, e) {
      return wq.from(t.toRed(U3.mont(e.modulus)).redPow(new U3(e.publicExponent)).fromRed().toArray());
    }
    z3.exports = Mq;
  });
  j3 = T2((SL, K3) => {
    var _q = Ha(), Ad = on(), xq = bf(), H3 = _d(), W3 = xd(), Rd = w0(), Sq = Ed(), Eq = Ks(), Kr = Te().Buffer;
    K3.exports = function(e, r, o) {
      var f2;
      e.padding ? f2 = e.padding : o ? f2 = 1 : f2 = 4;
      var p2 = _q(e), m2;
      if (f2 === 4)
        m2 = Aq(p2, r);
      else if (f2 === 1)
        m2 = Rq(p2, r, o);
      else if (f2 === 3) {
        if (m2 = new Rd(r), m2.cmp(p2.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      return o ? Eq(m2, p2) : Sq(m2, p2);
    };
    function Aq(t, e) {
      var r = t.modulus.byteLength(), o = e.length, f2 = xq("sha1").update(Kr.alloc(0)).digest(), p2 = f2.length, m2 = 2 * p2;
      if (o > r - m2 - 2)
        throw new Error("message too long");
      var y3 = Kr.alloc(r - o - m2 - 2), M2 = r - p2 - 1, x3 = Ad(p2), S2 = W3(Kr.concat([f2, y3, Kr.alloc(1, 1), e], M2), H3(x3, M2)), E3 = W3(x3, H3(S2, p2));
      return new Rd(Kr.concat([Kr.alloc(1), E3, S2], r));
    }
    function Rq(t, e, r) {
      var o = e.length, f2 = t.modulus.byteLength();
      if (o > f2 - 11)
        throw new Error("message too long");
      var p2;
      return r ? p2 = Kr.alloc(f2 - o - 3, 255) : p2 = Bq(f2 - o - 3), new Rd(Kr.concat([Kr.from([0, r ? 1 : 2]), p2, Kr.alloc(1), e], f2));
    }
    function Bq(t) {
      for (var e = Kr.allocUnsafe(t), r = 0, o = Ad(t * 2), f2 = 0, p2;r < t; )
        f2 === o.length && (o = Ad(t * 2), f2 = 0), p2 = o[f2++], p2 && (e[r++] = p2);
      return e;
    }
  });
  Y3 = T2((EL, G3) => {
    var qq = Ha(), Z3 = _d(), V3 = xd(), $3 = w0(), Iq = Ks(), Tq = bf(), kq = Ed(), Za = Te().Buffer;
    G3.exports = function(e, r, o) {
      var f2;
      e.padding ? f2 = e.padding : o ? f2 = 1 : f2 = 4;
      var p2 = qq(e), m2 = p2.modulus.byteLength();
      if (r.length > m2 || new $3(r).cmp(p2.modulus) >= 0)
        throw new Error("decryption error");
      var y3;
      o ? y3 = kq(new $3(r), p2) : y3 = Iq(r, p2);
      var M2 = Za.alloc(m2 - y3.length);
      if (y3 = Za.concat([M2, y3], m2), f2 === 4)
        return Lq(p2, y3);
      if (f2 === 1)
        return Nq(p2, y3, o);
      if (f2 === 3)
        return y3;
      throw new Error("unknown padding");
    };
    function Lq(t, e) {
      var r = t.modulus.byteLength(), o = Tq("sha1").update(Za.alloc(0)).digest(), f2 = o.length;
      if (e[0] !== 0)
        throw new Error("decryption error");
      var p2 = e.slice(1, f2 + 1), m2 = e.slice(f2 + 1), y3 = V3(p2, Z3(m2, f2)), M2 = V3(m2, Z3(y3, r - f2 - 1));
      if (Dq(o, M2.slice(0, f2)))
        throw new Error("decryption error");
      for (var x3 = f2;M2[x3] === 0; )
        x3++;
      if (M2[x3++] !== 1)
        throw new Error("decryption error");
      return M2.slice(x3);
    }
    function Nq(t, e, r) {
      for (var o = e.slice(0, 2), f2 = 2, p2 = 0;e[f2++] !== 0; )
        if (f2 >= e.length) {
          p2++;
          break;
        }
      var m2 = e.slice(2, f2 - 1);
      if ((o.toString("hex") !== "0002" && !r || o.toString("hex") !== "0001" && r) && p2++, m2.length < 8 && p2++, p2)
        throw new Error("decryption error");
      return e.slice(f2);
    }
    function Dq(t, e) {
      t = Za.from(t), e = Za.from(e);
      var r = 0, o = t.length;
      t.length !== e.length && (r++, o = Math.min(t.length, e.length));
      for (var f2 = -1;++f2 < o; )
        r += t[f2] ^ e[f2];
      return r;
    }
  });
  X3 = T2((Vn) => {
    Vn.publicEncrypt = j3();
    Vn.privateDecrypt = Y3();
    Vn.privateEncrypt = function(e, r) {
      return Vn.publicEncrypt(e, r, true);
    };
    Vn.publicDecrypt = function(e, r) {
      return Vn.privateDecrypt(e, r, true);
    };
  });
  ow = T2((Va) => {
    function J3() {
      throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var ew = Te(), Q3 = on(), tw = ew.Buffer, rw = ew.kMaxLength, Bd = global.crypto || global.msCrypto, iw = Math.pow(2, 32) - 1;
    function nw(t, e) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("offset must be a number");
      if (t > iw || t < 0)
        throw new TypeError("offset must be a uint32");
      if (t > rw || t > e)
        throw new RangeError("offset out of range");
    }
    function fw(t, e, r) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("size must be a number");
      if (t > iw || t < 0)
        throw new TypeError("size must be a uint32");
      if (t + e > r || t > rw)
        throw new RangeError("buffer too small");
    }
    Bd && Bd.getRandomValues ? (Va.randomFill = Pq, Va.randomFillSync = Cq) : (Va.randomFill = J3, Va.randomFillSync = J3);
    function Pq(t, e, r, o) {
      if (!tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof e == "function")
        o = e, e = 0, r = t.length;
      else if (typeof r == "function")
        o = r, r = t.length - e;
      else if (typeof o != "function")
        throw new TypeError('"cb" argument must be a function');
      return nw(e, t.length), fw(r, e, t.length), aw(t, e, r, o);
    }
    function aw(t, e, r, o) {
      if (true) {
        var f2 = t.buffer, p2 = new Uint8Array(f2, e, r);
        if (Bd.getRandomValues(p2), o) {
          process.nextTick(function() {
            o(null, t);
          });
          return;
        }
        return t;
      }
      if (o) {
        Q3(r, function(y3, M2) {
          if (y3)
            return o(y3);
          M2.copy(t, e), o(null, t);
        });
        return;
      }
      var m2 = Q3(r);
      return m2.copy(t, e), t;
    }
    function Cq(t, e, r) {
      if (typeof e > "u" && (e = 0), !tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return nw(e, t.length), r === undefined && (r = t.length - e), fw(r, e, t.length), aw(t, e, r);
    }
  });
  qd = T2((ke) => {
    ke.randomBytes = ke.rng = ke.pseudoRandomBytes = ke.prng = on();
    ke.createHash = ke.Hash = bf();
    ke.createHmac = ke.Hmac = wu();
    var Oq = Eb(), Fq = Object.keys(Oq), Uq = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Fq);
    ke.getHashes = function() {
      return Uq;
    };
    var sw = Iu();
    ke.pbkdf2 = sw.pbkdf2;
    ke.pbkdf2Sync = sw.pbkdf2Sync;
    var ui = Vm();
    ke.Cipher = ui.Cipher;
    ke.createCipher = ui.createCipher;
    ke.Cipheriv = ui.Cipheriv;
    ke.createCipheriv = ui.createCipheriv;
    ke.Decipher = ui.Decipher;
    ke.createDecipher = ui.createDecipher;
    ke.Decipheriv = ui.Decipheriv;
    ke.createDecipheriv = ui.createDecipheriv;
    ke.getCiphers = ui.getCiphers;
    ke.listCiphers = ui.listCiphers;
    var $a = hg();
    ke.DiffieHellmanGroup = $a.DiffieHellmanGroup;
    ke.createDiffieHellmanGroup = $a.createDiffieHellmanGroup;
    ke.getDiffieHellman = $a.getDiffieHellman;
    ke.createDiffieHellman = $a.createDiffieHellman;
    ke.DiffieHellman = $a.DiffieHellman;
    var M0 = k3();
    ke.createSign = M0.createSign;
    ke.Sign = M0.Sign;
    ke.createVerify = M0.createVerify;
    ke.Verify = M0.Verify;
    ke.createECDH = P3();
    var _0 = X3();
    ke.publicEncrypt = _0.publicEncrypt;
    ke.privateEncrypt = _0.privateEncrypt;
    ke.publicDecrypt = _0.publicDecrypt;
    ke.privateDecrypt = _0.privateDecrypt;
    var hw = ow();
    ke.randomFill = hw.randomFill;
    ke.randomFillSync = hw.randomFillSync;
    ke.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
    };
    ke.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  Xt = {};
  Ja(Xt, { DEFAULT_ENCODING: () => Ga, default: () => Wq, getCurves: () => dw, getRandomValues: () => uw, randomUUID: () => lw, scrypt: () => Td, scryptSync: () => Id, timingSafeEqual: () => x0, webcrypto: () => cw });
  ot(Xt, rn(qd()));
  zq = rn(qd());
  Hq = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  x0 = "timingSafeEqual" in crypto ? (t, e) => {
    let { byteLength: r } = t, { byteLength: o } = e;
    if (typeof r != "number" || typeof o != "number")
      throw new TypeError("Input must be an array buffer view");
    if (r !== o)
      throw new RangeError("Input buffers must have the same length");
    return crypto.timingSafeEqual(t, e);
  } : undefined;
  Id = "scryptSync" in crypto ? (t, e, r, o) => {
    let f2 = crypto.scryptSync(t, e, r, o);
    return Ga !== "buffer" ? new Buffer(f2).toString(Ga) : new Buffer(f2);
  } : undefined;
  Td = "scryptSync" in crypto ? function(t, e, r, o, f2) {
    if (typeof o == "function" && (f2 = o, o = undefined), typeof f2 != "function") {
      var p2 = new TypeError("callback must be a function");
      throw p2.code = "ERR_INVALID_CALLBACK", p2;
    }
    try {
      let m2 = crypto.scryptSync(t, e, r, o);
      process.nextTick(f2, null, Ga !== "buffer" ? new Buffer(m2).toString(Ga) : new Buffer(m2));
    } catch (m2) {
      throw m2;
    }
  } : undefined;
  x0 && (Object.defineProperty(x0, "name", { value: "::bunternal::" }), Object.defineProperty(Td, "name", { value: "::bunternal::" }), Object.defineProperty(Id, "name", { value: "::bunternal::" }));
  cw = crypto;
  Wq = { ...zq, getRandomValues: uw, randomUUID: lw, timingSafeEqual: x0, scryptSync: Id, scrypt: Td, webcrypto: cw, getCurves: dw };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// ../../../../../../../../../bun-vfs$$/node_modules/events/index.js
var exports_events = {};
__export(exports_events, {
  prototype: () => P2,
  once: () => M2,
  default: () => A2,
  EventEmitter: () => o
});
function x3(t) {
  console && console.warn && console.warn(t);
}
function o() {
  o.init.call(this);
}
function v(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
function m2(t) {
  return t._maxListeners === undefined ? o.defaultMaxListeners : t._maxListeners;
}
function y3(t, e, n, r) {
  var i, f2, s3;
  if (v(n), f2 = t._events, f2 === undefined ? (f2 = t._events = Object.create(null), t._eventsCount = 0) : (f2.newListener !== undefined && (t.emit("newListener", e, n.listener ? n.listener : n), f2 = t._events), s3 = f2[e]), s3 === undefined)
    s3 = f2[e] = n, ++t._eventsCount;
  else if (typeof s3 == "function" ? s3 = f2[e] = r ? [n, s3] : [s3, n] : r ? s3.unshift(n) : s3.push(n), i = m2(t), i > 0 && s3.length > i && !s3.warned) {
    s3.warned = true;
    var u3 = new Error("Possible EventEmitter memory leak detected. " + s3.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u3.name = "MaxListenersExceededWarning", u3.emitter = t, u3.type = e, u3.count = s3.length, x3(u3);
  }
  return t;
}
function C() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function g3(t, e, n) {
  var r = { fired: false, wrapFn: undefined, target: t, type: e, listener: n }, i = C.bind(r);
  return i.listener = n, r.wrapFn = i, i;
}
function _4(t, e, n) {
  var r = t._events;
  if (r === undefined)
    return [];
  var i = r[e];
  return i === undefined ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? R2(i) : b3(i, i.length);
}
function w(t) {
  var e = this._events;
  if (e !== undefined) {
    var n = e[t];
    if (typeof n == "function")
      return 1;
    if (n !== undefined)
      return n.length;
  }
  return 0;
}
function b3(t, e) {
  for (var n = new Array(e), r = 0;r < e; ++r)
    n[r] = t[r];
  return n;
}
function j4(t, e) {
  for (;e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function R2(t) {
  for (var e = new Array(t.length), n = 0;n < e.length; ++n)
    e[n] = t[n].listener || t[n];
  return e;
}
function M2(t, e) {
  return new Promise(function(n, r) {
    function i(s3) {
      t.removeListener(e, f2), r(s3);
    }
    function f2() {
      typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
    }
    E3(t, e, f2, { once: true }), e !== "error" && N4(t, i, { once: true });
  });
}
function N4(t, e, n) {
  typeof t.on == "function" && E3(t, "error", e, n);
}
function E3(t, e, n, r) {
  if (typeof t.on == "function")
    r.once ? t.once(e, n) : t.on(e, n);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(f2) {
      r.once && t.removeEventListener(e, i), n(f2);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var a2, d2, l2, L3, h3 = 10, A2, P2;
var init_events = __esm(() => {
  a2 = typeof Reflect == "object" ? Reflect : null;
  d2 = a2 && typeof a2.apply == "function" ? a2.apply : function(e, n, r) {
    return Function.prototype.apply.call(e, n, r);
  };
  a2 && typeof a2.ownKeys == "function" ? l2 = a2.ownKeys : Object.getOwnPropertySymbols ? l2 = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : l2 = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  L3 = Number.isNaN || function(e) {
    return e !== e;
  };
  o.EventEmitter = o;
  o.prototype._events = undefined;
  o.prototype._eventsCount = 0;
  o.prototype._maxListeners = undefined;
  Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
    return h3;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || L3(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    h3 = t;
  } });
  o.init = function() {
    (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
  };
  o.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || L3(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  o.prototype.getMaxListeners = function() {
    return m2(this);
  };
  o.prototype.emit = function(e) {
    for (var n = [], r = 1;r < arguments.length; r++)
      n.push(arguments[r]);
    var i = e === "error", f2 = this._events;
    if (f2 !== undefined)
      i = i && f2.error === undefined;
    else if (!i)
      return false;
    if (i) {
      var s3;
      if (n.length > 0 && (s3 = n[0]), s3 instanceof Error)
        throw s3;
      var u3 = new Error("Unhandled error." + (s3 ? " (" + s3.message + ")" : ""));
      throw u3.context = s3, u3;
    }
    var c2 = f2[e];
    if (c2 === undefined)
      return false;
    if (typeof c2 == "function")
      d2(c2, this, n);
    else
      for (var p2 = c2.length, O3 = b3(c2, p2), r = 0;r < p2; ++r)
        d2(O3[r], this, n);
    return true;
  };
  o.prototype.addListener = function(e, n) {
    return y3(this, e, n, false);
  };
  o.prototype.on = o.prototype.addListener;
  o.prototype.prependListener = function(e, n) {
    return y3(this, e, n, true);
  };
  o.prototype.once = function(e, n) {
    return v(n), this.on(e, g3(this, e, n)), this;
  };
  o.prototype.prependOnceListener = function(e, n) {
    return v(n), this.prependListener(e, g3(this, e, n)), this;
  };
  o.prototype.removeListener = function(e, n) {
    var r, i, f2, s3, u3;
    if (v(n), i = this._events, i === undefined)
      return this;
    if (r = i[e], r === undefined)
      return this;
    if (r === n || r.listener === n)
      --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
    else if (typeof r != "function") {
      for (f2 = -1, s3 = r.length - 1;s3 >= 0; s3--)
        if (r[s3] === n || r[s3].listener === n) {
          u3 = r[s3].listener, f2 = s3;
          break;
        }
      if (f2 < 0)
        return this;
      f2 === 0 ? r.shift() : j4(r, f2), r.length === 1 && (i[e] = r[0]), i.removeListener !== undefined && this.emit("removeListener", e, u3 || n);
    }
    return this;
  };
  o.prototype.off = o.prototype.removeListener;
  o.prototype.removeAllListeners = function(e) {
    var n, r, i;
    if (r = this._events, r === undefined)
      return this;
    if (r.removeListener === undefined)
      return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
    if (arguments.length === 0) {
      var f2 = Object.keys(r), s3;
      for (i = 0;i < f2.length; ++i)
        s3 = f2[i], s3 !== "removeListener" && this.removeAllListeners(s3);
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if (n = r[e], typeof n == "function")
      this.removeListener(e, n);
    else if (n !== undefined)
      for (i = n.length - 1;i >= 0; i--)
        this.removeListener(e, n[i]);
    return this;
  };
  o.prototype.listeners = function(e) {
    return _4(this, e, true);
  };
  o.prototype.rawListeners = function(e) {
    return _4(this, e, false);
  };
  o.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : w.call(t, e);
  };
  o.prototype.listenerCount = w;
  o.prototype.eventNames = function() {
    return this._eventsCount > 0 ? l2(this._events) : [];
  };
  A2 = o;
  P2 = o.prototype;
});

// ../../../../../../../../../bun-vfs$$/node_modules/util/index.js
var exports_util = {};
__export(exports_util, {
  default: () => so,
  TextEncoder: () => st,
  TextDecoder: () => ct
});
var pt, dr, lt, gt, dt, bt, p2 = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports), At = (r, e) => {
  for (var t in e)
    dr(r, t, { get: e[t], enumerable: true });
}, gr = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o2 of gt(e))
      !bt.call(r, o2) && o2 !== t && dr(r, o2, { get: () => e[o2], enumerable: !(n = lt(e, o2)) || n.enumerable });
  return r;
}, F = (r, e, t) => (gr(r, e, "default"), t && gr(t, e, "default")), mt = (r, e, t) => (t = r != null ? pt(dt(r)) : {}, gr(e || !r || !r.__esModule ? dr(t, "default", { value: r, enumerable: true }) : t, r)), br, N6, Zr, Kr, V3, re, H2, ce, Y2, Ae, Se, Pe, Fr, Br, Ur, Rr, qe, rt, tt, nt, yt, E4, st, ct, so;
var init_util = __esm(() => {
  pt = Object.create;
  dr = Object.defineProperty;
  lt = Object.getOwnPropertyDescriptor;
  gt = Object.getOwnPropertyNames;
  dt = Object.getPrototypeOf;
  bt = Object.prototype.hasOwnProperty;
  br = p2((po2, Vr) => {
    Vr.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var e = {}, t = Symbol("test"), n = Object(t);
      if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
        return false;
      var o2 = 42;
      e[t] = o2;
      for (t in e)
        return false;
      if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
        return false;
      var i = Object.getOwnPropertySymbols(e);
      if (i.length !== 1 || i[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a3 = Object.getOwnPropertyDescriptor(e, t);
        if (a3.value !== o2 || a3.enumerable !== true)
          return false;
      }
      return true;
    };
  });
  N6 = p2((lo, Jr) => {
    var ht = br();
    Jr.exports = function() {
      return ht() && !!Symbol.toStringTag;
    };
  });
  Zr = p2((go, Hr) => {
    var Lr = typeof Symbol < "u" && Symbol, St = br();
    Hr.exports = function() {
      return typeof Lr != "function" || typeof Symbol != "function" || typeof Lr("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : St();
    };
  });
  Kr = p2((bo, Yr) => {
    var vt = "Function.prototype.bind called on incompatible ", Ar = Array.prototype.slice, Ot = Object.prototype.toString, jt = "[object Function]";
    Yr.exports = function(e) {
      var t = this;
      if (typeof t != "function" || Ot.call(t) !== jt)
        throw new TypeError(vt + t);
      for (var n = Ar.call(arguments, 1), o2, i = function() {
        if (this instanceof o2) {
          var g4 = t.apply(this, n.concat(Ar.call(arguments)));
          return Object(g4) === g4 ? g4 : this;
        } else
          return t.apply(e, n.concat(Ar.call(arguments)));
      }, a3 = Math.max(0, t.length - n.length), f2 = [], c2 = 0;c2 < a3; c2++)
        f2.push("$" + c2);
      if (o2 = Function("binder", "return function (" + f2.join(",") + "){ return binder.apply(this,arguments); }")(i), t.prototype) {
        var l3 = function() {
        };
        l3.prototype = t.prototype, o2.prototype = new l3, l3.prototype = null;
      }
      return o2;
    };
  });
  V3 = p2((Ao2, Qr2) => {
    var Pt = Kr();
    Qr2.exports = Function.prototype.bind || Pt;
  });
  re = p2((mo, Xr) => {
    var wt = V3();
    Xr.exports = wt.call(Function.call, Object.prototype.hasOwnProperty);
  });
  H2 = p2((ho, ie) => {
    var s3, x4 = SyntaxError, oe = Function, U3 = TypeError, mr = function(r) {
      try {
        return oe('"use strict"; return (' + r + ").constructor;")();
      } catch {
      }
    }, v2 = Object.getOwnPropertyDescriptor;
    if (v2)
      try {
        v2({}, "");
      } catch {
        v2 = null;
      }
    var hr = function() {
      throw new U3;
    }, Et = v2 ? function() {
      try {
        return arguments.callee, hr;
      } catch {
        try {
          return v2(arguments, "callee").get;
        } catch {
          return hr;
        }
      }
    }() : hr, I3 = Zr()(), m4 = Object.getPrototypeOf || function(r) {
      return r.__proto__;
    }, B3 = {}, Tt2 = typeof Uint8Array > "u" ? s3 : m4(Uint8Array), O3 = { "%AggregateError%": typeof AggregateError > "u" ? s3 : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? s3 : ArrayBuffer, "%ArrayIteratorPrototype%": I3 ? m4([][Symbol.iterator]()) : s3, "%AsyncFromSyncIteratorPrototype%": s3, "%AsyncFunction%": B3, "%AsyncGenerator%": B3, "%AsyncGeneratorFunction%": B3, "%AsyncIteratorPrototype%": B3, "%Atomics%": typeof Atomics > "u" ? s3 : Atomics, "%BigInt%": typeof BigInt > "u" ? s3 : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? s3 : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? s3 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? s3 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? s3 : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? s3 : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? s3 : FinalizationRegistry, "%Function%": oe, "%GeneratorFunction%": B3, "%Int8Array%": typeof Int8Array > "u" ? s3 : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? s3 : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? s3 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": I3 ? m4(m4([][Symbol.iterator]())) : s3, "%JSON%": typeof JSON == "object" ? JSON : s3, "%Map%": typeof Map > "u" ? s3 : Map, "%MapIteratorPrototype%": typeof Map > "u" || !I3 ? s3 : m4(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? s3 : Promise, "%Proxy%": typeof Proxy > "u" ? s3 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? s3 : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? s3 : Set, "%SetIteratorPrototype%": typeof Set > "u" || !I3 ? s3 : m4(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? s3 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": I3 ? m4(""[Symbol.iterator]()) : s3, "%Symbol%": I3 ? Symbol : s3, "%SyntaxError%": x4, "%ThrowTypeError%": Et, "%TypedArray%": Tt2, "%TypeError%": U3, "%Uint8Array%": typeof Uint8Array > "u" ? s3 : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? s3 : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? s3 : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? s3 : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? s3 : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? s3 : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? s3 : WeakSet };
    try {
      null.error;
    } catch (r) {
      ee = m4(m4(r)), O3["%Error.prototype%"] = ee;
    }
    var ee, Ft = function r(e) {
      var t;
      if (e === "%AsyncFunction%")
        t = mr("async function () {}");
      else if (e === "%GeneratorFunction%")
        t = mr("function* () {}");
      else if (e === "%AsyncGeneratorFunction%")
        t = mr("async function* () {}");
      else if (e === "%AsyncGenerator%") {
        var n = r("%AsyncGeneratorFunction%");
        n && (t = n.prototype);
      } else if (e === "%AsyncIteratorPrototype%") {
        var o2 = r("%AsyncGenerator%");
        o2 && (t = m4(o2.prototype));
      }
      return O3[e] = t, t;
    }, te = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, C2 = V3(), J2 = re(), It = C2.call(Function.call, Array.prototype.concat), Bt = C2.call(Function.apply, Array.prototype.splice), ne = C2.call(Function.call, String.prototype.replace), L4 = C2.call(Function.call, String.prototype.slice), Ut2 = C2.call(Function.call, RegExp.prototype.exec), xt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Dt = /\\(\\)?/g, Rt = function(e) {
      var t = L4(e, 0, 1), n = L4(e, -1);
      if (t === "%" && n !== "%")
        throw new x4("invalid intrinsic syntax, expected closing `%`");
      if (n === "%" && t !== "%")
        throw new x4("invalid intrinsic syntax, expected opening `%`");
      var o2 = [];
      return ne(e, xt, function(i, a3, f2, c2) {
        o2[o2.length] = f2 ? ne(c2, Dt, "$1") : a3 || i;
      }), o2;
    }, kt = function(e, t) {
      var n = e, o2;
      if (J2(te, n) && (o2 = te[n], n = "%" + o2[0] + "%"), J2(O3, n)) {
        var i = O3[n];
        if (i === B3 && (i = Ft(n)), typeof i > "u" && !t)
          throw new U3("intrinsic " + e + " exists, but is not available. Please file an issue!");
        return { alias: o2, name: n, value: i };
      }
      throw new x4("intrinsic " + e + " does not exist!");
    };
    ie.exports = function(e, t) {
      if (typeof e != "string" || e.length === 0)
        throw new U3("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof t != "boolean")
        throw new U3('"allowMissing" argument must be a boolean');
      if (Ut2(/^%?[^%]*%?$/, e) === null)
        throw new x4("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var n = Rt(e), o2 = n.length > 0 ? n[0] : "", i = kt("%" + o2 + "%", t), a3 = i.name, f2 = i.value, c2 = false, l3 = i.alias;
      l3 && (o2 = l3[0], Bt(n, It([0, 1], l3)));
      for (var g4 = 1, S2 = true;g4 < n.length; g4 += 1) {
        var d4 = n[g4], T3 = L4(d4, 0, 1), _5 = L4(d4, -1);
        if ((T3 === '"' || T3 === "'" || T3 === "`" || _5 === '"' || _5 === "'" || _5 === "`") && T3 !== _5)
          throw new x4("property names with quotes must have matching quotes");
        if ((d4 === "constructor" || !S2) && (c2 = true), o2 += "." + d4, a3 = "%" + o2 + "%", J2(O3, a3))
          f2 = O3[a3];
        else if (f2 != null) {
          if (!(d4 in f2)) {
            if (!t)
              throw new U3("base intrinsic for " + e + " exists, but the property is not available.");
            return;
          }
          if (v2 && g4 + 1 >= n.length) {
            var z = v2(f2, d4);
            S2 = !!z, S2 && "get" in z && !("originalValue" in z.get) ? f2 = z.get : f2 = f2[d4];
          } else
            S2 = J2(f2, d4), f2 = f2[d4];
          S2 && !c2 && (O3[a3] = f2);
        }
      }
      return f2;
    };
  });
  ce = p2((So, Z3) => {
    var Sr = V3(), D2 = H2(), ue = D2("%Function.prototype.apply%"), ye = D2("%Function.prototype.call%"), se = D2("%Reflect.apply%", true) || Sr.call(ye, ue), ae = D2("%Object.getOwnPropertyDescriptor%", true), j5 = D2("%Object.defineProperty%", true), Mt = D2("%Math.max%");
    if (j5)
      try {
        j5({}, "a", { value: 1 });
      } catch {
        j5 = null;
      }
    Z3.exports = function(e) {
      var t = se(Sr, ye, arguments);
      if (ae && j5) {
        var n = ae(t, "length");
        n.configurable && j5(t, "length", { value: 1 + Mt(0, e.length - (arguments.length - 1)) });
      }
      return t;
    };
    var fe = function() {
      return se(Sr, ue, arguments);
    };
    j5 ? j5(Z3.exports, "apply", { value: fe }) : Z3.exports.apply = fe;
  });
  Y2 = p2((vo2, ge) => {
    var pe = H2(), le = ce(), Nt = le(pe("String.prototype.indexOf"));
    ge.exports = function(e, t) {
      var n = pe(e, !!t);
      return typeof n == "function" && Nt(e, ".prototype.") > -1 ? le(n) : n;
    };
  });
  Ae = p2((Oo, be) => {
    var Ct = N6()(), $t = Y2(), vr = $t("Object.prototype.toString"), K2 = function(e) {
      return Ct && e && typeof e == "object" && Symbol.toStringTag in e ? false : vr(e) === "[object Arguments]";
    }, de = function(e) {
      return K2(e) ? true : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && vr(e) !== "[object Array]" && vr(e.callee) === "[object Function]";
    }, qt = function() {
      return K2(arguments);
    }();
    K2.isLegacyArguments = de;
    be.exports = qt ? K2 : de;
  });
  Se = p2((jo, he) => {
    var Gt = Object.prototype.toString, Wt = Function.prototype.toString, _t = /^\s*(?:function)?\*/, me = N6()(), Or = Object.getPrototypeOf, zt = function() {
      if (!me)
        return false;
      try {
        return Function("return function*() {}")();
      } catch {
      }
    }, jr;
    he.exports = function(e) {
      if (typeof e != "function")
        return false;
      if (_t.test(Wt.call(e)))
        return true;
      if (!me) {
        var t = Gt.call(e);
        return t === "[object GeneratorFunction]";
      }
      if (!Or)
        return false;
      if (typeof jr > "u") {
        var n = zt();
        jr = n ? Or(n) : false;
      }
      return Or(e) === jr;
    };
  });
  Pe = p2((Po, je) => {
    var Oe = Function.prototype.toString, R3 = typeof Reflect == "object" && Reflect !== null && Reflect.apply, wr, Q3;
    if (typeof R3 == "function" && typeof Object.defineProperty == "function")
      try {
        wr = Object.defineProperty({}, "length", { get: function() {
          throw Q3;
        } }), Q3 = {}, R3(function() {
          throw 42;
        }, null, wr);
      } catch (r) {
        r !== Q3 && (R3 = null);
      }
    else
      R3 = null;
    var Vt = /^\s*class\b/, Er = function(e) {
      try {
        var t = Oe.call(e);
        return Vt.test(t);
      } catch {
        return false;
      }
    }, Pr = function(e) {
      try {
        return Er(e) ? false : (Oe.call(e), true);
      } catch {
        return false;
      }
    }, X4 = Object.prototype.toString, Jt2 = "[object Object]", Lt = "[object Function]", Ht = "[object GeneratorFunction]", Zt = "[object HTMLAllCollection]", Yt = "[object HTML document.all class]", Kt = "[object HTMLCollection]", Qt = typeof Symbol == "function" && !!Symbol.toStringTag, Xt2 = !(0 in [,]), Tr = function() {
      return false;
    };
    typeof document == "object" && (ve = document.all, X4.call(ve) === X4.call(document.all) && (Tr = function(e) {
      if ((Xt2 || !e) && (typeof e > "u" || typeof e == "object"))
        try {
          var t = X4.call(e);
          return (t === Zt || t === Yt || t === Kt || t === Jt2) && e("") == null;
        } catch {
        }
      return false;
    }));
    var ve;
    je.exports = R3 ? function(e) {
      if (Tr(e))
        return true;
      if (!e || typeof e != "function" && typeof e != "object")
        return false;
      try {
        R3(e, null, wr);
      } catch (t) {
        if (t !== Q3)
          return false;
      }
      return !Er(e) && Pr(e);
    } : function(e) {
      if (Tr(e))
        return true;
      if (!e || typeof e != "function" && typeof e != "object")
        return false;
      if (Qt)
        return Pr(e);
      if (Er(e))
        return false;
      var t = X4.call(e);
      return t !== Lt && t !== Ht && !/^\[object HTML/.test(t) ? false : Pr(e);
    };
  });
  Fr = p2((wo, Ee) => {
    var rn2 = Pe(), en = Object.prototype.toString, we = Object.prototype.hasOwnProperty, tn = function(e, t, n) {
      for (var o2 = 0, i = e.length;o2 < i; o2++)
        we.call(e, o2) && (n == null ? t(e[o2], o2, e) : t.call(n, e[o2], o2, e));
    }, nn = function(e, t, n) {
      for (var o2 = 0, i = e.length;o2 < i; o2++)
        n == null ? t(e.charAt(o2), o2, e) : t.call(n, e.charAt(o2), o2, e);
    }, on2 = function(e, t, n) {
      for (var o2 in e)
        we.call(e, o2) && (n == null ? t(e[o2], o2, e) : t.call(n, e[o2], o2, e));
    }, an = function(e, t, n) {
      if (!rn2(t))
        throw new TypeError("iterator must be a function");
      var o2;
      arguments.length >= 3 && (o2 = n), en.call(e) === "[object Array]" ? tn(e, t, o2) : typeof e == "string" ? nn(e, t, o2) : on2(e, t, o2);
    };
    Ee.exports = an;
  });
  Br = p2((Eo, Te2) => {
    var Ir = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], fn = typeof globalThis > "u" ? global : globalThis;
    Te2.exports = function() {
      for (var e = [], t = 0;t < Ir.length; t++)
        typeof fn[Ir[t]] == "function" && (e[e.length] = Ir[t]);
      return e;
    };
  });
  Ur = p2((To, Fe) => {
    var un = H2(), rr = un("%Object.getOwnPropertyDescriptor%", true);
    if (rr)
      try {
        rr([], "length");
      } catch {
        rr = null;
      }
    Fe.exports = rr;
  });
  Rr = p2((Fo, De) => {
    var Ie2 = Fr(), yn2 = Br(), Dr = Y2(), sn2 = Dr("Object.prototype.toString"), Be = N6()(), er = Ur(), cn = typeof globalThis > "u" ? global : globalThis, Ue = yn2(), pn2 = Dr("Array.prototype.indexOf", true) || function(e, t) {
      for (var n = 0;n < e.length; n += 1)
        if (e[n] === t)
          return n;
      return -1;
    }, ln = Dr("String.prototype.slice"), xe = {}, xr = Object.getPrototypeOf;
    Be && er && xr && Ie2(Ue, function(r) {
      var e = new cn[r];
      if (Symbol.toStringTag in e) {
        var t = xr(e), n = er(t, Symbol.toStringTag);
        if (!n) {
          var o2 = xr(t);
          n = er(o2, Symbol.toStringTag);
        }
        xe[r] = n.get;
      }
    });
    var gn = function(e) {
      var t = false;
      return Ie2(xe, function(n, o2) {
        if (!t)
          try {
            t = n.call(e) === o2;
          } catch {
          }
      }), t;
    };
    De.exports = function(e) {
      if (!e || typeof e != "object")
        return false;
      if (!Be || !(Symbol.toStringTag in e)) {
        var t = ln(sn2(e), 8, -1);
        return pn2(Ue, t) > -1;
      }
      return er ? gn(e) : false;
    };
  });
  qe = p2((Io, $e) => {
    var ke = Fr(), dn = Br(), Me = Y2(), kr = Ur(), bn = Me("Object.prototype.toString"), Ne = N6()(), Re = typeof globalThis > "u" ? global : globalThis, An = dn(), mn = Me("String.prototype.slice"), Ce = {}, Mr = Object.getPrototypeOf;
    Ne && kr && Mr && ke(An, function(r) {
      if (typeof Re[r] == "function") {
        var e = new Re[r];
        if (Symbol.toStringTag in e) {
          var t = Mr(e), n = kr(t, Symbol.toStringTag);
          if (!n) {
            var o2 = Mr(t);
            n = kr(o2, Symbol.toStringTag);
          }
          Ce[r] = n.get;
        }
      }
    });
    var hn2 = function(e) {
      var t = false;
      return ke(Ce, function(n, o2) {
        if (!t)
          try {
            var i = n.call(e);
            i === o2 && (t = i);
          } catch {
          }
      }), t;
    }, Sn = Rr();
    $e.exports = function(e) {
      return Sn(e) ? !Ne || !(Symbol.toStringTag in e) ? mn(bn(e), 8, -1) : hn2(e) : false;
    };
  });
  rt = p2((u3) => {
    var vn = Ae(), On = Se(), A4 = qe(), Ge = Rr();
    function k4(r) {
      return r.call.bind(r);
    }
    var We = typeof BigInt < "u", _e = typeof Symbol < "u", b4 = k4(Object.prototype.toString), jn = k4(Number.prototype.valueOf), Pn = k4(String.prototype.valueOf), wn = k4(Boolean.prototype.valueOf);
    We && (ze = k4(BigInt.prototype.valueOf));
    var ze;
    _e && (Ve = k4(Symbol.prototype.valueOf));
    var Ve;
    function q2(r, e) {
      if (typeof r != "object")
        return false;
      try {
        return e(r), true;
      } catch {
        return false;
      }
    }
    u3.isArgumentsObject = vn;
    u3.isGeneratorFunction = On;
    u3.isTypedArray = Ge;
    function En(r) {
      return typeof Promise < "u" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function";
    }
    u3.isPromise = En;
    function Tn(r) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : Ge(r) || Le(r);
    }
    u3.isArrayBufferView = Tn;
    function Fn(r) {
      return A4(r) === "Uint8Array";
    }
    u3.isUint8Array = Fn;
    function In(r) {
      return A4(r) === "Uint8ClampedArray";
    }
    u3.isUint8ClampedArray = In;
    function Bn(r) {
      return A4(r) === "Uint16Array";
    }
    u3.isUint16Array = Bn;
    function Un(r) {
      return A4(r) === "Uint32Array";
    }
    u3.isUint32Array = Un;
    function xn(r) {
      return A4(r) === "Int8Array";
    }
    u3.isInt8Array = xn;
    function Dn(r) {
      return A4(r) === "Int16Array";
    }
    u3.isInt16Array = Dn;
    function Rn(r) {
      return A4(r) === "Int32Array";
    }
    u3.isInt32Array = Rn;
    function kn2(r) {
      return A4(r) === "Float32Array";
    }
    u3.isFloat32Array = kn2;
    function Mn(r) {
      return A4(r) === "Float64Array";
    }
    u3.isFloat64Array = Mn;
    function Nn(r) {
      return A4(r) === "BigInt64Array";
    }
    u3.isBigInt64Array = Nn;
    function Cn(r) {
      return A4(r) === "BigUint64Array";
    }
    u3.isBigUint64Array = Cn;
    function tr(r) {
      return b4(r) === "[object Map]";
    }
    tr.working = typeof Map < "u" && tr(new Map);
    function $n(r) {
      return typeof Map > "u" ? false : tr.working ? tr(r) : r instanceof Map;
    }
    u3.isMap = $n;
    function nr(r) {
      return b4(r) === "[object Set]";
    }
    nr.working = typeof Set < "u" && nr(new Set);
    function qn(r) {
      return typeof Set > "u" ? false : nr.working ? nr(r) : r instanceof Set;
    }
    u3.isSet = qn;
    function or2(r) {
      return b4(r) === "[object WeakMap]";
    }
    or2.working = typeof WeakMap < "u" && or2(new WeakMap);
    function Gn(r) {
      return typeof WeakMap > "u" ? false : or2.working ? or2(r) : r instanceof WeakMap;
    }
    u3.isWeakMap = Gn;
    function Cr2(r) {
      return b4(r) === "[object WeakSet]";
    }
    Cr2.working = typeof WeakSet < "u" && Cr2(new WeakSet);
    function Wn(r) {
      return Cr2(r);
    }
    u3.isWeakSet = Wn;
    function ir(r) {
      return b4(r) === "[object ArrayBuffer]";
    }
    ir.working = typeof ArrayBuffer < "u" && ir(new ArrayBuffer);
    function Je(r) {
      return typeof ArrayBuffer > "u" ? false : ir.working ? ir(r) : r instanceof ArrayBuffer;
    }
    u3.isArrayBuffer = Je;
    function ar2(r) {
      return b4(r) === "[object DataView]";
    }
    ar2.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ar2(new DataView(new ArrayBuffer(1), 0, 1));
    function Le(r) {
      return typeof DataView > "u" ? false : ar2.working ? ar2(r) : r instanceof DataView;
    }
    u3.isDataView = Le;
    var Nr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : undefined;
    function $2(r) {
      return b4(r) === "[object SharedArrayBuffer]";
    }
    function He(r) {
      return typeof Nr > "u" ? false : (typeof $2.working > "u" && ($2.working = $2(new Nr)), $2.working ? $2(r) : r instanceof Nr);
    }
    u3.isSharedArrayBuffer = He;
    function _n(r) {
      return b4(r) === "[object AsyncFunction]";
    }
    u3.isAsyncFunction = _n;
    function zn(r) {
      return b4(r) === "[object Map Iterator]";
    }
    u3.isMapIterator = zn;
    function Vn(r) {
      return b4(r) === "[object Set Iterator]";
    }
    u3.isSetIterator = Vn;
    function Jn(r) {
      return b4(r) === "[object Generator]";
    }
    u3.isGeneratorObject = Jn;
    function Ln2(r) {
      return b4(r) === "[object WebAssembly.Module]";
    }
    u3.isWebAssemblyCompiledModule = Ln2;
    function Ze(r) {
      return q2(r, jn);
    }
    u3.isNumberObject = Ze;
    function Ye(r) {
      return q2(r, Pn);
    }
    u3.isStringObject = Ye;
    function Ke(r) {
      return q2(r, wn);
    }
    u3.isBooleanObject = Ke;
    function Qe(r) {
      return We && q2(r, ze);
    }
    u3.isBigIntObject = Qe;
    function Xe(r) {
      return _e && q2(r, Ve);
    }
    u3.isSymbolObject = Xe;
    function Hn(r) {
      return Ze(r) || Ye(r) || Ke(r) || Qe(r) || Xe(r);
    }
    u3.isBoxedPrimitive = Hn;
    function Zn(r) {
      return typeof Uint8Array < "u" && (Je(r) || He(r));
    }
    u3.isAnyArrayBuffer = Zn;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(r) {
      Object.defineProperty(u3, r, { enumerable: false, value: function() {
        throw new Error(r + " is not supported in userland");
      } });
    });
  });
  tt = p2((Uo, et) => {
    et.exports = function(e) {
      return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
    };
  });
  nt = p2((xo, $r) => {
    typeof Object.create == "function" ? $r.exports = function(e, t) {
      t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : $r.exports = function(e, t) {
      if (t) {
        e.super_ = t;
        var n = function() {
        };
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
      }
    };
  });
  yt = p2((y4) => {
    var ot2 = Object.getOwnPropertyDescriptors || function(e) {
      for (var t = Object.keys(e), n = {}, o2 = 0;o2 < t.length; o2++)
        n[t[o2]] = Object.getOwnPropertyDescriptor(e, t[o2]);
      return n;
    }, Yn = /%[sdj%]/g;
    y4.format = function(r) {
      if (!lr(r)) {
        for (var e = [], t = 0;t < arguments.length; t++)
          e.push(h4(arguments[t]));
        return e.join(" ");
      }
      for (var t = 1, n = arguments, o2 = n.length, i = String(r).replace(Yn, function(f2) {
        if (f2 === "%%")
          return "%";
        if (t >= o2)
          return f2;
        switch (f2) {
          case "%s":
            return String(n[t++]);
          case "%d":
            return Number(n[t++]);
          case "%j":
            try {
              return JSON.stringify(n[t++]);
            } catch {
              return "[Circular]";
            }
          default:
            return f2;
        }
      }), a3 = n[t];t < o2; a3 = n[++t])
        pr2(a3) || !M3(a3) ? i += " " + a3 : i += " " + h4(a3);
      return i;
    };
    y4.deprecate = function(r, e) {
      if (typeof process < "u" && process.noDeprecation === true)
        return r;
      if (typeof process > "u")
        return function() {
          return y4.deprecate(r, e).apply(this, arguments);
        };
      var t = false;
      function n() {
        if (!t) {
          if (process.throwDeprecation)
            throw new Error(e);
          process.traceDeprecation ? console.trace(e) : console.error(e), t = true;
        }
        return r.apply(this, arguments);
      }
      return n;
    };
    var fr = {}, it = /^$/;
    process.env.NODE_DEBUG && (ur2 = process.env.NODE_DEBUG, ur2 = ur2.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), it = new RegExp("^" + ur2 + "$", "i"));
    var ur2;
    y4.debuglog = function(r) {
      if (r = r.toUpperCase(), !fr[r])
        if (it.test(r)) {
          var e = process.pid;
          fr[r] = function() {
            var t = y4.format.apply(y4, arguments);
            console.error("%s %d: %s", r, e, t);
          };
        } else
          fr[r] = function() {
          };
      return fr[r];
    };
    function h4(r, e) {
      var t = { seen: [], stylize: Qn };
      return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), _r(e) ? t.showHidden = e : e && y4._extend(t, e), w2(t.showHidden) && (t.showHidden = false), w2(t.depth) && (t.depth = 2), w2(t.colors) && (t.colors = false), w2(t.customInspect) && (t.customInspect = true), t.colors && (t.stylize = Kn), sr(t, r, t.depth);
    }
    y4.inspect = h4;
    h4.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
    h4.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    function Kn(r, e) {
      var t = h4.styles[e];
      return t ? "\x1B[" + h4.colors[t][0] + "m" + r + "\x1B[" + h4.colors[t][1] + "m" : r;
    }
    function Qn(r, e) {
      return r;
    }
    function Xn(r) {
      var e = {};
      return r.forEach(function(t, n) {
        e[t] = true;
      }), e;
    }
    function sr(r, e, t) {
      if (r.customInspect && e && yr(e.inspect) && e.inspect !== y4.inspect && !(e.constructor && e.constructor.prototype === e)) {
        var n = e.inspect(t, r);
        return lr(n) || (n = sr(r, n, t)), n;
      }
      var o2 = ro(r, e);
      if (o2)
        return o2;
      var i = Object.keys(e), a3 = Xn(i);
      if (r.showHidden && (i = Object.getOwnPropertyNames(e)), W(e) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
        return qr(e);
      if (i.length === 0) {
        if (yr(e)) {
          var f2 = e.name ? ": " + e.name : "";
          return r.stylize("[Function" + f2 + "]", "special");
        }
        if (G2(e))
          return r.stylize(RegExp.prototype.toString.call(e), "regexp");
        if (cr(e))
          return r.stylize(Date.prototype.toString.call(e), "date");
        if (W(e))
          return qr(e);
      }
      var c2 = "", l3 = false, g4 = ["{", "}"];
      if (at(e) && (l3 = true, g4 = ["[", "]"]), yr(e)) {
        var S2 = e.name ? ": " + e.name : "";
        c2 = " [Function" + S2 + "]";
      }
      if (G2(e) && (c2 = " " + RegExp.prototype.toString.call(e)), cr(e) && (c2 = " " + Date.prototype.toUTCString.call(e)), W(e) && (c2 = " " + qr(e)), i.length === 0 && (!l3 || e.length == 0))
        return g4[0] + c2 + g4[1];
      if (t < 0)
        return G2(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
      r.seen.push(e);
      var d4;
      return l3 ? d4 = eo(r, e, t, a3, i) : d4 = i.map(function(T3) {
        return Wr(r, e, t, a3, T3, l3);
      }), r.seen.pop(), to(d4, c2, g4);
    }
    function ro(r, e) {
      if (w2(e))
        return r.stylize("undefined", "undefined");
      if (lr(e)) {
        var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return r.stylize(t, "string");
      }
      if (ft(e))
        return r.stylize("" + e, "number");
      if (_r(e))
        return r.stylize("" + e, "boolean");
      if (pr2(e))
        return r.stylize("null", "null");
    }
    function qr(r) {
      return "[" + Error.prototype.toString.call(r) + "]";
    }
    function eo(r, e, t, n, o2) {
      for (var i = [], a3 = 0, f2 = e.length;a3 < f2; ++a3)
        ut(e, String(a3)) ? i.push(Wr(r, e, t, n, String(a3), true)) : i.push("");
      return o2.forEach(function(c2) {
        c2.match(/^\d+$/) || i.push(Wr(r, e, t, n, c2, true));
      }), i;
    }
    function Wr(r, e, t, n, o2, i) {
      var a3, f2, c2;
      if (c2 = Object.getOwnPropertyDescriptor(e, o2) || { value: e[o2] }, c2.get ? c2.set ? f2 = r.stylize("[Getter/Setter]", "special") : f2 = r.stylize("[Getter]", "special") : c2.set && (f2 = r.stylize("[Setter]", "special")), ut(n, o2) || (a3 = "[" + o2 + "]"), f2 || (r.seen.indexOf(c2.value) < 0 ? (pr2(t) ? f2 = sr(r, c2.value, null) : f2 = sr(r, c2.value, t - 1), f2.indexOf(`
`) > -1 && (i ? f2 = f2.split(`
`).map(function(l3) {
        return "  " + l3;
      }).join(`
`).slice(2) : f2 = `
` + f2.split(`
`).map(function(l3) {
        return "   " + l3;
      }).join(`
`))) : f2 = r.stylize("[Circular]", "special")), w2(a3)) {
        if (i && o2.match(/^\d+$/))
          return f2;
        a3 = JSON.stringify("" + o2), a3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a3 = a3.slice(1, -1), a3 = r.stylize(a3, "name")) : (a3 = a3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a3 = r.stylize(a3, "string"));
      }
      return a3 + ": " + f2;
    }
    function to(r, e, t) {
      var n = 0, o2 = r.reduce(function(i, a3) {
        return n++, a3.indexOf(`
`) >= 0 && n++, i + a3.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return o2 > 60 ? t[0] + (e === "" ? "" : e + `
 `) + " " + r.join(`,
  `) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1];
    }
    y4.types = rt();
    function at(r) {
      return Array.isArray(r);
    }
    y4.isArray = at;
    function _r(r) {
      return typeof r == "boolean";
    }
    y4.isBoolean = _r;
    function pr2(r) {
      return r === null;
    }
    y4.isNull = pr2;
    function no(r) {
      return r == null;
    }
    y4.isNullOrUndefined = no;
    function ft(r) {
      return typeof r == "number";
    }
    y4.isNumber = ft;
    function lr(r) {
      return typeof r == "string";
    }
    y4.isString = lr;
    function oo(r) {
      return typeof r == "symbol";
    }
    y4.isSymbol = oo;
    function w2(r) {
      return r === undefined;
    }
    y4.isUndefined = w2;
    function G2(r) {
      return M3(r) && zr(r) === "[object RegExp]";
    }
    y4.isRegExp = G2;
    y4.types.isRegExp = G2;
    function M3(r) {
      return typeof r == "object" && r !== null;
    }
    y4.isObject = M3;
    function cr(r) {
      return M3(r) && zr(r) === "[object Date]";
    }
    y4.isDate = cr;
    y4.types.isDate = cr;
    function W(r) {
      return M3(r) && (zr(r) === "[object Error]" || r instanceof Error);
    }
    y4.isError = W;
    y4.types.isNativeError = W;
    function yr(r) {
      return typeof r == "function";
    }
    y4.isFunction = yr;
    function io(r) {
      return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r > "u";
    }
    y4.isPrimitive = io;
    y4.isBuffer = tt();
    function zr(r) {
      return Object.prototype.toString.call(r);
    }
    function Gr2(r) {
      return r < 10 ? "0" + r.toString(10) : r.toString(10);
    }
    var ao = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function fo() {
      var r = new Date, e = [Gr2(r.getHours()), Gr2(r.getMinutes()), Gr2(r.getSeconds())].join(":");
      return [r.getDate(), ao[r.getMonth()], e].join(" ");
    }
    y4.log = function() {
      console.log("%s - %s", fo(), y4.format.apply(y4, arguments));
    };
    y4.inherits = nt();
    y4._extend = function(r, e) {
      if (!e || !M3(e))
        return r;
      for (var t = Object.keys(e), n = t.length;n--; )
        r[t[n]] = e[t[n]];
      return r;
    };
    function ut(r, e) {
      return Object.prototype.hasOwnProperty.call(r, e);
    }
    var P4 = typeof Symbol < "u" ? Symbol("util.promisify.custom") : undefined;
    y4.promisify = function(e) {
      if (typeof e != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (P4 && e[P4]) {
        var t = e[P4];
        if (typeof t != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t, P4, { value: t, enumerable: false, writable: false, configurable: true }), t;
      }
      function t() {
        for (var n, o2, i = new Promise(function(c2, l3) {
          n = c2, o2 = l3;
        }), a3 = [], f2 = 0;f2 < arguments.length; f2++)
          a3.push(arguments[f2]);
        a3.push(function(c2, l3) {
          c2 ? o2(c2) : n(l3);
        });
        try {
          e.apply(this, a3);
        } catch (c2) {
          o2(c2);
        }
        return i;
      }
      return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), P4 && Object.defineProperty(t, P4, { value: t, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t, ot2(e));
    };
    y4.promisify.custom = P4;
    function uo(r, e) {
      if (!r) {
        var t = new Error("Promise was rejected with a falsy value");
        t.reason = r, r = t;
      }
      return e(r);
    }
    function yo(r) {
      if (typeof r != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function e() {
        for (var t = [], n = 0;n < arguments.length; n++)
          t.push(arguments[n]);
        var o2 = t.pop();
        if (typeof o2 != "function")
          throw new TypeError("The last argument must be of type Function");
        var i = this, a3 = function() {
          return o2.apply(i, arguments);
        };
        r.apply(this, t).then(function(f2) {
          process.nextTick(a3.bind(null, null, f2));
        }, function(f2) {
          process.nextTick(uo.bind(null, f2, a3));
        });
      }
      return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, ot2(r)), e;
    }
    y4.callbackify = yo;
  });
  E4 = {};
  At(E4, { TextDecoder: () => ct, TextEncoder: () => st, default: () => so });
  F(E4, mt(yt()));
  st = globalThis.TextEncoder;
  ct = globalThis.TextDecoder;
  so = { TextEncoder: st, TextDecoder: ct };
});

// ../../../node_modules/readline/readline.js
var require_readline = __commonJS((exports, module) => {
  var fs = (() => ({}));
  var EventEmitter = (init_events(), __toCommonJS(exports_events)).EventEmitter;
  var util = (init_util(), __toCommonJS(exports_util));
  var readLine = module.exports = function(file, opts) {
    if (!(this instanceof readLine))
      return new readLine(file, opts);
    EventEmitter.call(this);
    opts = opts || {};
    opts.maxLineLength = opts.maxLineLength || 4096;
    opts.retainBuffer = !!opts.retainBuffer;
    var self2 = this, lineBuffer = new Buffer(opts.maxLineLength), lineLength = 0, lineCount = 0, byteCount = 0, emit = function(lineCount2, byteCount2) {
      try {
        var line = lineBuffer.slice(0, lineLength);
        self2.emit("line", opts.retainBuffer ? line : line.toString(), lineCount2, byteCount2);
      } catch (err) {
        self2.emit("error", err);
      } finally {
        lineLength = 0;
      }
    };
    this.input = typeof file === "string" ? fs.createReadStream(file, opts) : file;
    this.input.on("open", function(fd) {
      self2.emit("open", fd);
    }).on("data", function(data) {
      for (var i = 0;i < data.length; i++) {
        if (data[i] == 10 || data[i] == 13) {
          if (data[i] == 10) {
            lineCount++;
            emit(lineCount, byteCount);
          }
        } else {
          lineBuffer[lineLength] = data[i];
          lineLength++;
        }
        byteCount++;
      }
    }).on("error", function(err) {
      self2.emit("error", err);
    }).on("end", function() {
      if (lineLength) {
        lineCount++;
        emit(lineCount, byteCount);
      }
      self2.emit("end");
    }).on("close", function() {
      self2.emit("close");
    });
  };
  util.inherits(readLine, EventEmitter);
});

// ../../../../../../../../../bun-vfs$$/node_modules/stream/index.js
var exports_stream = {};
__export(exports_stream, {
  default: () => Uc
});
var al, tt2, cl2, dl2, hl2, pl, yl2 = (e, t) => () => (e && (t = e(e = 0)), t), E5 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Qr2 = (e, t) => {
  for (var r in t)
    tt2(e, r, { get: t[r], enumerable: true });
}, et = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of dl2(t))
      !pl.call(e, i) && i !== r && tt2(e, i, { get: () => t[i], enumerable: !(n = cl2(t, i)) || n.enumerable });
  return e;
}, ue = (e, t, r) => (et(e, t, "default"), r && et(r, t, "default")), rt2 = (e, t, r) => (r = e != null ? al(hl2(e)) : {}, et(t || !e || !e.__esModule ? tt2(r, "default", { value: e, enumerable: true }) : r, e)), pe = (e) => et(tt2({}, "__esModule", { value: true }), e), tn, rn2, te, I3, V4, ut, C2, He, ir, k4, Gu, se, ae, ce2, di, Se2, Et, xt, At2, Pi, Tt2, Wi, Gi, Er, Ke, Cr2, Mo, J2, qr, $r, Ut2, Jo, Kr2, fl, Jr, Ze, Uc;
var init_stream = __esm(() => {
  al = Object.create;
  tt2 = Object.defineProperty;
  cl2 = Object.getOwnPropertyDescriptor;
  dl2 = Object.getOwnPropertyNames;
  hl2 = Object.getPrototypeOf;
  pl = Object.prototype.hasOwnProperty;
  tn = E5((nt2) => {
    nt2.byteLength = bl2;
    nt2.toByteArray = _l;
    nt2.fromByteArray = ml;
    var G2 = [], P4 = [], wl = typeof Uint8Array < "u" ? Uint8Array : Array, Wt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ye = 0, Zr2 = Wt.length;ye < Zr2; ++ye)
      G2[ye] = Wt[ye], P4[Wt.charCodeAt(ye)] = ye;
    var ye, Zr2;
    P4[45] = 62;
    P4[95] = 63;
    function en(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function bl2(e) {
      var t = en(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function gl(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function _l(e) {
      var t, r = en(e), n = r[0], i = r[1], o2 = new wl(gl(e, n, i)), l3 = 0, u3 = i > 0 ? n - 4 : n, f2;
      for (f2 = 0;f2 < u3; f2 += 4)
        t = P4[e.charCodeAt(f2)] << 18 | P4[e.charCodeAt(f2 + 1)] << 12 | P4[e.charCodeAt(f2 + 2)] << 6 | P4[e.charCodeAt(f2 + 3)], o2[l3++] = t >> 16 & 255, o2[l3++] = t >> 8 & 255, o2[l3++] = t & 255;
      return i === 2 && (t = P4[e.charCodeAt(f2)] << 2 | P4[e.charCodeAt(f2 + 1)] >> 4, o2[l3++] = t & 255), i === 1 && (t = P4[e.charCodeAt(f2)] << 10 | P4[e.charCodeAt(f2 + 1)] << 4 | P4[e.charCodeAt(f2 + 2)] >> 2, o2[l3++] = t >> 8 & 255, o2[l3++] = t & 255), o2;
    }
    function El(e) {
      return G2[e >> 18 & 63] + G2[e >> 12 & 63] + G2[e >> 6 & 63] + G2[e & 63];
    }
    function Sl(e, t, r) {
      for (var n, i = [], o2 = t;o2 < r; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i.push(El(n));
      return i.join("");
    }
    function ml(e) {
      for (var t, r = e.length, n = r % 3, i = [], o2 = 16383, l3 = 0, u3 = r - n;l3 < u3; l3 += o2)
        i.push(Sl(e, l3, l3 + o2 > u3 ? u3 : l3 + o2));
      return n === 1 ? (t = e[r - 1], i.push(G2[t >> 2] + G2[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(G2[t >> 10] + G2[t >> 4 & 63] + G2[t << 2 & 63] + "=")), i.join("");
    }
  });
  rn2 = E5(($t) => {
    $t.read = function(e, t, r, n, i) {
      var o2, l3, u3 = i * 8 - n - 1, f2 = (1 << u3) - 1, s3 = f2 >> 1, d4 = -7, c2 = r ? i - 1 : 0, y4 = r ? -1 : 1, h4 = e[t + c2];
      for (c2 += y4, o2 = h4 & (1 << -d4) - 1, h4 >>= -d4, d4 += u3;d4 > 0; o2 = o2 * 256 + e[t + c2], c2 += y4, d4 -= 8)
        ;
      for (l3 = o2 & (1 << -d4) - 1, o2 >>= -d4, d4 += n;d4 > 0; l3 = l3 * 256 + e[t + c2], c2 += y4, d4 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - s3;
      else {
        if (o2 === f2)
          return l3 ? NaN : (h4 ? -1 : 1) * (1 / 0);
        l3 = l3 + Math.pow(2, n), o2 = o2 - s3;
      }
      return (h4 ? -1 : 1) * l3 * Math.pow(2, o2 - n);
    };
    $t.write = function(e, t, r, n, i, o2) {
      var l3, u3, f2, s3 = o2 * 8 - i - 1, d4 = (1 << s3) - 1, c2 = d4 >> 1, y4 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h4 = n ? 0 : o2 - 1, p4 = n ? 1 : -1, B3 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u3 = isNaN(t) ? 1 : 0, l3 = d4) : (l3 = Math.floor(Math.log(t) / Math.LN2), t * (f2 = Math.pow(2, -l3)) < 1 && (l3--, f2 *= 2), l3 + c2 >= 1 ? t += y4 / f2 : t += y4 * Math.pow(2, 1 - c2), t * f2 >= 2 && (l3++, f2 /= 2), l3 + c2 >= d4 ? (u3 = 0, l3 = d4) : l3 + c2 >= 1 ? (u3 = (t * f2 - 1) * Math.pow(2, i), l3 = l3 + c2) : (u3 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), l3 = 0));i >= 8; e[r + h4] = u3 & 255, h4 += p4, u3 /= 256, i -= 8)
        ;
      for (l3 = l3 << i | u3, s3 += i;s3 > 0; e[r + h4] = l3 & 255, h4 += p4, l3 /= 256, s3 -= 8)
        ;
      e[r + h4 - p4] |= B3 * 128;
    };
  });
  te = E5((Fe) => {
    var jt = tn(), Le = rn2(), nn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Fe.Buffer = a3;
    Fe.SlowBuffer = Bl;
    Fe.INSPECT_MAX_BYTES = 50;
    var it = 2147483647;
    Fe.kMaxLength = it;
    a3.TYPED_ARRAY_SUPPORT = xl();
    !a3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function xl() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a3.prototype, "parent", { enumerable: true, get: function() {
      if (!!a3.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(a3.prototype, "offset", { enumerable: true, get: function() {
      if (!!a3.isBuffer(this))
        return this.byteOffset;
    } });
    function ee(e) {
      if (e > it)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, a3.prototype), t;
    }
    function a3(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return Yt(e);
      }
      return fn(e, t, r);
    }
    a3.poolSize = 8192;
    function fn(e, t, r) {
      if (typeof e == "string")
        return Al(e, t);
      if (ArrayBuffer.isView(e))
        return Il2(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (H3(e, ArrayBuffer) || e && H3(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (H3(e, SharedArrayBuffer) || e && H3(e.buffer, SharedArrayBuffer)))
        return Ht(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return a3.from(n, t, r);
      let i = Tl(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return a3.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    a3.from = function(e, t, r) {
      return fn(e, t, r);
    };
    Object.setPrototypeOf(a3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(a3, Uint8Array);
    function sn2(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function Rl(e, t, r) {
      return sn2(e), e <= 0 ? ee(e) : t !== undefined ? typeof r == "string" ? ee(e).fill(t, r) : ee(e).fill(t) : ee(e);
    }
    a3.alloc = function(e, t, r) {
      return Rl(e, t, r);
    };
    function Yt(e) {
      return sn2(e), ee(e < 0 ? 0 : Kt(e) | 0);
    }
    a3.allocUnsafe = function(e) {
      return Yt(e);
    };
    a3.allocUnsafeSlow = function(e) {
      return Yt(e);
    };
    function Al(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !a3.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = an(e, t) | 0, n = ee(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Gt(e) {
      let t = e.length < 0 ? 0 : Kt(e.length) | 0, r = ee(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function Il2(e) {
      if (H3(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Ht(t.buffer, t.byteOffset, t.byteLength);
      }
      return Gt(e);
    }
    function Ht(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, a3.prototype), n;
    }
    function Tl(e) {
      if (a3.isBuffer(e)) {
        let t = Kt(e.length) | 0, r = ee(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || Xt2(e.length) ? ee(0) : Gt(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Gt(e.data);
    }
    function Kt(e) {
      if (e >= it)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + it.toString(16) + " bytes");
      return e | 0;
    }
    function Bl(e) {
      return +e != e && (e = 0), a3.alloc(+e);
    }
    a3.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== a3.prototype;
    };
    a3.compare = function(t, r) {
      if (H3(t, Uint8Array) && (t = a3.from(t, t.offset, t.byteLength)), H3(r, Uint8Array) && (r = a3.from(r, r.offset, r.byteLength)), !a3.isBuffer(t) || !a3.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o2 = 0, l3 = Math.min(n, i);o2 < l3; ++o2)
        if (t[o2] !== r[o2]) {
          n = t[o2], i = r[o2];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    a3.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    a3.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return a3.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = a3.allocUnsafe(r), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let l3 = t[n];
        if (H3(l3, Uint8Array))
          o2 + l3.length > i.length ? (a3.isBuffer(l3) || (l3 = a3.from(l3)), l3.copy(i, o2)) : Uint8Array.prototype.set.call(i, l3, o2);
        else if (a3.isBuffer(l3))
          l3.copy(i, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += l3.length;
      }
      return i;
    };
    function an(e, t) {
      if (a3.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || H3(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Vt(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return _n(e).length;
          default:
            if (i)
              return n ? -1 : Vt(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    a3.byteLength = an;
    function Ll(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return vl(this, t, r);
          case "utf8":
          case "utf-8":
            return dn(this, t, r);
          case "ascii":
            return kl(this, t, r);
          case "latin1":
          case "binary":
            return Ul(this, t, r);
          case "base64":
            return Dl(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ql(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    a3.prototype._isBuffer = true;
    function we(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    a3.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        we(this, r, r + 1);
      return this;
    };
    a3.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        we(this, r, r + 3), we(this, r + 1, r + 2);
      return this;
    };
    a3.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        we(this, r, r + 7), we(this, r + 1, r + 6), we(this, r + 2, r + 5), we(this, r + 3, r + 4);
      return this;
    };
    a3.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? dn(this, 0, t) : Ll.apply(this, arguments);
    };
    a3.prototype.toLocaleString = a3.prototype.toString;
    a3.prototype.equals = function(t) {
      if (!a3.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : a3.compare(this, t) === 0;
    };
    a3.prototype.inspect = function() {
      let t = "", r = Fe.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    nn && (a3.prototype[nn] = a3.prototype.inspect);
    a3.prototype.compare = function(t, r, n, i, o2) {
      if (H3(t, Uint8Array) && (t = a3.from(t, t.offset, t.byteLength)), !a3.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o2 === undefined && (o2 = this.length), r < 0 || n > t.length || i < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i >= o2 && r >= n)
        return 0;
      if (i >= o2)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let l3 = o2 - i, u3 = n - r, f2 = Math.min(l3, u3), s3 = this.slice(i, o2), d4 = t.slice(r, n);
      for (let c2 = 0;c2 < f2; ++c2)
        if (s3[c2] !== d4[c2]) {
          l3 = s3[c2], u3 = d4[c2];
          break;
        }
      return l3 < u3 ? -1 : u3 < l3 ? 1 : 0;
    };
    function cn(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Xt2(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = a3.from(t, n)), a3.isBuffer(t))
        return t.length === 0 ? -1 : on2(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : on2(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function on2(e, t, r, n, i) {
      let o2 = 1, l3 = e.length, u3 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, l3 /= 2, u3 /= 2, r /= 2;
      }
      function f2(d4, c2) {
        return o2 === 1 ? d4[c2] : d4.readUInt16BE(c2 * o2);
      }
      let s3;
      if (i) {
        let d4 = -1;
        for (s3 = r;s3 < l3; s3++)
          if (f2(e, s3) === f2(t, d4 === -1 ? 0 : s3 - d4)) {
            if (d4 === -1 && (d4 = s3), s3 - d4 + 1 === u3)
              return d4 * o2;
          } else
            d4 !== -1 && (s3 -= s3 - d4), d4 = -1;
      } else
        for (r + u3 > l3 && (r = l3 - u3), s3 = r;s3 >= 0; s3--) {
          let d4 = true;
          for (let c2 = 0;c2 < u3; c2++)
            if (f2(e, s3 + c2) !== f2(t, c2)) {
              d4 = false;
              break;
            }
          if (d4)
            return s3;
        }
      return -1;
    }
    a3.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    a3.prototype.indexOf = function(t, r, n) {
      return cn(this, t, r, n, true);
    };
    a3.prototype.lastIndexOf = function(t, r, n) {
      return cn(this, t, r, n, false);
    };
    function Nl2(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let l3;
      for (l3 = 0;l3 < n; ++l3) {
        let u3 = parseInt(t.substr(l3 * 2, 2), 16);
        if (Xt2(u3))
          return l3;
        e[r + l3] = u3;
      }
      return l3;
    }
    function Fl2(e, t, r, n) {
      return ot2(Vt(t, e.length - r), e, r, n);
    }
    function Ml(e, t, r, n) {
      return ot2(Gl(t), e, r, n);
    }
    function Cl2(e, t, r, n) {
      return ot2(_n(t), e, r, n);
    }
    function Ol(e, t, r, n) {
      return ot2(Hl(t, e.length - r), e, r, n);
    }
    a3.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let l3 = false;
      for (;; )
        switch (i) {
          case "hex":
            return Nl2(this, t, r, n);
          case "utf8":
          case "utf-8":
            return Fl2(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return Ml(this, t, r, n);
          case "base64":
            return Cl2(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ol(this, t, r, n);
          default:
            if (l3)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), l3 = true;
        }
    };
    a3.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Dl(e, t, r) {
      return t === 0 && r === e.length ? jt.fromByteArray(e) : jt.fromByteArray(e.slice(t, r));
    }
    function dn(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o2 = e[i], l3 = null, u3 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i + u3 <= r) {
          let f2, s3, d4, c2;
          switch (u3) {
            case 1:
              o2 < 128 && (l3 = o2);
              break;
            case 2:
              f2 = e[i + 1], (f2 & 192) === 128 && (c2 = (o2 & 31) << 6 | f2 & 63, c2 > 127 && (l3 = c2));
              break;
            case 3:
              f2 = e[i + 1], s3 = e[i + 2], (f2 & 192) === 128 && (s3 & 192) === 128 && (c2 = (o2 & 15) << 12 | (f2 & 63) << 6 | s3 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (l3 = c2));
              break;
            case 4:
              f2 = e[i + 1], s3 = e[i + 2], d4 = e[i + 3], (f2 & 192) === 128 && (s3 & 192) === 128 && (d4 & 192) === 128 && (c2 = (o2 & 15) << 18 | (f2 & 63) << 12 | (s3 & 63) << 6 | d4 & 63, c2 > 65535 && c2 < 1114112 && (l3 = c2));
          }
        }
        l3 === null ? (l3 = 65533, u3 = 1) : l3 > 65535 && (l3 -= 65536, n.push(l3 >>> 10 & 1023 | 55296), l3 = 56320 | l3 & 1023), n.push(l3), i += u3;
      }
      return Pl2(n);
    }
    var ln = 4096;
    function Pl2(e) {
      let t = e.length;
      if (t <= ln)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += ln));
      return r;
    }
    function kl(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function Ul(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function vl(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o2 = t;o2 < r; ++o2)
        i += Vl[e[o2]];
      return i;
    }
    function ql(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i;
    }
    a3.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, a3.prototype), i;
    };
    function F3(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    a3.prototype.readUintLE = a3.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F3(t, r, this.length);
      let i = this[t], o2 = 1, l3 = 0;
      for (;++l3 < r && (o2 *= 256); )
        i += this[t + l3] * o2;
      return i;
    };
    a3.prototype.readUintBE = a3.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F3(t, r, this.length);
      let i = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        i += this[t + --r] * o2;
      return i;
    };
    a3.prototype.readUint8 = a3.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || F3(t, 1, this.length), this[t];
    };
    a3.prototype.readUint16LE = a3.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || F3(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    a3.prototype.readUint16BE = a3.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || F3(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    a3.prototype.readUint32LE = a3.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || F3(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    a3.prototype.readUint32BE = a3.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || F3(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    a3.prototype.readBigUInt64LE = fe(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o2) << BigInt(32));
    });
    a3.prototype.readBigUInt64BE = fe(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o2);
    });
    a3.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F3(t, r, this.length);
      let i = this[t], o2 = 1, l3 = 0;
      for (;++l3 < r && (o2 *= 256); )
        i += this[t + l3] * o2;
      return o2 *= 128, i >= o2 && (i -= Math.pow(2, 8 * r)), i;
    };
    a3.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F3(t, r, this.length);
      let i = r, o2 = 1, l3 = this[t + --i];
      for (;i > 0 && (o2 *= 256); )
        l3 += this[t + --i] * o2;
      return o2 *= 128, l3 >= o2 && (l3 -= Math.pow(2, 8 * r)), l3;
    };
    a3.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || F3(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    a3.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || F3(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    a3.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || F3(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    a3.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || F3(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    a3.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || F3(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    a3.prototype.readBigInt64LE = fe(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    a3.prototype.readBigInt64BE = fe(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    a3.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || F3(t, 4, this.length), Le.read(this, t, true, 23, 4);
    };
    a3.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || F3(t, 4, this.length), Le.read(this, t, false, 23, 4);
    };
    a3.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || F3(t, 8, this.length), Le.read(this, t, true, 52, 8);
    };
    a3.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || F3(t, 8, this.length), Le.read(this, t, false, 52, 8);
    };
    function O3(e, t, r, n, i, o2) {
      if (!a3.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    a3.prototype.writeUintLE = a3.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n) - 1;
        O3(this, t, r, n, u3, 0);
      }
      let o2 = 1, l3 = 0;
      for (this[r] = t & 255;++l3 < n && (o2 *= 256); )
        this[r + l3] = t / o2 & 255;
      return r + n;
    };
    a3.prototype.writeUintBE = a3.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let u3 = Math.pow(2, 8 * n) - 1;
        O3(this, t, r, n, u3, 0);
      }
      let o2 = n - 1, l3 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (l3 *= 256); )
        this[r + o2] = t / l3 & 255;
      return r + n;
    };
    a3.prototype.writeUint8 = a3.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    a3.prototype.writeUint16LE = a3.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    a3.prototype.writeUint16BE = a3.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    a3.prototype.writeUint32LE = a3.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    a3.prototype.writeUint32BE = a3.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function hn2(e, t, r, n, i) {
      gn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let l3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, r;
    }
    function pn2(e, t, r, n, i) {
      gn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let l3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = l3, l3 = l3 >> 8, e[r + 2] = l3, l3 = l3 >> 8, e[r + 1] = l3, l3 = l3 >> 8, e[r] = l3, r + 8;
    }
    a3.prototype.writeBigUInt64LE = fe(function(t, r = 0) {
      return hn2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    a3.prototype.writeBigUInt64BE = fe(function(t, r = 0) {
      return pn2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    a3.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let f2 = Math.pow(2, 8 * n - 1);
        O3(this, t, r, n, f2 - 1, -f2);
      }
      let o2 = 0, l3 = 1, u3 = 0;
      for (this[r] = t & 255;++o2 < n && (l3 *= 256); )
        t < 0 && u3 === 0 && this[r + o2 - 1] !== 0 && (u3 = 1), this[r + o2] = (t / l3 >> 0) - u3 & 255;
      return r + n;
    };
    a3.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let f2 = Math.pow(2, 8 * n - 1);
        O3(this, t, r, n, f2 - 1, -f2);
      }
      let o2 = n - 1, l3 = 1, u3 = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (l3 *= 256); )
        t < 0 && u3 === 0 && this[r + o2 + 1] !== 0 && (u3 = 1), this[r + o2] = (t / l3 >> 0) - u3 & 255;
      return r + n;
    };
    a3.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    a3.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    a3.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    a3.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    a3.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O3(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    a3.prototype.writeBigInt64LE = fe(function(t, r = 0) {
      return hn2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    a3.prototype.writeBigInt64BE = fe(function(t, r = 0) {
      return pn2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function yn2(e, t, r, n, i, o2) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function wn(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || yn2(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Le.write(e, t, r, n, 23, 4), r + 4;
    }
    a3.prototype.writeFloatLE = function(t, r, n) {
      return wn(this, t, r, true, n);
    };
    a3.prototype.writeFloatBE = function(t, r, n) {
      return wn(this, t, r, false, n);
    };
    function bn(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || yn2(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Le.write(e, t, r, n, 52, 8), r + 8;
    }
    a3.prototype.writeDoubleLE = function(t, r, n) {
      return bn(this, t, r, true, n);
    };
    a3.prototype.writeDoubleBE = function(t, r, n) {
      return bn(this, t, r, false, n);
    };
    a3.prototype.copy = function(t, r, n, i) {
      if (!a3.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o2 = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o2;
    };
    a3.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !a3.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let l3 = t.charCodeAt(0);
          (i === "utf8" && l3 < 128 || i === "latin1") && (t = l3);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < n; ++o2)
          this[o2] = t;
      else {
        let l3 = a3.isBuffer(t) ? t : a3.from(t, i), u3 = l3.length;
        if (u3 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r; ++o2)
          this[o2 + r] = l3[o2 % u3];
      }
      return this;
    };
    var Be = {};
    function zt(e, t, r) {
      Be[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    zt("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    zt("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = un(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = un(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function un(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function Wl2(e, t, r) {
      Ne(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ge(t, e.length - (r + 1));
    }
    function gn(e, t, r, n, i, o2) {
      if (e > r || e < t) {
        let l3 = typeof t == "bigint" ? "n" : "", u3;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? u3 = `>= 0${l3} and < 2${l3} ** ${(o2 + 1) * 8}${l3}` : u3 = `>= -(2${l3} ** ${(o2 + 1) * 8 - 1}${l3}) and < 2 ** ${(o2 + 1) * 8 - 1}${l3}` : u3 = `>= ${t}${l3} and <= ${r}${l3}`, new Be.ERR_OUT_OF_RANGE("value", u3, e);
      }
      Wl2(n, i, o2);
    }
    function Ne(e, t) {
      if (typeof e != "number")
        throw new Be.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ge(e, t, r) {
      throw Math.floor(e) !== e ? (Ne(e, r), new Be.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new Be.ERR_BUFFER_OUT_OF_BOUNDS : new Be.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var $l = /[^+/0-9A-Za-z-_]/g;
    function jl(e) {
      if (e = e.split("=")[0], e = e.trim().replace($l, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Vt(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o2 = [];
      for (let l3 = 0;l3 < n; ++l3) {
        if (r = e.charCodeAt(l3), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (l3 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function Gl(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Hl(e, t) {
      let r, n, i, o2 = [];
      for (let l3 = 0;l3 < e.length && !((t -= 2) < 0); ++l3)
        r = e.charCodeAt(l3), n = r >> 8, i = r % 256, o2.push(i), o2.push(n);
      return o2;
    }
    function _n(e) {
      return jt.toByteArray(jl(e));
    }
    function ot2(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function H3(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function Xt2(e) {
      return e !== e;
    }
    var Vl = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function fe(e) {
      return typeof BigInt > "u" ? Yl : e;
    }
    function Yl() {
      throw new Error("BigInt not supported");
    }
  });
  I3 = E5((Gc, En) => {
    En.exports = { ArrayIsArray(e) {
      return Array.isArray(e);
    }, ArrayPrototypeIncludes(e, t) {
      return e.includes(t);
    }, ArrayPrototypeIndexOf(e, t) {
      return e.indexOf(t);
    }, ArrayPrototypeJoin(e, t) {
      return e.join(t);
    }, ArrayPrototypeMap(e, t) {
      return e.map(t);
    }, ArrayPrototypePop(e, t) {
      return e.pop(t);
    }, ArrayPrototypePush(e, t) {
      return e.push(t);
    }, ArrayPrototypeSlice(e, t, r) {
      return e.slice(t, r);
    }, Error, FunctionPrototypeCall(e, t, ...r) {
      return e.call(t, ...r);
    }, FunctionPrototypeSymbolHasInstance(e, t) {
      return Function.prototype[Symbol.hasInstance].call(e, t);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(e, t) {
      return Object.defineProperties(e, t);
    }, ObjectDefineProperty(e, t, r) {
      return Object.defineProperty(e, t, r);
    }, ObjectGetOwnPropertyDescriptor(e, t) {
      return Object.getOwnPropertyDescriptor(e, t);
    }, ObjectKeys(e) {
      return Object.keys(e);
    }, ObjectSetPrototypeOf(e, t) {
      return Object.setPrototypeOf(e, t);
    }, Promise, PromisePrototypeCatch(e, t) {
      return e.catch(t);
    }, PromisePrototypeThen(e, t, r) {
      return e.then(t, r);
    }, PromiseReject(e) {
      return Promise.reject(e);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(e, t) {
      return e.test(t);
    }, SafeSet: Set, String, StringPrototypeSlice(e, t, r) {
      return e.slice(t, r);
    }, StringPrototypeToLowerCase(e) {
      return e.toLowerCase();
    }, StringPrototypeToUpperCase(e) {
      return e.toUpperCase();
    }, StringPrototypeTrim(e) {
      return e.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(e, t, r) {
      return e.set(t, r);
    }, Uint8Array };
  });
  V4 = E5((Hc, Qt) => {
    var Kl = te(), zl = Object.getPrototypeOf(async function() {
    }).constructor, Sn = globalThis.Blob || Kl.Blob, Xl = typeof Sn < "u" ? function(t) {
      return t instanceof Sn;
    } : function(t) {
      return false;
    }, Jt2 = class extends Error {
      constructor(t) {
        if (!Array.isArray(t))
          throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
        let r = "";
        for (let n = 0;n < t.length; n++)
          r += `    ${t[n].stack}
`;
        super(r), this.name = "AggregateError", this.errors = t;
      }
    };
    Qt.exports = { AggregateError: Jt2, kEmptyObject: Object.freeze({}), once(e) {
      let t = false;
      return function(...r) {
        t || (t = true, e.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let e, t;
      return { promise: new Promise((n, i) => {
        e = n, t = i;
      }), resolve: e, reject: t };
    }, promisify(e) {
      return new Promise((t, r) => {
        e((n, ...i) => n ? r(n) : t(...i));
      });
    }, debuglog() {
      return function() {
      };
    }, format(e, ...t) {
      return e.replace(/%([sdifj])/g, function(...[r, n]) {
        let i = t.shift();
        return n === "f" ? i.toFixed(6) : n === "j" ? JSON.stringify(i) : n === "s" && typeof i == "object" ? `${i.constructor !== Object ? i.constructor.name : ""} {}`.trim() : i.toString();
      });
    }, inspect(e) {
      switch (typeof e) {
        case "string":
          if (e.includes("'"))
            if (e.includes('"')) {
              if (!e.includes("`") && !e.includes("${"))
                return `\`${e}\``;
            } else
              return `"${e}"`;
          return `'${e}'`;
        case "number":
          return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
        case "bigint":
          return `${String(e)}n`;
        case "boolean":
        case "undefined":
          return String(e);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(e) {
      return e instanceof zl;
    }, isArrayBufferView(e) {
      return ArrayBuffer.isView(e);
    } }, isBlob: Xl };
    Qt.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  ut = E5((Vc, lt2) => {
    var { AbortController: mn, AbortSignal: Jl } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    lt2.exports = mn;
    lt2.exports.AbortSignal = Jl;
    lt2.exports.default = mn;
  });
  C2 = E5((Yc, An) => {
    var { format: Ql, inspect: ft, AggregateError: Zl } = V4(), eu = globalThis.AggregateError || Zl, tu = Symbol("kIsNodeError"), ru = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], nu = /^([A-Z][a-z0-9]*)+$/, iu = "__node_internal_", st2 = {};
    function be(e, t) {
      if (!e)
        throw new st2.ERR_INTERNAL_ASSERTION(t);
    }
    function xn(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function ou2(e, t, r) {
      if (typeof t == "function")
        return be(t.length <= r.length, `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`), t(...r);
      let n = (t.match(/%[dfijoOs]/g) || []).length;
      return be(n === r.length, `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`), r.length === 0 ? t : Ql(t, ...r);
    }
    function M3(e, t, r) {
      r || (r = Error);

      class n extends r {
        constructor(...o2) {
          super(ou2(e, t, o2));
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      }
      Object.defineProperties(n.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${e}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), n.prototype.code = e, n.prototype[tu] = true, st2[e] = n;
    }
    function Rn(e) {
      let t = iu + e.name;
      return Object.defineProperty(e, "name", { value: t }), e;
    }
    function lu(e, t) {
      if (e && t && e !== t) {
        if (Array.isArray(t.errors))
          return t.errors.push(e), t;
        let r = new eu([t, e], t.message);
        return r.code = t.code, r;
      }
      return e || t;
    }
    var Zt = class extends Error {
      constructor(t = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new st2.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    M3("ERR_ASSERTION", "%s", Error);
    M3("ERR_INVALID_ARG_TYPE", (e, t, r) => {
      be(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
      let n = "The ";
      e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
      let i = [], o2 = [], l3 = [];
      for (let f2 of t)
        be(typeof f2 == "string", "All expected entries have to be of type string"), ru.includes(f2) ? i.push(f2.toLowerCase()) : nu.test(f2) ? o2.push(f2) : (be(f2 !== "object", 'The value "object" should be written as "Object"'), l3.push(f2));
      if (o2.length > 0) {
        let f2 = i.indexOf("object");
        f2 !== -1 && (i.splice(i, f2, 1), o2.push("Object"));
      }
      if (i.length > 0) {
        switch (i.length) {
          case 1:
            n += `of type ${i[0]}`;
            break;
          case 2:
            n += `one of type ${i[0]} or ${i[1]}`;
            break;
          default: {
            let f2 = i.pop();
            n += `one of type ${i.join(", ")}, or ${f2}`;
          }
        }
        (o2.length > 0 || l3.length > 0) && (n += " or ");
      }
      if (o2.length > 0) {
        switch (o2.length) {
          case 1:
            n += `an instance of ${o2[0]}`;
            break;
          case 2:
            n += `an instance of ${o2[0]} or ${o2[1]}`;
            break;
          default: {
            let f2 = o2.pop();
            n += `an instance of ${o2.join(", ")}, or ${f2}`;
          }
        }
        l3.length > 0 && (n += " or ");
      }
      switch (l3.length) {
        case 0:
          break;
        case 1:
          l3[0].toLowerCase() !== l3[0] && (n += "an "), n += `${l3[0]}`;
          break;
        case 2:
          n += `one of ${l3[0]} or ${l3[1]}`;
          break;
        default: {
          let f2 = l3.pop();
          n += `one of ${l3.join(", ")}, or ${f2}`;
        }
      }
      if (r == null)
        n += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        n += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var u3;
        (u3 = r.constructor) !== null && u3 !== undefined && u3.name ? n += `. Received an instance of ${r.constructor.name}` : n += `. Received ${ft(r, { depth: -1 })}`;
      } else {
        let f2 = ft(r, { colors: false });
        f2.length > 25 && (f2 = `${f2.slice(0, 25)}...`), n += `. Received type ${typeof r} (${f2})`;
      }
      return n;
    }, TypeError);
    M3("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
      let n = ft(t);
      return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
    }, TypeError);
    M3("ERR_INVALID_RETURN_VALUE", (e, t, r) => {
      var n;
      let i = r != null && (n = r.constructor) !== null && n !== undefined && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
    }, TypeError);
    M3("ERR_MISSING_ARGS", (...e) => {
      be(e.length > 0, "At least one arg needs to be specified");
      let t, r = e.length;
      switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
        case 1:
          t += `The ${e[0]} argument`;
          break;
        case 2:
          t += `The ${e[0]} and ${e[1]} arguments`;
          break;
        default:
          {
            let n = e.pop();
            t += `The ${e.join(", ")}, and ${n} arguments`;
          }
          break;
      }
      return `${t} must be specified`;
    }, TypeError);
    M3("ERR_OUT_OF_RANGE", (e, t, r) => {
      be(t, 'Missing "range" argument');
      let n;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = xn(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = xn(n)), n += "n") : n = ft(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
    }, RangeError);
    M3("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    M3("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    M3("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    M3("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    M3("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    M3("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    M3("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    M3("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    M3("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    M3("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    M3("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    An.exports = { AbortError: Zt, aggregateTwoErrors: Rn(lu), hideStackFrames: Rn, codes: st2 };
  });
  He = E5((Kc, Cn) => {
    var { ArrayIsArray: Bn, ArrayPrototypeIncludes: Ln2, ArrayPrototypeJoin: Nn, ArrayPrototypeMap: uu, NumberIsInteger: tr, NumberIsNaN: fu2, NumberMAX_SAFE_INTEGER: su, NumberMIN_SAFE_INTEGER: au, NumberParseInt: cu2, ObjectPrototypeHasOwnProperty: du, RegExpPrototypeExec: hu, String: pu, StringPrototypeToUpperCase: yu, StringPrototypeTrim: wu2 } = I3(), { hideStackFrames: W, codes: { ERR_SOCKET_BAD_PORT: bu2, ERR_INVALID_ARG_TYPE: D2, ERR_INVALID_ARG_VALUE: at, ERR_OUT_OF_RANGE: ge, ERR_UNKNOWN_SIGNAL: In } } = C2(), { normalizeEncoding: gu } = V4(), { isAsyncFunction: _u2, isArrayBufferView: Eu2 } = V4().types, Tn = {};
    function Su(e) {
      return e === (e | 0);
    }
    function mu2(e) {
      return e === e >>> 0;
    }
    var xu2 = /^[0-7]+$/, Ru = "must be a 32-bit unsigned integer or an octal string";
    function Au2(e, t, r) {
      if (typeof e > "u" && (e = r), typeof e == "string") {
        if (hu(xu2, e) === null)
          throw new at(t, e, Ru);
        e = cu2(e, 8);
      }
      return Fn(e, t), e;
    }
    var Iu2 = W((e, t, r = au, n = su) => {
      if (typeof e != "number")
        throw new D2(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      if (e < r || e > n)
        throw new ge(t, `>= ${r} && <= ${n}`, e);
    }), Tu2 = W((e, t, r = -2147483648, n = 2147483647) => {
      if (typeof e != "number")
        throw new D2(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      if (e < r || e > n)
        throw new ge(t, `>= ${r} && <= ${n}`, e);
    }), Fn = W((e, t, r = false) => {
      if (typeof e != "number")
        throw new D2(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      let n = r ? 1 : 0, i = 4294967295;
      if (e < n || e > i)
        throw new ge(t, `>= ${n} && <= ${i}`, e);
    });
    function Mn(e, t) {
      if (typeof e != "string")
        throw new D2(t, "string", e);
    }
    function Bu(e, t, r = undefined, n) {
      if (typeof e != "number")
        throw new D2(t, "number", e);
      if (r != null && e < r || n != null && e > n || (r != null || n != null) && fu2(e))
        throw new ge(t, `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`, e);
    }
    var Lu = W((e, t, r) => {
      if (!Ln2(r, e)) {
        let n = Nn(uu(r, (o2) => typeof o2 == "string" ? `'${o2}'` : pu(o2)), ", "), i = "must be one of: " + n;
        throw new at(t, e, i);
      }
    });
    function Nu(e, t) {
      if (typeof e != "boolean")
        throw new D2(t, "boolean", e);
    }
    function er(e, t, r) {
      return e == null || !du(e, t) ? r : e[t];
    }
    var Fu2 = W((e, t, r = null) => {
      let n = er(r, "allowArray", false), i = er(r, "allowFunction", false);
      if (!er(r, "nullable", false) && e === null || !n && Bn(e) || typeof e != "object" && (!i || typeof e != "function"))
        throw new D2(t, "Object", e);
    }), Mu2 = W((e, t, r = 0) => {
      if (!Bn(e))
        throw new D2(t, "Array", e);
      if (e.length < r) {
        let n = `must be longer than ${r}`;
        throw new at(t, e, n);
      }
    });
    function Cu(e, t = "signal") {
      if (Mn(e, t), Tn[e] === undefined)
        throw Tn[yu(e)] !== undefined ? new In(e + " (signals must use all capital letters)") : new In(e);
    }
    var Ou2 = W((e, t = "buffer") => {
      if (!Eu2(e))
        throw new D2(t, ["Buffer", "TypedArray", "DataView"], e);
    });
    function Du(e, t) {
      let r = gu(t), n = e.length;
      if (r === "hex" && n % 2 !== 0)
        throw new at("encoding", t, `is invalid for data of length ${n}`);
    }
    function Pu2(e, t = "Port", r = true) {
      if (typeof e != "number" && typeof e != "string" || typeof e == "string" && wu2(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
        throw new bu2(t, e, r);
      return e | 0;
    }
    var ku2 = W((e, t) => {
      if (e !== undefined && (e === null || typeof e != "object" || !("aborted" in e)))
        throw new D2(t, "AbortSignal", e);
    }), Uu = W((e, t) => {
      if (typeof e != "function")
        throw new D2(t, "Function", e);
    }), vu = W((e, t) => {
      if (typeof e != "function" || _u2(e))
        throw new D2(t, "Function", e);
    }), qu = W((e, t) => {
      if (e !== undefined)
        throw new D2(t, "undefined", e);
    });
    function Wu2(e, t, r) {
      if (!Ln2(r, e))
        throw new D2(t, `('${Nn(r, "|")}')`, e);
    }
    Cn.exports = { isInt32: Su, isUint32: mu2, parseFileMode: Au2, validateArray: Mu2, validateBoolean: Nu, validateBuffer: Ou2, validateEncoding: Du, validateFunction: Uu, validateInt32: Tu2, validateInteger: Iu2, validateNumber: Bu, validateObject: Fu2, validateOneOf: Lu, validatePlainFunction: vu, validatePort: Pu2, validateSignalName: Cu, validateString: Mn, validateUint32: Fn, validateUndefined: qu, validateUnion: Wu2, validateAbortSignal: ku2 };
  });
  ir = E5((zc, kn2) => {
    var x4 = kn2.exports = {}, Y4, K2;
    function rr() {
      throw new Error("setTimeout has not been defined");
    }
    function nr() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Y4 = setTimeout : Y4 = rr;
      } catch {
        Y4 = rr;
      }
      try {
        typeof clearTimeout == "function" ? K2 = clearTimeout : K2 = nr;
      } catch {
        K2 = nr;
      }
    })();
    function On(e) {
      if (Y4 === setTimeout)
        return setTimeout(e, 0);
      if ((Y4 === rr || !Y4) && setTimeout)
        return Y4 = setTimeout, setTimeout(e, 0);
      try {
        return Y4(e, 0);
      } catch {
        try {
          return Y4.call(null, e, 0);
        } catch {
          return Y4.call(this, e, 0);
        }
      }
    }
    function $u(e) {
      if (K2 === clearTimeout)
        return clearTimeout(e);
      if ((K2 === nr || !K2) && clearTimeout)
        return K2 = clearTimeout, clearTimeout(e);
      try {
        return K2(e);
      } catch {
        try {
          return K2.call(null, e);
        } catch {
          return K2.call(this, e);
        }
      }
    }
    var re2 = [], Me = false, _e, ct2 = -1;
    function ju2() {
      !Me || !_e || (Me = false, _e.length ? re2 = _e.concat(re2) : ct2 = -1, re2.length && Dn());
    }
    function Dn() {
      if (!Me) {
        var e = On(ju2);
        Me = true;
        for (var t = re2.length;t; ) {
          for (_e = re2, re2 = [];++ct2 < t; )
            _e && _e[ct2].run();
          ct2 = -1, t = re2.length;
        }
        _e = null, Me = false, $u(e);
      }
    }
    x4.nextTick = function(e) {
      var t = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          t[r - 1] = arguments[r];
      re2.push(new Pn(e, t)), re2.length === 1 && !Me && On(Dn);
    };
    function Pn(e, t) {
      this.fun = e, this.array = t;
    }
    Pn.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    x4.title = "browser";
    x4.browser = true;
    x4.env = {};
    x4.argv = [];
    x4.version = "";
    x4.versions = {};
    function ne() {
    }
    x4.on = ne;
    x4.addListener = ne;
    x4.once = ne;
    x4.off = ne;
    x4.removeListener = ne;
    x4.removeAllListeners = ne;
    x4.emit = ne;
    x4.prependListener = ne;
    x4.prependOnceListener = ne;
    x4.listeners = function(e) {
      return [];
    };
    x4.binding = function(e) {
      throw new Error("process.binding is not supported");
    };
    x4.cwd = function() {
      return "/";
    };
    x4.chdir = function(e) {
      throw new Error("process.chdir is not supported");
    };
    x4.umask = function() {
      return 0;
    };
  });
  k4 = {};
  Qr2(k4, { default: () => Gu });
  se = yl2(() => {
    ue(k4, rt2(ir()));
    Gu = rt2(ir());
  });
  ae = E5((Jc, zn) => {
    var { Symbol: dt2, SymbolAsyncIterator: Un, SymbolIterator: vn } = I3(), qn = dt2("kDestroyed"), Wn = dt2("kIsErrored"), or2 = dt2("kIsReadable"), $n = dt2("kIsDisturbed");
    function ht(e, t = false) {
      var r;
      return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!e._writableState || e._readableState));
    }
    function pt2(e) {
      var t;
      return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === undefined ? undefined : t.writable) !== false));
    }
    function Hu(e) {
      return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
    }
    function Ee(e) {
      return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
    }
    function Vu(e, t) {
      return e == null ? false : t === true ? typeof e[Un] == "function" : t === false ? typeof e[vn] == "function" : typeof e[Un] == "function" || typeof e[vn] == "function";
    }
    function yt2(e) {
      if (!Ee(e))
        return null;
      let { _writableState: t, _readableState: r } = e, n = t || r;
      return !!(e.destroyed || e[qn] || n != null && n.destroyed);
    }
    function jn(e) {
      if (!pt2(e))
        return null;
      if (e.writableEnded === true)
        return true;
      let t = e._writableState;
      return t != null && t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Yu2(e, t) {
      if (!pt2(e))
        return null;
      if (e.writableFinished === true)
        return true;
      let r = e._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || t === false && r.ended === true && r.length === 0);
    }
    function Ku(e) {
      if (!ht(e))
        return null;
      if (e.readableEnded === true)
        return true;
      let t = e._readableState;
      return !t || t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Gn(e, t) {
      if (!ht(e))
        return null;
      let r = e._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || t === false && r.ended === true && r.length === 0);
    }
    function Hn(e) {
      return e && e[or2] != null ? e[or2] : typeof e?.readable != "boolean" ? null : yt2(e) ? false : ht(e) && e.readable && !Gn(e);
    }
    function Vn(e) {
      return typeof e?.writable != "boolean" ? null : yt2(e) ? false : pt2(e) && e.writable && !jn(e);
    }
    function zu(e, t) {
      return Ee(e) ? yt2(e) ? true : !(t?.readable !== false && Hn(e) || t?.writable !== false && Vn(e)) : null;
    }
    function Xu(e) {
      var t, r;
      return Ee(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === undefined ? undefined : r.errored) !== null && t !== undefined ? t : null : null;
    }
    function Ju(e) {
      var t, r;
      return Ee(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === undefined ? undefined : r.errored) !== null && t !== undefined ? t : null : null;
    }
    function Qu(e) {
      if (!Ee(e))
        return null;
      if (typeof e.closed == "boolean")
        return e.closed;
      let { _writableState: t, _readableState: r } = e;
      return typeof t?.closed == "boolean" || typeof r?.closed == "boolean" ? t?.closed || r?.closed : typeof e._closed == "boolean" && Yn(e) ? e._closed : null;
    }
    function Yn(e) {
      return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
    }
    function Kn(e) {
      return typeof e._sent100 == "boolean" && Yn(e);
    }
    function Zu(e) {
      var t;
      return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === undefined ? undefined : t.upgradeOrConnect) === undefined;
    }
    function ef(e) {
      if (!Ee(e))
        return null;
      let { _writableState: t, _readableState: r } = e, n = t || r;
      return !n && Kn(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === false);
    }
    function tf(e) {
      var t;
      return !!(e && ((t = e[$n]) !== null && t !== undefined ? t : e.readableDidRead || e.readableAborted));
    }
    function rf(e) {
      var t, r, n, i, o2, l3, u3, f2, s3, d4;
      return !!(e && ((t = (r = (n = (i = (o2 = (l3 = e[Wn]) !== null && l3 !== undefined ? l3 : e.readableErrored) !== null && o2 !== undefined ? o2 : e.writableErrored) !== null && i !== undefined ? i : (u3 = e._readableState) === null || u3 === undefined ? undefined : u3.errorEmitted) !== null && n !== undefined ? n : (f2 = e._writableState) === null || f2 === undefined ? undefined : f2.errorEmitted) !== null && r !== undefined ? r : (s3 = e._readableState) === null || s3 === undefined ? undefined : s3.errored) !== null && t !== undefined ? t : (d4 = e._writableState) === null || d4 === undefined ? undefined : d4.errored));
    }
    zn.exports = { kDestroyed: qn, isDisturbed: tf, kIsDisturbed: $n, isErrored: rf, kIsErrored: Wn, isReadable: Hn, kIsReadable: or2, isClosed: Qu, isDestroyed: yt2, isDuplexNodeStream: Hu, isFinished: zu, isIterable: Vu, isReadableNodeStream: ht, isReadableEnded: Ku, isReadableFinished: Gn, isReadableErrored: Ju, isNodeStream: Ee, isWritable: Vn, isWritableNodeStream: pt2, isWritableEnded: jn, isWritableFinished: Yu2, isWritableErrored: Xu, isServerRequest: Zu, isServerResponse: Kn, willEmitClose: ef };
  });
  ce2 = E5((Qc2, ur2) => {
    var Ce = (se(), pe(k4)), { AbortError: nf, codes: of } = C2(), { ERR_INVALID_ARG_TYPE: lf, ERR_STREAM_PREMATURE_CLOSE: Xn } = of, { kEmptyObject: Jn, once: Qn } = V4(), { validateAbortSignal: uf, validateFunction: ff, validateObject: sf } = He(), { Promise: af } = I3(), { isClosed: cf, isReadable: Zn, isReadableNodeStream: lr, isReadableFinished: ei, isReadableErrored: df, isWritable: ti, isWritableNodeStream: ri2, isWritableFinished: ni, isWritableErrored: hf, isNodeStream: pf, willEmitClose: yf2 } = ae();
    function wf(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    var bf2 = () => {
    };
    function ii(e, t, r) {
      var n, i;
      arguments.length === 2 ? (r = t, t = Jn) : t == null ? t = Jn : sf(t, "options"), ff(r, "callback"), uf(t.signal, "options.signal"), r = Qn(r);
      let o2 = (n = t.readable) !== null && n !== undefined ? n : lr(e), l3 = (i = t.writable) !== null && i !== undefined ? i : ri2(e);
      if (!pf(e))
        throw new lf("stream", "Stream", e);
      let { _writableState: u3, _readableState: f2 } = e, s3 = () => {
        e.writable || y4();
      }, d4 = yf2(e) && lr(e) === o2 && ri2(e) === l3, c2 = ni(e, false), y4 = () => {
        c2 = true, e.destroyed && (d4 = false), !(d4 && (!e.readable || o2)) && (!o2 || h4) && r.call(e);
      }, h4 = ei(e, false), p4 = () => {
        h4 = true, e.destroyed && (d4 = false), !(d4 && (!e.writable || l3)) && (!l3 || c2) && r.call(e);
      }, B3 = (N5) => {
        r.call(e, N5);
      }, v2 = cf(e), w2 = () => {
        v2 = true;
        let N5 = hf(e) || df(e);
        if (N5 && typeof N5 != "boolean")
          return r.call(e, N5);
        if (o2 && !h4 && lr(e, true) && !ei(e, false))
          return r.call(e, new Xn);
        if (l3 && !c2 && !ni(e, false))
          return r.call(e, new Xn);
        r.call(e);
      }, b4 = () => {
        e.req.on("finish", y4);
      };
      wf(e) ? (e.on("complete", y4), d4 || e.on("abort", w2), e.req ? b4() : e.on("request", b4)) : l3 && !u3 && (e.on("end", s3), e.on("close", s3)), !d4 && typeof e.aborted == "boolean" && e.on("aborted", w2), e.on("end", p4), e.on("finish", y4), t.error !== false && e.on("error", B3), e.on("close", w2), v2 ? Ce.nextTick(w2) : u3 != null && u3.errorEmitted || f2 != null && f2.errorEmitted ? d4 || Ce.nextTick(w2) : (!o2 && (!d4 || Zn(e)) && (c2 || ti(e) === false) || !l3 && (!d4 || ti(e)) && (h4 || Zn(e) === false) || f2 && e.req && e.aborted) && Ce.nextTick(w2);
      let L4 = () => {
        r = bf2, e.removeListener("aborted", w2), e.removeListener("complete", y4), e.removeListener("abort", w2), e.removeListener("request", b4), e.req && e.req.removeListener("finish", y4), e.removeListener("end", s3), e.removeListener("close", s3), e.removeListener("finish", y4), e.removeListener("end", p4), e.removeListener("error", B3), e.removeListener("close", w2);
      };
      if (t.signal && !v2) {
        let N5 = () => {
          let Q3 = r;
          L4(), Q3.call(e, new nf(undefined, { cause: t.signal.reason }));
        };
        if (t.signal.aborted)
          Ce.nextTick(N5);
        else {
          let Q3 = r;
          r = Qn((...Ie2) => {
            t.signal.removeEventListener("abort", N5), Q3.apply(e, Ie2);
          }), t.signal.addEventListener("abort", N5);
        }
      }
      return L4;
    }
    function gf(e, t) {
      return new af((r, n) => {
        ii(e, t, (i) => {
          i ? n(i) : r();
        });
      });
    }
    ur2.exports = ii;
    ur2.exports.finished = gf;
  });
  di = E5((Zc, ar2) => {
    var fi = globalThis.AbortController || ut().AbortController, { codes: { ERR_INVALID_ARG_TYPE: Ve, ERR_MISSING_ARGS: _f, ERR_OUT_OF_RANGE: Ef }, AbortError: z } = C2(), { validateAbortSignal: Oe, validateInteger: Sf, validateObject: De } = He(), mf = I3().Symbol("kWeak"), { finished: xf } = ce2(), { ArrayPrototypePush: Rf, MathFloor: Af, Number: If, NumberIsNaN: Tf2, Promise: oi, PromiseReject: li, PromisePrototypeThen: Bf, Symbol: si } = I3(), wt = si("kEmpty"), ui = si("kEof");
    function bt2(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal");
      let r = 1;
      return t?.concurrency != null && (r = Af(t.concurrency)), Sf(r, "concurrency", 1), async function* () {
        var i, o2;
        let l3 = new fi, u3 = this, f2 = [], s3 = l3.signal, d4 = { signal: s3 }, c2 = () => l3.abort();
        t != null && (i = t.signal) !== null && i !== undefined && i.aborted && c2(), t == null || (o2 = t.signal) === null || o2 === undefined || o2.addEventListener("abort", c2);
        let y4, h4, p4 = false;
        function B3() {
          p4 = true;
        }
        async function v2() {
          try {
            for await (let L4 of u3) {
              var w2;
              if (p4)
                return;
              if (s3.aborted)
                throw new z;
              try {
                L4 = e(L4, d4);
              } catch (N5) {
                L4 = li(N5);
              }
              L4 !== wt && (typeof ((w2 = L4) === null || w2 === undefined ? undefined : w2.catch) == "function" && L4.catch(B3), f2.push(L4), y4 && (y4(), y4 = null), !p4 && f2.length && f2.length >= r && await new oi((N5) => {
                h4 = N5;
              }));
            }
            f2.push(ui);
          } catch (L4) {
            let N5 = li(L4);
            Bf(N5, undefined, B3), f2.push(N5);
          } finally {
            var b4;
            p4 = true, y4 && (y4(), y4 = null), t == null || (b4 = t.signal) === null || b4 === undefined || b4.removeEventListener("abort", c2);
          }
        }
        v2();
        try {
          for (;; ) {
            for (;f2.length > 0; ) {
              let w2 = await f2[0];
              if (w2 === ui)
                return;
              if (s3.aborted)
                throw new z;
              w2 !== wt && (yield w2), f2.shift(), h4 && (h4(), h4 = null);
            }
            await new oi((w2) => {
              y4 = w2;
            });
          }
        } finally {
          l3.abort(), p4 = true, h4 && (h4(), h4 = null);
        }
      }.call(this);
    }
    function Lf(e = undefined) {
      return e != null && De(e, "options"), e?.signal != null && Oe(e.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let i of this) {
          var n;
          if (e != null && (n = e.signal) !== null && n !== undefined && n.aborted)
            throw new z({ cause: e.signal.reason });
          yield [r++, i];
        }
      }.call(this);
    }
    async function ai(e, t = undefined) {
      for await (let r of sr.call(this, e, t))
        return true;
      return false;
    }
    async function Nf(e, t = undefined) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      return !await ai.call(this, async (...r) => !await e(...r), t);
    }
    async function Ff(e, t) {
      for await (let r of sr.call(this, e, t))
        return r;
    }
    async function Mf(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      async function r(n, i) {
        return await e(n, i), wt;
      }
      for await (let n of bt2.call(this, r, t))
        ;
    }
    function sr(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      async function r(n, i) {
        return await e(n, i) ? n : wt;
      }
      return bt2.call(this, r, t);
    }
    var fr = class extends _f {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function Cf(e, t, r) {
      var n;
      if (typeof e != "function")
        throw new Ve("reducer", ["Function", "AsyncFunction"], e);
      r != null && De(r, "options"), r?.signal != null && Oe(r.signal, "options.signal");
      let i = arguments.length > 1;
      if (r != null && (n = r.signal) !== null && n !== undefined && n.aborted) {
        let s3 = new z(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await xf(this.destroy(s3)), s3;
      }
      let o2 = new fi, l3 = o2.signal;
      if (r != null && r.signal) {
        let s3 = { once: true, [mf]: this };
        r.signal.addEventListener("abort", () => o2.abort(), s3);
      }
      let u3 = false;
      try {
        for await (let s3 of this) {
          var f2;
          if (u3 = true, r != null && (f2 = r.signal) !== null && f2 !== undefined && f2.aborted)
            throw new z;
          i ? t = await e(t, s3, { signal: l3 }) : (t = s3, i = true);
        }
        if (!u3 && !i)
          throw new fr;
      } finally {
        o2.abort();
      }
      return t;
    }
    async function Of(e) {
      e != null && De(e, "options"), e?.signal != null && Oe(e.signal, "options.signal");
      let t = [];
      for await (let n of this) {
        var r;
        if (e != null && (r = e.signal) !== null && r !== undefined && r.aborted)
          throw new z(undefined, { cause: e.signal.reason });
        Rf(t, n);
      }
      return t;
    }
    function Df(e, t) {
      let r = bt2.call(this, e, t);
      return async function* () {
        for await (let i of r)
          yield* i;
      }.call(this);
    }
    function ci(e) {
      if (e = If(e), Tf2(e))
        return 0;
      if (e < 0)
        throw new Ef("number", ">= 0", e);
      return e;
    }
    function Pf(e, t = undefined) {
      return t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal"), e = ci(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new z;
        for await (let o2 of this) {
          var i;
          if (t != null && (i = t.signal) !== null && i !== undefined && i.aborted)
            throw new z;
          e-- <= 0 && (yield o2);
        }
      }.call(this);
    }
    function kf(e, t = undefined) {
      return t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal"), e = ci(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new z;
        for await (let o2 of this) {
          var i;
          if (t != null && (i = t.signal) !== null && i !== undefined && i.aborted)
            throw new z;
          if (e-- > 0)
            yield o2;
          else
            return;
        }
      }.call(this);
    }
    ar2.exports.streamReturningOperators = { asIndexedPairs: Lf, drop: Pf, filter: sr, flatMap: Df, map: bt2, take: kf };
    ar2.exports.promiseReturningOperators = { every: Nf, forEach: Mf, reduce: Cf, toArray: Of, some: ai, find: Ff };
  });
  Se2 = E5((ed, Ei) => {
    var de = (se(), pe(k4)), { aggregateTwoErrors: Uf, codes: { ERR_MULTIPLE_CALLBACK: vf2 }, AbortError: qf } = C2(), { Symbol: yi2 } = I3(), { kDestroyed: Wf, isDestroyed: $f2, isFinished: jf, isServerRequest: Gf } = ae(), wi = yi2("kDestroy"), cr = yi2("kConstruct");
    function bi(e, t, r) {
      e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
    }
    function Hf(e, t) {
      let r = this._readableState, n = this._writableState, i = n || r;
      return n && n.destroyed || r && r.destroyed ? (typeof t == "function" && t(), this) : (bi(e, n, r), n && (n.destroyed = true), r && (r.destroyed = true), i.constructed ? hi(this, e, t) : this.once(wi, function(o2) {
        hi(this, Uf(o2, e), t);
      }), this);
    }
    function hi(e, t, r) {
      let n = false;
      function i(o2) {
        if (n)
          return;
        n = true;
        let { _readableState: l3, _writableState: u3 } = e;
        bi(o2, u3, l3), u3 && (u3.closed = true), l3 && (l3.closed = true), typeof r == "function" && r(o2), o2 ? de.nextTick(Vf, e, o2) : de.nextTick(gi, e);
      }
      try {
        e._destroy(t || null, i);
      } catch (o2) {
        i(o2);
      }
    }
    function Vf(e, t) {
      dr2(e, t), gi(e);
    }
    function gi(e) {
      let { _readableState: t, _writableState: r } = e;
      r && (r.closeEmitted = true), t && (t.closeEmitted = true), (r && r.emitClose || t && t.emitClose) && e.emit("close");
    }
    function dr2(e, t) {
      let { _readableState: r, _writableState: n } = e;
      n && n.errorEmitted || r && r.errorEmitted || (n && (n.errorEmitted = true), r && (r.errorEmitted = true), e.emit("error", t));
    }
    function Yf() {
      let e = this._readableState, t = this._writableState;
      e && (e.constructed = true, e.closed = false, e.closeEmitted = false, e.destroyed = false, e.errored = null, e.errorEmitted = false, e.reading = false, e.ended = e.readable === false, e.endEmitted = e.readable === false), t && (t.constructed = true, t.destroyed = false, t.closed = false, t.closeEmitted = false, t.errored = null, t.errorEmitted = false, t.finalCalled = false, t.prefinished = false, t.ended = t.writable === false, t.ending = t.writable === false, t.finished = t.writable === false);
    }
    function hr(e, t, r) {
      let { _readableState: n, _writableState: i } = e;
      if (i && i.destroyed || n && n.destroyed)
        return this;
      n && n.autoDestroy || i && i.autoDestroy ? e.destroy(t) : t && (t.stack, i && !i.errored && (i.errored = t), n && !n.errored && (n.errored = t), r ? de.nextTick(dr2, e, t) : dr2(e, t));
    }
    function Kf2(e, t) {
      if (typeof e._construct != "function")
        return;
      let { _readableState: r, _writableState: n } = e;
      r && (r.constructed = false), n && (n.constructed = false), e.once(cr, t), !(e.listenerCount(cr) > 1) && de.nextTick(zf, e);
    }
    function zf(e) {
      let t = false;
      function r(n) {
        if (t) {
          hr(e, n ?? new vf2);
          return;
        }
        t = true;
        let { _readableState: i, _writableState: o2 } = e, l3 = o2 || i;
        i && (i.constructed = true), o2 && (o2.constructed = true), l3.destroyed ? e.emit(wi, n) : n ? hr(e, n, true) : de.nextTick(Xf, e);
      }
      try {
        e._construct(r);
      } catch (n) {
        r(n);
      }
    }
    function Xf(e) {
      e.emit(cr);
    }
    function pi(e) {
      return e && e.setHeader && typeof e.abort == "function";
    }
    function _i(e) {
      e.emit("close");
    }
    function Jf2(e, t) {
      e.emit("error", t), de.nextTick(_i, e);
    }
    function Qf2(e, t) {
      !e || $f2(e) || (!t && !jf(e) && (t = new qf), Gf(e) ? (e.socket = null, e.destroy(t)) : pi(e) ? e.abort() : pi(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? de.nextTick(Jf2, e, t) : de.nextTick(_i, e), e.destroyed || (e[Wf] = true));
    }
    Ei.exports = { construct: Kf2, destroyer: Qf2, destroy: Hf, undestroy: Yf, errorOrDestroy: hr };
  });
  Et = E5((td2, pr2) => {
    var Pe2 = typeof Reflect == "object" ? Reflect : null, Si = Pe2 && typeof Pe2.apply == "function" ? Pe2.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, gt2;
    Pe2 && typeof Pe2.ownKeys == "function" ? gt2 = Pe2.ownKeys : Object.getOwnPropertySymbols ? gt2 = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : gt2 = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function Zf(e) {
      console && console.warn && console.warn(e);
    }
    var xi = Number.isNaN || function(t) {
      return t !== t;
    };
    function S2() {
      S2.init.call(this);
    }
    pr2.exports = S2;
    pr2.exports.once = ns;
    S2.EventEmitter = S2;
    S2.prototype._events = undefined;
    S2.prototype._eventsCount = 0;
    S2.prototype._maxListeners = undefined;
    var mi = 10;
    function _t(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(S2, "defaultMaxListeners", { enumerable: true, get: function() {
      return mi;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || xi(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      mi = e;
    } });
    S2.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    S2.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || xi(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Ri(e) {
      return e._maxListeners === undefined ? S2.defaultMaxListeners : e._maxListeners;
    }
    S2.prototype.getMaxListeners = function() {
      return Ri(this);
    };
    S2.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i = i && o2.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var l3;
        if (r.length > 0 && (l3 = r[0]), l3 instanceof Error)
          throw l3;
        var u3 = new Error("Unhandled error." + (l3 ? " (" + l3.message + ")" : ""));
        throw u3.context = l3, u3;
      }
      var f2 = o2[t];
      if (f2 === undefined)
        return false;
      if (typeof f2 == "function")
        Si(f2, this, r);
      else
        for (var s3 = f2.length, d4 = Li(f2, s3), n = 0;n < s3; ++n)
          Si(d4[n], this, r);
      return true;
    };
    function Ai(e, t, r, n) {
      var i, o2, l3;
      if (_t(r), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o2 = e._events), l3 = o2[t]), l3 === undefined)
        l3 = o2[t] = r, ++e._eventsCount;
      else if (typeof l3 == "function" ? l3 = o2[t] = n ? [r, l3] : [l3, r] : n ? l3.unshift(r) : l3.push(r), i = Ri(e), i > 0 && l3.length > i && !l3.warned) {
        l3.warned = true;
        var u3 = new Error("Possible EventEmitter memory leak detected. " + l3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        u3.name = "MaxListenersExceededWarning", u3.emitter = e, u3.type = t, u3.count = l3.length, Zf(u3);
      }
      return e;
    }
    S2.prototype.addListener = function(t, r) {
      return Ai(this, t, r, false);
    };
    S2.prototype.on = S2.prototype.addListener;
    S2.prototype.prependListener = function(t, r) {
      return Ai(this, t, r, true);
    };
    function es() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ii(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = es.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    S2.prototype.once = function(t, r) {
      return _t(r), this.on(t, Ii(this, t, r)), this;
    };
    S2.prototype.prependOnceListener = function(t, r) {
      return _t(r), this.prependListener(t, Ii(this, t, r)), this;
    };
    S2.prototype.removeListener = function(t, r) {
      var n, i, o2, l3, u3;
      if (_t(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o2 = -1, l3 = n.length - 1;l3 >= 0; l3--)
          if (n[l3] === r || n[l3].listener === r) {
            u3 = n[l3].listener, o2 = l3;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : ts(n, o2), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, u3 || r);
      }
      return this;
    };
    S2.prototype.off = S2.prototype.removeListener;
    S2.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), l3;
        for (i = 0;i < o2.length; ++i)
          l3 = o2[i], l3 !== "removeListener" && this.removeAllListeners(l3);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Ti(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? rs(i) : Li(i, i.length);
    }
    S2.prototype.listeners = function(t) {
      return Ti(this, t, true);
    };
    S2.prototype.rawListeners = function(t) {
      return Ti(this, t, false);
    };
    S2.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : Bi.call(e, t);
    };
    S2.prototype.listenerCount = Bi;
    function Bi(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    S2.prototype.eventNames = function() {
      return this._eventsCount > 0 ? gt2(this._events) : [];
    };
    function Li(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function ts(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function rs(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function ns(e, t) {
      return new Promise(function(r, n) {
        function i(l3) {
          e.removeListener(t, o2), n(l3);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        Ni(e, t, o2, { once: true }), t !== "error" && is(e, i, { once: true });
      });
    }
    function is(e, t, r) {
      typeof e.on == "function" && Ni(e, "error", t, r);
    }
    function Ni(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  xt = E5((rd, Mi) => {
    var { ArrayIsArray: os2, ObjectSetPrototypeOf: Fi2 } = I3(), { EventEmitter: St } = Et();
    function mt2(e) {
      St.call(this, e);
    }
    Fi2(mt2.prototype, St.prototype);
    Fi2(mt2, St);
    mt2.prototype.pipe = function(e, t) {
      let r = this;
      function n(d4) {
        e.writable && e.write(d4) === false && r.pause && r.pause();
      }
      r.on("data", n);
      function i() {
        r.readable && r.resume && r.resume();
      }
      e.on("drain", i), !e._isStdio && (!t || t.end !== false) && (r.on("end", l3), r.on("close", u3));
      let o2 = false;
      function l3() {
        o2 || (o2 = true, e.end());
      }
      function u3() {
        o2 || (o2 = true, typeof e.destroy == "function" && e.destroy());
      }
      function f2(d4) {
        s3(), St.listenerCount(this, "error") === 0 && this.emit("error", d4);
      }
      yr(r, "error", f2), yr(e, "error", f2);
      function s3() {
        r.removeListener("data", n), e.removeListener("drain", i), r.removeListener("end", l3), r.removeListener("close", u3), r.removeListener("error", f2), e.removeListener("error", f2), r.removeListener("end", s3), r.removeListener("close", s3), e.removeListener("close", s3);
      }
      return r.on("end", s3), r.on("close", s3), e.on("close", s3), e.emit("pipe", r), e;
    };
    function yr(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : os2(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    Mi.exports = { Stream: mt2, prependListener: yr };
  });
  At2 = E5((nd2, Rt) => {
    var { AbortError: ls, codes: us } = C2(), fs = ce2(), { ERR_INVALID_ARG_TYPE: Ci } = us, ss = (e, t) => {
      if (typeof e != "object" || !("aborted" in e))
        throw new Ci(t, "AbortSignal", e);
    };
    function as(e) {
      return !!(e && typeof e.pipe == "function");
    }
    Rt.exports.addAbortSignal = function(t, r) {
      if (ss(t, "signal"), !as(r))
        throw new Ci("stream", "stream.Stream", r);
      return Rt.exports.addAbortSignalNoValidate(t, r);
    };
    Rt.exports.addAbortSignalNoValidate = function(e, t) {
      if (typeof e != "object" || !("aborted" in e))
        return t;
      let r = () => {
        t.destroy(new ls(undefined, { cause: e.reason }));
      };
      return e.aborted ? r() : (e.addEventListener("abort", r), fs(t, () => e.removeEventListener("abort", r))), t;
    };
  });
  Pi = E5((od2, Di) => {
    var { StringPrototypeSlice: Oi2, SymbolIterator: cs, TypedArrayPrototypeSet: It, Uint8Array: ds } = I3(), { Buffer: wr } = te(), { inspect: hs } = V4();
    Di.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(t) {
        let r = { data: t, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(t) {
        let r = { data: t, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let t = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(t) {
        if (this.length === 0)
          return "";
        let r = this.head, n = "" + r.data;
        for (;(r = r.next) !== null; )
          n += t + r.data;
        return n;
      }
      concat(t) {
        if (this.length === 0)
          return wr.alloc(0);
        let r = wr.allocUnsafe(t >>> 0), n = this.head, i = 0;
        for (;n; )
          It(r, n.data, i), i += n.data.length, n = n.next;
        return r;
      }
      consume(t, r) {
        let n = this.head.data;
        if (t < n.length) {
          let i = n.slice(0, t);
          return this.head.data = n.slice(t), i;
        }
        return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
      }
      first() {
        return this.head.data;
      }
      *[cs]() {
        for (let t = this.head;t; t = t.next)
          yield t.data;
      }
      _getString(t) {
        let r = "", n = this.head, i = 0;
        do {
          let o2 = n.data;
          if (t > o2.length)
            r += o2, t -= o2.length;
          else {
            t === o2.length ? (r += o2, ++i, n.next ? this.head = n.next : this.head = this.tail = null) : (r += Oi2(o2, 0, t), this.head = n, n.data = Oi2(o2, t));
            break;
          }
          ++i;
        } while ((n = n.next) !== null);
        return this.length -= i, r;
      }
      _getBuffer(t) {
        let r = wr.allocUnsafe(t), n = t, i = this.head, o2 = 0;
        do {
          let l3 = i.data;
          if (t > l3.length)
            It(r, l3, n - t), t -= l3.length;
          else {
            t === l3.length ? (It(r, l3, n - t), ++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (It(r, new ds(l3.buffer, l3.byteOffset, t), n - t), this.head = i, i.data = l3.slice(t));
            break;
          }
          ++o2;
        } while ((i = i.next) !== null);
        return this.length -= o2, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](t, r) {
        return hs(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Tt2 = E5((ld, Ui2) => {
    var { MathFloor: ps, NumberIsInteger: ys } = I3(), { ERR_INVALID_ARG_VALUE: ws2 } = C2().codes;
    function bs(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function ki2(e) {
      return e ? 16 : 16 * 1024;
    }
    function gs(e, t, r, n) {
      let i = bs(t, n, r);
      if (i != null) {
        if (!ys(i) || i < 0) {
          let o2 = n ? `options.${r}` : "options.highWaterMark";
          throw new ws2(o2, i);
        }
        return ps(i);
      }
      return ki2(e.objectMode);
    }
    Ui2.exports = { getHighWaterMark: gs, getDefaultHighWaterMark: ki2 };
  });
  Wi = E5((br2, qi) => {
    var Bt = te(), X4 = Bt.Buffer;
    function vi(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    X4.from && X4.alloc && X4.allocUnsafe && X4.allocUnsafeSlow ? qi.exports = Bt : (vi(Bt, br2), br2.Buffer = me);
    function me(e, t, r) {
      return X4(e, t, r);
    }
    me.prototype = Object.create(X4.prototype);
    vi(X4, me);
    me.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return X4(e, t, r);
    };
    me.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = X4(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    me.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return X4(e);
    };
    me.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return Bt.SlowBuffer(e);
    };
  });
  Gi = E5((ji2) => {
    var _r = Wi().Buffer, $i = _r.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _s(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function Es2(e) {
      var t = _s(e);
      if (typeof t != "string" && (_r.isEncoding === $i || !$i(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    ji2.StringDecoder = Ye;
    function Ye(e) {
      this.encoding = Es2(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = Is, this.end = Ts, t = 4;
          break;
        case "utf8":
          this.fillLast = xs, t = 4;
          break;
        case "base64":
          this.text = Bs, this.end = Ls, t = 3;
          break;
        default:
          this.write = Ns, this.end = Fs;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = _r.allocUnsafe(t);
    }
    Ye.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Ye.prototype.end = As2;
    Ye.prototype.text = Rs;
    Ye.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function gr2(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Ss(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = gr2(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = gr2(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = gr2(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function ms(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "";
      }
    }
    function xs(e) {
      var t = this.lastTotal - this.lastNeed, r = ms(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Rs(e, t) {
      var r = Ss(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function As2(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "" : t;
    }
    function Is(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Ts(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Bs(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Ls(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Ns(e) {
      return e.toString(this.encoding);
    }
    function Fs(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Er = E5((fd, Ki) => {
    var Hi = (se(), pe(k4)), { PromisePrototypeThen: Ms, SymbolAsyncIterator: Vi, SymbolIterator: Yi } = I3(), { Buffer: Cs } = te(), { ERR_INVALID_ARG_TYPE: Os, ERR_STREAM_NULL_VALUES: Ds2 } = C2().codes;
    function Ps(e, t, r) {
      let n;
      if (typeof t == "string" || t instanceof Cs)
        return new e({ objectMode: true, ...r, read() {
          this.push(t), this.push(null);
        } });
      let i;
      if (t && t[Vi])
        i = true, n = t[Vi]();
      else if (t && t[Yi])
        i = false, n = t[Yi]();
      else
        throw new Os("iterable", ["Iterable"], t);
      let o2 = new e({ objectMode: true, highWaterMark: 1, ...r }), l3 = false;
      o2._read = function() {
        l3 || (l3 = true, f2());
      }, o2._destroy = function(s3, d4) {
        Ms(u3(s3), () => Hi.nextTick(d4, s3), (c2) => Hi.nextTick(d4, c2 || s3));
      };
      async function u3(s3) {
        let d4 = s3 != null, c2 = typeof n.throw == "function";
        if (d4 && c2) {
          let { value: y4, done: h4 } = await n.throw(s3);
          if (await y4, h4)
            return;
        }
        if (typeof n.return == "function") {
          let { value: y4 } = await n.return();
          await y4;
        }
      }
      async function f2() {
        for (;; ) {
          try {
            let { value: s3, done: d4 } = i ? await n.next() : n.next();
            if (d4)
              o2.push(null);
            else {
              let c2 = s3 && typeof s3.then == "function" ? await s3 : s3;
              if (c2 === null)
                throw l3 = false, new Ds2;
              if (o2.push(c2))
                continue;
              l3 = false;
            }
          } catch (s3) {
            o2.destroy(s3);
          }
          break;
        }
      }
      return o2;
    }
    Ki.exports = Ps;
  });
  Ke = E5((sd, uo) => {
    var $2 = (se(), pe(k4)), { ArrayPrototypeIndexOf: ks, NumberIsInteger: Us, NumberIsNaN: vs2, NumberParseInt: qs, ObjectDefineProperties: Ji, ObjectKeys: Ws2, ObjectSetPrototypeOf: Qi, Promise: $s, SafeSet: js, SymbolAsyncIterator: Gs, Symbol: Hs } = I3();
    uo.exports = g4;
    g4.ReadableState = Ir;
    var { EventEmitter: Vs } = Et(), { Stream: he, prependListener: Ys } = xt(), { Buffer: Sr } = te(), { addAbortSignal: Ks2 } = At2(), zs = ce2(), _5 = V4().debuglog("stream", (e) => {
      _5 = e;
    }), Xs = Pi(), Ue = Se2(), { getHighWaterMark: Js, getDefaultHighWaterMark: Qs } = Tt2(), { aggregateTwoErrors: zi, codes: { ERR_INVALID_ARG_TYPE: Zs, ERR_METHOD_NOT_IMPLEMENTED: ea, ERR_OUT_OF_RANGE: ta, ERR_STREAM_PUSH_AFTER_EOF: ra, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: na } } = C2(), { validateObject: ia } = He(), xe = Hs("kPaused"), { StringDecoder: Zi } = Gi(), oa = Er();
    Qi(g4.prototype, he.prototype);
    Qi(g4, he);
    var mr = () => {
    }, { errorOrDestroy: ke } = Ue;
    function Ir(e, t, r) {
      typeof r != "boolean" && (r = t instanceof J2()), this.objectMode = !!(e && e.objectMode), r && (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)), this.highWaterMark = e ? Js(this, e, "readableHighWaterMark", r) : Qs(false), this.buffer = new Xs, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[xe] = null, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, e && e.encoding && (this.decoder = new Zi(e.encoding), this.encoding = e.encoding);
    }
    function g4(e) {
      if (!(this instanceof g4))
        return new g4(e);
      let t = this instanceof J2();
      this._readableState = new Ir(e, this, t), e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.construct == "function" && (this._construct = e.construct), e.signal && !t && Ks2(e.signal, this)), he.call(this, e), Ue.construct(this, () => {
        this._readableState.needReadable && Lt(this, this._readableState);
      });
    }
    g4.prototype.destroy = Ue.destroy;
    g4.prototype._undestroy = Ue.undestroy;
    g4.prototype._destroy = function(e, t) {
      t(e);
    };
    g4.prototype[Vs.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    g4.prototype.push = function(e, t) {
      return eo(this, e, t, false);
    };
    g4.prototype.unshift = function(e, t) {
      return eo(this, e, t, true);
    };
    function eo(e, t, r, n) {
      _5("readableAddChunk", t);
      let i = e._readableState, o2;
      if (i.objectMode || (typeof t == "string" ? (r = r || i.defaultEncoding, i.encoding !== r && (n && i.encoding ? t = Sr.from(t, r).toString(i.encoding) : (t = Sr.from(t, r), r = ""))) : t instanceof Sr ? r = "" : he._isUint8Array(t) ? (t = he._uint8ArrayToBuffer(t), r = "") : t != null && (o2 = new Zs("chunk", ["string", "Buffer", "Uint8Array"], t))), o2)
        ke(e, o2);
      else if (t === null)
        i.reading = false, fa(e, i);
      else if (i.objectMode || t && t.length > 0)
        if (n)
          if (i.endEmitted)
            ke(e, new na);
          else {
            if (i.destroyed || i.errored)
              return false;
            xr(e, i, t, true);
          }
        else if (i.ended)
          ke(e, new ra);
        else {
          if (i.destroyed || i.errored)
            return false;
          i.reading = false, i.decoder && !r ? (t = i.decoder.write(t), i.objectMode || t.length !== 0 ? xr(e, i, t, false) : Lt(e, i)) : xr(e, i, t, false);
        }
      else
        n || (i.reading = false, Lt(e, i));
      return !i.ended && (i.length < i.highWaterMark || i.length === 0);
    }
    function xr(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0 ? (t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null, t.dataEmitted = true, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && Nt(e)), Lt(e, t);
    }
    g4.prototype.isPaused = function() {
      let e = this._readableState;
      return e[xe] === true || e.flowing === false;
    };
    g4.prototype.setEncoding = function(e) {
      let t = new Zi(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, n = "";
      for (let i of r)
        n += t.write(i);
      return r.clear(), n !== "" && r.push(n), this._readableState.length = n.length, this;
    };
    var la = 1073741824;
    function ua(e) {
      if (e > la)
        throw new ta("size", "<= 1GiB", e);
      return e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++, e;
    }
    function Xi(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : vs2(e) ? t.flowing && t.length ? t.buffer.first().length : t.length : e <= t.length ? e : t.ended ? t.length : 0;
    }
    g4.prototype.read = function(e) {
      _5("read", e), e === undefined ? e = NaN : Us(e) || (e = qs(e, 10));
      let t = this._readableState, r = e;
      if (e > t.highWaterMark && (t.highWaterMark = ua(e)), e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return _5("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Rr2(this) : Nt(this), null;
      if (e = Xi(e, t), e === 0 && t.ended)
        return t.length === 0 && Rr2(this), null;
      let n = t.needReadable;
      if (_5("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, _5("length less than watermark", n)), t.ended || t.reading || t.destroyed || t.errored || !t.constructed)
        n = false, _5("reading, ended or constructing", n);
      else if (n) {
        _5("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true);
        try {
          this._read(t.highWaterMark);
        } catch (o2) {
          ke(this, o2);
        }
        t.sync = false, t.reading || (e = Xi(r, t));
      }
      let i;
      return e > 0 ? i = oo(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && Rr2(this)), i !== null && !t.errorEmitted && !t.closeEmitted && (t.dataEmitted = true, this.emit("data", i)), i;
    };
    function fa(e, t) {
      if (_5("onEofChunk"), !t.ended) {
        if (t.decoder) {
          let r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? Nt(e) : (t.needReadable = false, t.emittedReadable = true, to(e));
      }
    }
    function Nt(e) {
      let t = e._readableState;
      _5("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (_5("emitReadable", t.flowing), t.emittedReadable = true, $2.nextTick(to, e));
    }
    function to(e) {
      let t = e._readableState;
      _5("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && !t.errored && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, no(e);
    }
    function Lt(e, t) {
      !t.readingMore && t.constructed && (t.readingMore = true, $2.nextTick(sa, e, t));
    }
    function sa(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        let r = t.length;
        if (_5("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    g4.prototype._read = function(e) {
      throw new ea("_read()");
    };
    g4.prototype.pipe = function(e, t) {
      let r = this, n = this._readableState;
      n.pipes.length === 1 && (n.multiAwaitDrain || (n.multiAwaitDrain = true, n.awaitDrainWriters = new js(n.awaitDrainWriters ? [n.awaitDrainWriters] : []))), n.pipes.push(e), _5("pipe count=%d opts=%j", n.pipes.length, t);
      let o2 = (!t || t.end !== false) && e !== $2.stdout && e !== $2.stderr ? u3 : v2;
      n.endEmitted ? $2.nextTick(o2) : r.once("end", o2), e.on("unpipe", l3);
      function l3(w2, b4) {
        _5("onunpipe"), w2 === r && b4 && b4.hasUnpiped === false && (b4.hasUnpiped = true, d4());
      }
      function u3() {
        _5("onend"), e.end();
      }
      let f2, s3 = false;
      function d4() {
        _5("cleanup"), e.removeListener("close", p4), e.removeListener("finish", B3), f2 && e.removeListener("drain", f2), e.removeListener("error", h4), e.removeListener("unpipe", l3), r.removeListener("end", u3), r.removeListener("end", v2), r.removeListener("data", y4), s3 = true, f2 && n.awaitDrainWriters && (!e._writableState || e._writableState.needDrain) && f2();
      }
      function c2() {
        s3 || (n.pipes.length === 1 && n.pipes[0] === e ? (_5("false write response, pause", 0), n.awaitDrainWriters = e, n.multiAwaitDrain = false) : n.pipes.length > 1 && n.pipes.includes(e) && (_5("false write response, pause", n.awaitDrainWriters.size), n.awaitDrainWriters.add(e)), r.pause()), f2 || (f2 = aa(r, e), e.on("drain", f2));
      }
      r.on("data", y4);
      function y4(w2) {
        _5("ondata");
        let b4 = e.write(w2);
        _5("dest.write", b4), b4 === false && c2();
      }
      function h4(w2) {
        if (_5("onerror", w2), v2(), e.removeListener("error", h4), e.listenerCount("error") === 0) {
          let b4 = e._writableState || e._readableState;
          b4 && !b4.errorEmitted ? ke(e, w2) : e.emit("error", w2);
        }
      }
      Ys(e, "error", h4);
      function p4() {
        e.removeListener("finish", B3), v2();
      }
      e.once("close", p4);
      function B3() {
        _5("onfinish"), e.removeListener("close", p4), v2();
      }
      e.once("finish", B3);
      function v2() {
        _5("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), e.writableNeedDrain === true ? n.flowing && c2() : n.flowing || (_5("pipe resume"), r.resume()), e;
    };
    function aa(e, t) {
      return function() {
        let n = e._readableState;
        n.awaitDrainWriters === t ? (_5("pipeOnDrain", 1), n.awaitDrainWriters = null) : n.multiAwaitDrain && (_5("pipeOnDrain", n.awaitDrainWriters.size), n.awaitDrainWriters.delete(t)), (!n.awaitDrainWriters || n.awaitDrainWriters.size === 0) && e.listenerCount("data") && e.resume();
      };
    }
    g4.prototype.unpipe = function(e) {
      let t = this._readableState, r = { hasUnpiped: false };
      if (t.pipes.length === 0)
        return this;
      if (!e) {
        let i = t.pipes;
        t.pipes = [], this.pause();
        for (let o2 = 0;o2 < i.length; o2++)
          i[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let n = ks(t.pipes, e);
      return n === -1 ? this : (t.pipes.splice(n, 1), t.pipes.length === 0 && this.pause(), e.emit("unpipe", this, r), this);
    };
    g4.prototype.on = function(e, t) {
      let r = he.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, _5("on readable", n.length, n.reading), n.length ? Nt(this) : n.reading || $2.nextTick(ca, this)), r;
    };
    g4.prototype.addListener = g4.prototype.on;
    g4.prototype.removeListener = function(e, t) {
      let r = he.prototype.removeListener.call(this, e, t);
      return e === "readable" && $2.nextTick(ro, this), r;
    };
    g4.prototype.off = g4.prototype.removeListener;
    g4.prototype.removeAllListeners = function(e) {
      let t = he.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && $2.nextTick(ro, this), t;
    };
    function ro(e) {
      let t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && t[xe] === false ? t.flowing = true : e.listenerCount("data") > 0 ? e.resume() : t.readableListening || (t.flowing = null);
    }
    function ca(e) {
      _5("readable nexttick read 0"), e.read(0);
    }
    g4.prototype.resume = function() {
      let e = this._readableState;
      return e.flowing || (_5("resume"), e.flowing = !e.readableListening, da(this, e)), e[xe] = false, this;
    };
    function da(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, $2.nextTick(ha, e, t));
    }
    function ha(e, t) {
      _5("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), no(e), t.flowing && !t.reading && e.read(0);
    }
    g4.prototype.pause = function() {
      return _5("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (_5("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[xe] = true, this;
    };
    function no(e) {
      let t = e._readableState;
      for (_5("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    g4.prototype.wrap = function(e) {
      let t = false;
      e.on("data", (n) => {
        !this.push(n) && e.pause && (t = true, e.pause());
      }), e.on("end", () => {
        this.push(null);
      }), e.on("error", (n) => {
        ke(this, n);
      }), e.on("close", () => {
        this.destroy();
      }), e.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        t && e.resume && (t = false, e.resume());
      };
      let r = Ws2(e);
      for (let n = 1;n < r.length; n++) {
        let i = r[n];
        this[i] === undefined && typeof e[i] == "function" && (this[i] = e[i].bind(e));
      }
      return this;
    };
    g4.prototype[Gs] = function() {
      return io(this);
    };
    g4.prototype.iterator = function(e) {
      return e !== undefined && ia(e, "options"), io(this, e);
    };
    function io(e, t) {
      typeof e.read != "function" && (e = g4.wrap(e, { objectMode: true }));
      let r = pa2(e, t);
      return r.stream = e, r;
    }
    async function* pa2(e, t) {
      let r = mr;
      function n(l3) {
        this === e ? (r(), r = mr) : r = l3;
      }
      e.on("readable", n);
      let i, o2 = zs(e, { writable: false }, (l3) => {
        i = l3 ? zi(i, l3) : null, r(), r = mr;
      });
      try {
        for (;; ) {
          let l3 = e.destroyed ? null : e.read();
          if (l3 !== null)
            yield l3;
          else {
            if (i)
              throw i;
            if (i === null)
              return;
            await new $s(n);
          }
        }
      } catch (l3) {
        throw i = zi(i, l3), i;
      } finally {
        (i || t?.destroyOnReturn !== false) && (i === undefined || e._readableState.autoDestroy) ? Ue.destroyer(e, null) : (e.off("readable", n), o2());
      }
    }
    Ji(g4.prototype, { readable: { __proto__: null, get() {
      let e = this._readableState;
      return !!e && e.readable !== false && !e.destroyed && !e.errorEmitted && !e.endEmitted;
    }, set(e) {
      this._readableState && (this._readableState.readable = !!e);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    Ji(Ir.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[xe] !== false;
    }, set(e) {
      this[xe] = !!e;
    } } });
    g4._fromList = oo;
    function oo(e, t) {
      if (t.length === 0)
        return null;
      let r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function Rr2(e) {
      let t = e._readableState;
      _5("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, $2.nextTick(ya, t, e));
    }
    function ya(e, t) {
      if (_5("endReadableNT", e.endEmitted, e.length), !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
        if (e.endEmitted = true, t.emit("end"), t.writable && t.allowHalfOpen === false)
          $2.nextTick(wa, t);
        else if (e.autoDestroy) {
          let r = t._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && t.destroy();
        }
      }
    }
    function wa(e) {
      e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    g4.from = function(e, t) {
      return oa(g4, e, t);
    };
    var Ar;
    function lo() {
      return Ar === undefined && (Ar = {}), Ar;
    }
    g4.fromWeb = function(e, t) {
      return lo().newStreamReadableFromReadableStream(e, t);
    };
    g4.toWeb = function(e, t) {
      return lo().newReadableStreamFromStreamReadable(e, t);
    };
    g4.wrap = function(e, t) {
      var r, n;
      return new g4({ objectMode: (r = (n = e.readableObjectMode) !== null && n !== undefined ? n : e.objectMode) !== null && r !== undefined ? r : true, ...t, destroy(i, o2) {
        Ue.destroyer(e, i), o2(i);
      } }).wrap(e);
    };
  });
  Cr2 = E5((ad, Eo) => {
    var Re = (se(), pe(k4)), { ArrayPrototypeSlice: ao, Error: ba2, FunctionPrototypeSymbolHasInstance: co2, ObjectDefineProperty: ho, ObjectDefineProperties: ga, ObjectSetPrototypeOf: po2, StringPrototypeToLowerCase: _a, Symbol: Ea, SymbolHasInstance: Sa } = I3();
    Eo.exports = m4;
    m4.WritableState = Je;
    var { EventEmitter: ma } = Et(), ze = xt().Stream, { Buffer: Ft } = te(), Ot = Se2(), { addAbortSignal: xa } = At2(), { getHighWaterMark: Ra, getDefaultHighWaterMark: Aa2 } = Tt2(), { ERR_INVALID_ARG_TYPE: Ia, ERR_METHOD_NOT_IMPLEMENTED: Ta, ERR_MULTIPLE_CALLBACK: yo, ERR_STREAM_CANNOT_PIPE: Ba2, ERR_STREAM_DESTROYED: Xe, ERR_STREAM_ALREADY_FINISHED: La, ERR_STREAM_NULL_VALUES: Na, ERR_STREAM_WRITE_AFTER_END: Fa, ERR_UNKNOWN_ENCODING: wo } = C2().codes, { errorOrDestroy: ve } = Ot;
    po2(m4.prototype, ze.prototype);
    po2(m4, ze);
    function Lr() {
    }
    var qe2 = Ea("kOnFinished");
    function Je(e, t, r) {
      typeof r != "boolean" && (r = t instanceof J2()), this.objectMode = !!(e && e.objectMode), r && (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)), this.highWaterMark = e ? Ra(this, e, "writableHighWaterMark", r) : Aa2(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let n = !!(e && e.decodeStrings === false);
      this.decodeStrings = !n, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = Ca.bind(undefined, t), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, Ct(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[qe2] = [];
    }
    function Ct(e) {
      e.buffered = [], e.bufferedIndex = 0, e.allBuffers = true, e.allNoop = true;
    }
    Je.prototype.getBuffer = function() {
      return ao(this.buffered, this.bufferedIndex);
    };
    ho(Je.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function m4(e) {
      let t = this instanceof J2();
      if (!t && !co2(m4, this))
        return new m4(e);
      this._writableState = new Je(e, this, t), e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final), typeof e.construct == "function" && (this._construct = e.construct), e.signal && xa(e.signal, this)), ze.call(this, e), Ot.construct(this, () => {
        let r = this._writableState;
        r.writing || Fr2(this, r), Mr(this, r);
      });
    }
    ho(m4, Sa, { __proto__: null, value: function(e) {
      return co2(this, e) ? true : this !== m4 ? false : e && e._writableState instanceof Je;
    } });
    m4.prototype.pipe = function() {
      ve(this, new Ba2);
    };
    function bo(e, t, r, n) {
      let i = e._writableState;
      if (typeof r == "function")
        n = r, r = i.defaultEncoding;
      else {
        if (!r)
          r = i.defaultEncoding;
        else if (r !== "buffer" && !Ft.isEncoding(r))
          throw new wo(r);
        typeof n != "function" && (n = Lr);
      }
      if (t === null)
        throw new Na;
      if (!i.objectMode)
        if (typeof t == "string")
          i.decodeStrings !== false && (t = Ft.from(t, r), r = "buffer");
        else if (t instanceof Ft)
          r = "buffer";
        else if (ze._isUint8Array(t))
          t = ze._uint8ArrayToBuffer(t), r = "buffer";
        else
          throw new Ia("chunk", ["string", "Buffer", "Uint8Array"], t);
      let o2;
      return i.ending ? o2 = new Fa : i.destroyed && (o2 = new Xe("write")), o2 ? (Re.nextTick(n, o2), ve(e, o2, true), o2) : (i.pendingcb++, Ma(e, i, t, r, n));
    }
    m4.prototype.write = function(e, t, r) {
      return bo(this, e, t, r) === true;
    };
    m4.prototype.cork = function() {
      this._writableState.corked++;
    };
    m4.prototype.uncork = function() {
      let e = this._writableState;
      e.corked && (e.corked--, e.writing || Fr2(this, e));
    };
    m4.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = _a(t)), !Ft.isEncoding(t))
        throw new wo(t);
      return this._writableState.defaultEncoding = t, this;
    };
    function Ma(e, t, r, n, i) {
      let o2 = t.objectMode ? 1 : r.length;
      t.length += o2;
      let l3 = t.length < t.highWaterMark;
      return l3 || (t.needDrain = true), t.writing || t.corked || t.errored || !t.constructed ? (t.buffered.push({ chunk: r, encoding: n, callback: i }), t.allBuffers && n !== "buffer" && (t.allBuffers = false), t.allNoop && i !== Lr && (t.allNoop = false)) : (t.writelen = o2, t.writecb = i, t.writing = true, t.sync = true, e._write(r, n, t.onwrite), t.sync = false), l3 && !t.errored && !t.destroyed;
    }
    function fo(e, t, r, n, i, o2, l3) {
      t.writelen = n, t.writecb = l3, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new Xe("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o2, t.onwrite), t.sync = false;
    }
    function so2(e, t, r, n) {
      --t.pendingcb, n(r), Nr(t), ve(e, r);
    }
    function Ca(e, t) {
      let r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function") {
        ve(e, new yo);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, t ? (t.stack, r.errored || (r.errored = t), e._readableState && !e._readableState.errored && (e._readableState.errored = t), n ? Re.nextTick(so2, e, r, t, i) : so2(e, r, t, i)) : (r.buffered.length > r.bufferedIndex && Fr2(e, r), n ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === i ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: i, stream: e, state: r }, Re.nextTick(Oa2, r.afterWriteTickInfo)) : go(e, r, 1, i));
    }
    function Oa2({ stream: e, state: t, count: r, cb: n }) {
      return t.afterWriteTickInfo = null, go(e, t, r, n);
    }
    function go(e, t, r, n) {
      for (!t.ending && !e.destroyed && t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));r-- > 0; )
        t.pendingcb--, n();
      t.destroyed && Nr(t), Mr(e, t);
    }
    function Nr(e) {
      if (e.writing)
        return;
      for (let i = e.bufferedIndex;i < e.buffered.length; ++i) {
        var t;
        let { chunk: o2, callback: l3 } = e.buffered[i], u3 = e.objectMode ? 1 : o2.length;
        e.length -= u3, l3((t = e.errored) !== null && t !== undefined ? t : new Xe("write"));
      }
      let r = e[qe2].splice(0);
      for (let i = 0;i < r.length; i++) {
        var n;
        r[i]((n = e.errored) !== null && n !== undefined ? n : new Xe("end"));
      }
      Ct(e);
    }
    function Fr2(e, t) {
      if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed)
        return;
      let { buffered: r, bufferedIndex: n, objectMode: i } = t, o2 = r.length - n;
      if (!o2)
        return;
      let l3 = n;
      if (t.bufferProcessing = true, o2 > 1 && e._writev) {
        t.pendingcb -= o2 - 1;
        let u3 = t.allNoop ? Lr : (s3) => {
          for (let d4 = l3;d4 < r.length; ++d4)
            r[d4].callback(s3);
        }, f2 = t.allNoop && l3 === 0 ? r : ao(r, l3);
        f2.allBuffers = t.allBuffers, fo(e, t, true, t.length, f2, "", u3), Ct(t);
      } else {
        do {
          let { chunk: u3, encoding: f2, callback: s3 } = r[l3];
          r[l3++] = null;
          let d4 = i ? 1 : u3.length;
          fo(e, t, false, d4, u3, f2, s3);
        } while (l3 < r.length && !t.writing);
        l3 === r.length ? Ct(t) : l3 > 256 ? (r.splice(0, l3), t.bufferedIndex = 0) : t.bufferedIndex = l3;
      }
      t.bufferProcessing = false;
    }
    m4.prototype._write = function(e, t, r) {
      if (this._writev)
        this._writev([{ chunk: e, encoding: t }], r);
      else
        throw new Ta("_write()");
    };
    m4.prototype._writev = null;
    m4.prototype.end = function(e, t, r) {
      let n = this._writableState;
      typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null);
      let i;
      if (e != null) {
        let o2 = bo(this, e, t);
        o2 instanceof ba2 && (i = o2);
      }
      return n.corked && (n.corked = 1, this.uncork()), i || (!n.errored && !n.ending ? (n.ending = true, Mr(this, n, true), n.ended = true) : n.finished ? i = new La("end") : n.destroyed && (i = new Xe("end"))), typeof r == "function" && (i || n.finished ? Re.nextTick(r, i) : n[qe2].push(r)), this;
    };
    function Mt(e) {
      return e.ending && !e.destroyed && e.constructed && e.length === 0 && !e.errored && e.buffered.length === 0 && !e.finished && !e.writing && !e.errorEmitted && !e.closeEmitted;
    }
    function Da(e, t) {
      let r = false;
      function n(i) {
        if (r) {
          ve(e, i ?? yo());
          return;
        }
        if (r = true, t.pendingcb--, i) {
          let o2 = t[qe2].splice(0);
          for (let l3 = 0;l3 < o2.length; l3++)
            o2[l3](i);
          ve(e, i, t.sync);
        } else
          Mt(t) && (t.prefinished = true, e.emit("prefinish"), t.pendingcb++, Re.nextTick(Br2, e, t));
      }
      t.sync = true, t.pendingcb++;
      try {
        e._final(n);
      } catch (i) {
        n(i);
      }
      t.sync = false;
    }
    function Pa(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.finalCalled = true, Da(e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Mr(e, t, r) {
      Mt(t) && (Pa(e, t), t.pendingcb === 0 && (r ? (t.pendingcb++, Re.nextTick((n, i) => {
        Mt(i) ? Br2(n, i) : i.pendingcb--;
      }, e, t)) : Mt(t) && (t.pendingcb++, Br2(e, t))));
    }
    function Br2(e, t) {
      t.pendingcb--, t.finished = true;
      let r = t[qe2].splice(0);
      for (let n = 0;n < r.length; n++)
        r[n]();
      if (e.emit("finish"), t.autoDestroy) {
        let n = e._readableState;
        (!n || n.autoDestroy && (n.endEmitted || n.readable === false)) && e.destroy();
      }
    }
    ga(m4.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(e) {
      this._writableState && (this._writableState.destroyed = e);
    } }, writable: { __proto__: null, get() {
      let e = this._writableState;
      return !!e && e.writable !== false && !e.destroyed && !e.errored && !e.ending && !e.ended;
    }, set(e) {
      this._writableState && (this._writableState.writable = !!e);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let e = this._writableState;
      return e ? !e.destroyed && !e.ending && e.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var ka = Ot.destroy;
    m4.prototype.destroy = function(e, t) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[qe2].length) && Re.nextTick(Nr, r), ka.call(this, e, t), this;
    };
    m4.prototype._undestroy = Ot.undestroy;
    m4.prototype._destroy = function(e, t) {
      t(e);
    };
    m4.prototype[ma.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    var Tr;
    function _o() {
      return Tr === undefined && (Tr = {}), Tr;
    }
    m4.fromWeb = function(e, t) {
      return _o().newStreamWritableFromWritableStream(e, t);
    };
    m4.toWeb = function(e) {
      return _o().newWritableStreamFromStreamWritable(e);
    };
  });
  Mo = E5((cd2, Fo) => {
    var Or = (se(), pe(k4)), Ua = te(), { isReadable: va, isWritable: qa, isIterable: So, isNodeStream: Wa, isReadableNodeStream: mo, isWritableNodeStream: xo, isDuplexNodeStream: $a } = ae(), Ro = ce2(), { AbortError: No2, codes: { ERR_INVALID_ARG_TYPE: ja, ERR_INVALID_RETURN_VALUE: Ao2 } } = C2(), { destroyer: We } = Se2(), Ga2 = J2(), Ha2 = Ke(), { createDeferredPromise: Io } = V4(), To = Er(), Bo2 = globalThis.Blob || Ua.Blob, Va = typeof Bo2 < "u" ? function(t) {
      return t instanceof Bo2;
    } : function(t) {
      return false;
    }, Ya2 = globalThis.AbortController || ut().AbortController, { FunctionPrototypeCall: Lo } = I3(), Ae2 = class extends Ga2 {
      constructor(t) {
        super(t), t?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Fo.exports = function e(t, r) {
      if ($a(t))
        return t;
      if (mo(t))
        return Dt({ readable: t });
      if (xo(t))
        return Dt({ writable: t });
      if (Wa(t))
        return Dt({ writable: false, readable: false });
      if (typeof t == "function") {
        let { value: i, write: o2, final: l3, destroy: u3 } = Ka(t);
        if (So(i))
          return To(Ae2, i, { objectMode: true, write: o2, final: l3, destroy: u3 });
        let f2 = i?.then;
        if (typeof f2 == "function") {
          let s3, d4 = Lo(f2, i, (c2) => {
            if (c2 != null)
              throw new Ao2("nully", "body", c2);
          }, (c2) => {
            We(s3, c2);
          });
          return s3 = new Ae2({ objectMode: true, readable: false, write: o2, final(c2) {
            l3(async () => {
              try {
                await d4, Or.nextTick(c2, null);
              } catch (y4) {
                Or.nextTick(c2, y4);
              }
            });
          }, destroy: u3 });
        }
        throw new Ao2("Iterable, AsyncIterable or AsyncFunction", r, i);
      }
      if (Va(t))
        return e(t.arrayBuffer());
      if (So(t))
        return To(Ae2, t, { objectMode: true, writable: false });
      if (typeof t?.writable == "object" || typeof t?.readable == "object") {
        let i = t != null && t.readable ? mo(t?.readable) ? t?.readable : e(t.readable) : undefined, o2 = t != null && t.writable ? xo(t?.writable) ? t?.writable : e(t.writable) : undefined;
        return Dt({ readable: i, writable: o2 });
      }
      let n = t?.then;
      if (typeof n == "function") {
        let i;
        return Lo(n, t, (o2) => {
          o2 != null && i.push(o2), i.push(null);
        }, (o2) => {
          We(i, o2);
        }), i = new Ae2({ objectMode: true, writable: false, read() {
        } });
      }
      throw new ja(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], t);
    };
    function Ka(e) {
      let { promise: t, resolve: r } = Io(), n = new Ya2, i = n.signal;
      return { value: e(async function* () {
        for (;; ) {
          let l3 = t;
          t = null;
          let { chunk: u3, done: f2, cb: s3 } = await l3;
          if (Or.nextTick(s3), f2)
            return;
          if (i.aborted)
            throw new No2(undefined, { cause: i.reason });
          ({ promise: t, resolve: r } = Io()), yield u3;
        }
      }(), { signal: i }), write(l3, u3, f2) {
        let s3 = r;
        r = null, s3({ chunk: l3, done: false, cb: f2 });
      }, final(l3) {
        let u3 = r;
        r = null, u3({ done: true, cb: l3 });
      }, destroy(l3, u3) {
        n.abort(), u3(l3);
      } };
    }
    function Dt(e) {
      let t = e.readable && typeof e.readable.read != "function" ? Ha2.wrap(e.readable) : e.readable, r = e.writable, n = !!va(t), i = !!qa(r), o2, l3, u3, f2, s3;
      function d4(c2) {
        let y4 = f2;
        f2 = null, y4 ? y4(c2) : c2 ? s3.destroy(c2) : !n && !i && s3.destroy();
      }
      return s3 = new Ae2({ readableObjectMode: !!(t != null && t.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: n, writable: i }), i && (Ro(r, (c2) => {
        i = false, c2 && We(t, c2), d4(c2);
      }), s3._write = function(c2, y4, h4) {
        r.write(c2, y4) ? h4() : o2 = h4;
      }, s3._final = function(c2) {
        r.end(), l3 = c2;
      }, r.on("drain", function() {
        if (o2) {
          let c2 = o2;
          o2 = null, c2();
        }
      }), r.on("finish", function() {
        if (l3) {
          let c2 = l3;
          l3 = null, c2();
        }
      })), n && (Ro(t, (c2) => {
        n = false, c2 && We(t, c2), d4(c2);
      }), t.on("readable", function() {
        if (u3) {
          let c2 = u3;
          u3 = null, c2();
        }
      }), t.on("end", function() {
        s3.push(null);
      }), s3._read = function() {
        for (;; ) {
          let c2 = t.read();
          if (c2 === null) {
            u3 = s3._read;
            return;
          }
          if (!s3.push(c2))
            return;
        }
      }), s3._destroy = function(c2, y4) {
        !c2 && f2 !== null && (c2 = new No2), u3 = null, o2 = null, l3 = null, f2 === null ? y4(c2) : (f2 = y4, We(r, c2), We(t, c2));
      }, s3;
    }
  });
  J2 = E5((dd2, Do) => {
    var { ObjectDefineProperties: za, ObjectGetOwnPropertyDescriptor: ie, ObjectKeys: Xa2, ObjectSetPrototypeOf: Co } = I3();
    Do.exports = j5;
    var kr = Ke(), U3 = Cr2();
    Co(j5.prototype, kr.prototype);
    Co(j5, kr);
    {
      let e = Xa2(U3.prototype);
      for (let t = 0;t < e.length; t++) {
        let r = e[t];
        j5.prototype[r] || (j5.prototype[r] = U3.prototype[r]);
      }
    }
    function j5(e) {
      if (!(this instanceof j5))
        return new j5(e);
      kr.call(this, e), U3.call(this, e), e ? (this.allowHalfOpen = e.allowHalfOpen !== false, e.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    za(j5.prototype, { writable: { __proto__: null, ...ie(U3.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ie(U3.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ie(U3.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ie(U3.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ie(U3.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ie(U3.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ie(U3.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ie(U3.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ie(U3.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(e) {
      this._readableState && this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } } });
    var Dr;
    function Oo() {
      return Dr === undefined && (Dr = {}), Dr;
    }
    j5.fromWeb = function(e, t) {
      return Oo().newStreamDuplexFromReadableWritablePair(e, t);
    };
    j5.toWeb = function(e) {
      return Oo().newReadableWritablePairFromDuplex(e);
    };
    var Pr;
    j5.from = function(e) {
      return Pr || (Pr = Mo()), Pr(e, "body");
    };
  });
  qr = E5((hd2, ko2) => {
    var { ObjectSetPrototypeOf: Po, Symbol: Ja2 } = I3();
    ko2.exports = oe;
    var { ERR_METHOD_NOT_IMPLEMENTED: Qa } = C2().codes, vr = J2(), { getHighWaterMark: Za } = Tt2();
    Po(oe.prototype, vr.prototype);
    Po(oe, vr);
    var Qe = Ja2("kCallback");
    function oe(e) {
      if (!(this instanceof oe))
        return new oe(e);
      let t = e ? Za(this, e, "readableHighWaterMark", true) : null;
      t === 0 && (e = { ...e, highWaterMark: null, readableHighWaterMark: t, writableHighWaterMark: e.writableHighWaterMark || 0 }), vr.call(this, e), this._readableState.sync = false, this[Qe] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ec);
    }
    function Ur2(e) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
        if (t) {
          e ? e(t) : this.destroy(t);
          return;
        }
        r != null && this.push(r), this.push(null), e && e();
      }) : (this.push(null), e && e());
    }
    function ec() {
      this._final !== Ur2 && Ur2.call(this);
    }
    oe.prototype._final = Ur2;
    oe.prototype._transform = function(e, t, r) {
      throw new Qa("_transform()");
    };
    oe.prototype._write = function(e, t, r) {
      let n = this._readableState, i = this._writableState, o2 = n.length;
      this._transform(e, t, (l3, u3) => {
        if (l3) {
          r(l3);
          return;
        }
        u3 != null && this.push(u3), i.ended || o2 === n.length || n.length < n.highWaterMark ? r() : this[Qe] = r;
      });
    };
    oe.prototype._read = function() {
      if (this[Qe]) {
        let e = this[Qe];
        this[Qe] = null, e();
      }
    };
  });
  $r = E5((pd, vo2) => {
    var { ObjectSetPrototypeOf: Uo } = I3();
    vo2.exports = $e;
    var Wr = qr();
    Uo($e.prototype, Wr.prototype);
    Uo($e, Wr);
    function $e(e) {
      if (!(this instanceof $e))
        return new $e(e);
      Wr.call(this, e);
    }
    $e.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  Ut2 = E5((yd, Vo2) => {
    var Pt = (se(), pe(k4)), { ArrayIsArray: tc, Promise: rc, SymbolAsyncIterator: nc } = I3(), kt = ce2(), { once: ic } = V4(), oc = Se2(), qo = J2(), { aggregateTwoErrors: lc, codes: { ERR_INVALID_ARG_TYPE: Go2, ERR_INVALID_RETURN_VALUE: jr, ERR_MISSING_ARGS: uc, ERR_STREAM_DESTROYED: fc, ERR_STREAM_PREMATURE_CLOSE: sc }, AbortError: ac } = C2(), { validateFunction: cc, validateAbortSignal: dc } = He(), { isIterable: je, isReadable: Gr2, isReadableNodeStream: Yr, isNodeStream: Wo } = ae(), hc = globalThis.AbortController || ut().AbortController, Hr, Vr;
    function $o(e, t, r) {
      let n = false;
      e.on("close", () => {
        n = true;
      });
      let i = kt(e, { readable: t, writable: r }, (o2) => {
        n = !o2;
      });
      return { destroy: (o2) => {
        n || (n = true, oc.destroyer(e, o2 || new fc("pipe")));
      }, cleanup: i };
    }
    function pc2(e) {
      return cc(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
    }
    function yc(e) {
      if (je(e))
        return e;
      if (Yr(e))
        return wc(e);
      throw new Go2("val", ["Readable", "Iterable", "AsyncIterable"], e);
    }
    async function* wc(e) {
      Vr || (Vr = Ke()), yield* Vr.prototype[nc].call(e);
    }
    async function jo(e, t, r, { end: n }) {
      let i, o2 = null, l3 = (s3) => {
        if (s3 && (i = s3), o2) {
          let d4 = o2;
          o2 = null, d4();
        }
      }, u3 = () => new rc((s3, d4) => {
        i ? d4(i) : o2 = () => {
          i ? d4(i) : s3();
        };
      });
      t.on("drain", l3);
      let f2 = kt(t, { readable: false }, l3);
      try {
        t.writableNeedDrain && await u3();
        for await (let s3 of e)
          t.write(s3) || await u3();
        n && t.end(), await u3(), r();
      } catch (s3) {
        r(i !== s3 ? lc(i, s3) : s3);
      } finally {
        f2(), t.off("drain", l3);
      }
    }
    function bc(...e) {
      return Ho(e, ic(pc2(e)));
    }
    function Ho(e, t, r) {
      if (e.length === 1 && tc(e[0]) && (e = e[0]), e.length < 2)
        throw new uc("streams");
      let n = new hc, i = n.signal, o2 = r?.signal, l3 = [];
      dc(o2, "options.signal");
      function u3() {
        h4(new ac);
      }
      o2?.addEventListener("abort", u3);
      let f2, s3, d4 = [], c2 = 0;
      function y4(w2) {
        h4(w2, --c2 === 0);
      }
      function h4(w2, b4) {
        if (w2 && (!f2 || f2.code === "ERR_STREAM_PREMATURE_CLOSE") && (f2 = w2), !(!f2 && !b4)) {
          for (;d4.length; )
            d4.shift()(f2);
          o2?.removeEventListener("abort", u3), n.abort(), b4 && (f2 || l3.forEach((L4) => L4()), Pt.nextTick(t, f2, s3));
        }
      }
      let p4;
      for (let w2 = 0;w2 < e.length; w2++) {
        let b4 = e[w2], L4 = w2 < e.length - 1, N5 = w2 > 0, Q3 = L4 || r?.end !== false, Ie2 = w2 === e.length - 1;
        if (Wo(b4)) {
          let q2 = function(Z3) {
            Z3 && Z3.name !== "AbortError" && Z3.code !== "ERR_STREAM_PREMATURE_CLOSE" && y4(Z3);
          };
          var v2 = q2;
          if (Q3) {
            let { destroy: Z3, cleanup: qt } = $o(b4, L4, N5);
            d4.push(Z3), Gr2(b4) && Ie2 && l3.push(qt);
          }
          b4.on("error", q2), Gr2(b4) && Ie2 && l3.push(() => {
            b4.removeListener("error", q2);
          });
        }
        if (w2 === 0)
          if (typeof b4 == "function") {
            if (p4 = b4({ signal: i }), !je(p4))
              throw new jr("Iterable, AsyncIterable or Stream", "source", p4);
          } else
            je(b4) || Yr(b4) ? p4 = b4 : p4 = qo.from(b4);
        else if (typeof b4 == "function")
          if (p4 = yc(p4), p4 = b4(p4, { signal: i }), L4) {
            if (!je(p4, true))
              throw new jr("AsyncIterable", `transform[${w2 - 1}]`, p4);
          } else {
            var B3;
            Hr || (Hr = $r());
            let q2 = new Hr({ objectMode: true }), Z3 = (B3 = p4) === null || B3 === undefined ? undefined : B3.then;
            if (typeof Z3 == "function")
              c2++, Z3.call(p4, (Te2) => {
                s3 = Te2, Te2 != null && q2.write(Te2), Q3 && q2.end(), Pt.nextTick(y4);
              }, (Te2) => {
                q2.destroy(Te2), Pt.nextTick(y4, Te2);
              });
            else if (je(p4, true))
              c2++, jo(p4, q2, y4, { end: Q3 });
            else
              throw new jr("AsyncIterable or Promise", "destination", p4);
            p4 = q2;
            let { destroy: qt, cleanup: sl } = $o(p4, false, true);
            d4.push(qt), Ie2 && l3.push(sl);
          }
        else if (Wo(b4)) {
          if (Yr(p4)) {
            c2 += 2;
            let q2 = gc(p4, b4, y4, { end: Q3 });
            Gr2(b4) && Ie2 && l3.push(q2);
          } else if (je(p4))
            c2++, jo(p4, b4, y4, { end: Q3 });
          else
            throw new Go2("val", ["Readable", "Iterable", "AsyncIterable"], p4);
          p4 = b4;
        } else
          p4 = qo.from(b4);
      }
      return (i != null && i.aborted || o2 != null && o2.aborted) && Pt.nextTick(u3), p4;
    }
    function gc(e, t, r, { end: n }) {
      let i = false;
      return t.on("close", () => {
        i || r(new sc);
      }), e.pipe(t, { end: n }), n ? e.once("end", () => {
        i = true, t.end();
      }) : r(), kt(e, { readable: true, writable: false }, (o2) => {
        let l3 = e._readableState;
        o2 && o2.code === "ERR_STREAM_PREMATURE_CLOSE" && l3 && l3.ended && !l3.errored && !l3.errorEmitted ? e.once("end", r).once("error", r) : r(o2);
      }), kt(t, { readable: false, writable: true }, r);
    }
    Vo2.exports = { pipelineImpl: Ho, pipeline: bc };
  });
  Jo = E5((wd, Xo2) => {
    var { pipeline: _c } = Ut2(), vt = J2(), { destroyer: Ec } = Se2(), { isNodeStream: Sc, isReadable: Yo, isWritable: Ko } = ae(), { AbortError: mc, codes: { ERR_INVALID_ARG_VALUE: zo, ERR_MISSING_ARGS: xc } } = C2();
    Xo2.exports = function(...t) {
      if (t.length === 0)
        throw new xc("streams");
      if (t.length === 1)
        return vt.from(t[0]);
      let r = [...t];
      if (typeof t[0] == "function" && (t[0] = vt.from(t[0])), typeof t[t.length - 1] == "function") {
        let h4 = t.length - 1;
        t[h4] = vt.from(t[h4]);
      }
      for (let h4 = 0;h4 < t.length; ++h4)
        if (!!Sc(t[h4])) {
          if (h4 < t.length - 1 && !Yo(t[h4]))
            throw new zo(`streams[${h4}]`, r[h4], "must be readable");
          if (h4 > 0 && !Ko(t[h4]))
            throw new zo(`streams[${h4}]`, r[h4], "must be writable");
        }
      let n, i, o2, l3, u3;
      function f2(h4) {
        let p4 = l3;
        l3 = null, p4 ? p4(h4) : h4 ? u3.destroy(h4) : !y4 && !c2 && u3.destroy();
      }
      let s3 = t[0], d4 = _c(t, f2), c2 = !!Ko(s3), y4 = !!Yo(d4);
      return u3 = new vt({ writableObjectMode: !!(s3 != null && s3.writableObjectMode), readableObjectMode: !!(d4 != null && d4.writableObjectMode), writable: c2, readable: y4 }), c2 && (u3._write = function(h4, p4, B3) {
        s3.write(h4, p4) ? B3() : n = B3;
      }, u3._final = function(h4) {
        s3.end(), i = h4;
      }, s3.on("drain", function() {
        if (n) {
          let h4 = n;
          n = null, h4();
        }
      }), d4.on("finish", function() {
        if (i) {
          let h4 = i;
          i = null, h4();
        }
      })), y4 && (d4.on("readable", function() {
        if (o2) {
          let h4 = o2;
          o2 = null, h4();
        }
      }), d4.on("end", function() {
        u3.push(null);
      }), u3._read = function() {
        for (;; ) {
          let h4 = d4.read();
          if (h4 === null) {
            o2 = u3._read;
            return;
          }
          if (!u3.push(h4))
            return;
        }
      }), u3._destroy = function(h4, p4) {
        !h4 && l3 !== null && (h4 = new mc), o2 = null, n = null, i = null, l3 === null ? p4(h4) : (l3 = p4, Ec(d4, h4));
      }, u3;
    };
  });
  Kr2 = E5((bd2, Qo) => {
    var { ArrayPrototypePop: Rc, Promise: Ac } = I3(), { isIterable: Ic, isNodeStream: Tc } = ae(), { pipelineImpl: Bc } = Ut2(), { finished: Lc } = ce2();
    function Nc(...e) {
      return new Ac((t, r) => {
        let n, i, o2 = e[e.length - 1];
        if (o2 && typeof o2 == "object" && !Tc(o2) && !Ic(o2)) {
          let l3 = Rc(e);
          n = l3.signal, i = l3.end;
        }
        Bc(e, (l3, u3) => {
          l3 ? r(l3) : t(u3);
        }, { signal: n, end: i });
      });
    }
    Qo.exports = { finished: Lc, pipeline: Nc };
  });
  fl = E5((gd, ul) => {
    var { Buffer: Fc } = te(), { ObjectDefineProperty: le, ObjectKeys: tl2, ReflectApply: rl } = I3(), { promisify: { custom: nl } } = V4(), { streamReturningOperators: Zo, promiseReturningOperators: el } = di(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: il } } = C2(), Mc = Jo(), { pipeline: ol2 } = Ut2(), { destroyer: Cc } = Se2(), ll = ce2(), zr = Kr2(), Xr = ae(), R3 = ul.exports = xt().Stream;
    R3.isDisturbed = Xr.isDisturbed;
    R3.isErrored = Xr.isErrored;
    R3.isReadable = Xr.isReadable;
    R3.Readable = Ke();
    for (let e of tl2(Zo)) {
      let r = function(...n) {
        if (new.target)
          throw il();
        return R3.Readable.from(rl(t, this, n));
      };
      Dc = r;
      let t = Zo[e];
      le(r, "name", { __proto__: null, value: t.name }), le(r, "length", { __proto__: null, value: t.length }), le(R3.Readable.prototype, e, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var Dc;
    for (let e of tl2(el)) {
      let r = function(...i) {
        if (new.target)
          throw il();
        return rl(t, this, i);
      };
      Dc = r;
      let t = el[e];
      le(r, "name", { __proto__: null, value: t.name }), le(r, "length", { __proto__: null, value: t.length }), le(R3.Readable.prototype, e, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var Dc;
    R3.Writable = Cr2();
    R3.Duplex = J2();
    R3.Transform = qr();
    R3.PassThrough = $r();
    R3.pipeline = ol2;
    var { addAbortSignal: Oc2 } = At2();
    R3.addAbortSignal = Oc2;
    R3.finished = ll;
    R3.destroy = Cc;
    R3.compose = Mc;
    le(R3, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return zr;
    } });
    le(ol2, nl, { __proto__: null, enumerable: true, get() {
      return zr.pipeline;
    } });
    le(ll, nl, { __proto__: null, enumerable: true, get() {
      return zr.finished;
    } });
    R3.Stream = R3;
    R3._isUint8Array = function(t) {
      return t instanceof Uint8Array;
    };
    R3._uint8ArrayToBuffer = function(t) {
      return Fc.from(t.buffer, t.byteOffset, t.byteLength);
    };
  });
  Jr = E5((_d2, A4) => {
    var T3 = fl(), Pc2 = Kr2(), kc = T3.Readable.destroy;
    A4.exports = T3.Readable;
    A4.exports._uint8ArrayToBuffer = T3._uint8ArrayToBuffer;
    A4.exports._isUint8Array = T3._isUint8Array;
    A4.exports.isDisturbed = T3.isDisturbed;
    A4.exports.isErrored = T3.isErrored;
    A4.exports.isReadable = T3.isReadable;
    A4.exports.Readable = T3.Readable;
    A4.exports.Writable = T3.Writable;
    A4.exports.Duplex = T3.Duplex;
    A4.exports.Transform = T3.Transform;
    A4.exports.PassThrough = T3.PassThrough;
    A4.exports.addAbortSignal = T3.addAbortSignal;
    A4.exports.finished = T3.finished;
    A4.exports.destroy = T3.destroy;
    A4.exports.destroy = kc;
    A4.exports.pipeline = T3.pipeline;
    A4.exports.compose = T3.compose;
    Object.defineProperty(T3, "promises", { configurable: true, enumerable: true, get() {
      return Pc2;
    } });
    A4.exports.Stream = T3.Stream;
    A4.exports.default = A4.exports;
  });
  Ze = {};
  Qr2(Ze, { default: () => Uc });
  ue(Ze, rt2(Jr()));
  Uc = rt2(Jr());
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// ../../../node_modules/@chainlink/env-enc/dist/EncryptedEnv.js
var require_EncryptedEnv = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var fs_1 = __importDefault((() => ({})));
  var path_1 = __importDefault((init_path(), __toCommonJS(exports_path)));
  var os_1 = __importDefault((init_os(), __toCommonJS(exports_os)));
  var crypto_1 = __importDefault((init_crypto2(), __toCommonJS(exports_crypto)));
  var readline_1 = __importDefault(require_readline());
  var stream_1 = (init_stream(), __toCommonJS(exports_stream));

  class EncryptedEnv {
    constructor(options) {
      this.envVars = {};
      this.setVars = () => __awaiter(this, undefined, undefined, function* () {
        if (fs_1.default.existsSync(this.envPath) && !this.isFileEmpty(this.envPath)) {
          if (!this.readEnvEncFile()) {
            return;
          }
        } else {
          if (!this.password) {
            console.log(`Please set an encryption password by running: ${text.yellow}npx env-enc set-pw${text.reset}
`);
            return;
          }
        }
        const mutableStream = new stream_1.Writable({
          write: (chunk, encoding, callback) => {
            process.stdout.write(chunk, encoding);
            callback();
          }
        });
        let linesToClear = 0;
        let numVars = 0;
        while (true) {
          const prompt = readline_1.default.createInterface({
            input: process.stdin,
            output: mutableStream
          });
          const name = yield new Promise((resolve) => {
            prompt.question(`${text.yellow}${numVars > 0 ? "Would you like to set another variable? " : ""}Please enter the variable name (or press ${text.green}ENTER${text.yellow} to finish): 
${text.reset}`, (input) => {
              resolve(input);
            });
          });
          prompt.close();
          linesToClear += 2;
          if (name === "") {
            for (let i = 0;i < linesToClear; i++) {
              this.clearLine();
            }
            mutableStream.end();
            return;
          }
          if (!this.isValidEnvVarName(name)) {
            mutableStream.write(`${name} is an invalid name for an environment variable.
Variable names must start with an underscore or upper-case character may only contain upper-case characters, underscores, and numbers.
`);
            linesToClear += 2;
            continue;
          }
          const value = yield this.getHiddenInput(`${text.yellow}Please enter the variable value (input will be hidden): 
${text.reset}`);
          linesToClear += 2;
          this.envVars[name] = value;
          numVars += 1;
          this.writeEnvEncFile();
        }
      });
      this.removeVar = (name) => {
        if (!fs_1.default.existsSync(this.envPath)) {
          console.log(`Encrypted environment variable file ${text.yellow}${this.envPath}${text.reset} not found`);
          return;
        }
        if (!this.readEnvEncFile()) {
          return;
        }
        if (!this.envVars[name]) {
          console.log(`No saved variable with the name ${text.yellow}${name}${text.reset} was found`);
          return;
        }
        delete this.envVars[name];
        this.writeEnvEncFile();
      };
      this.removeAll = () => {
        if (!fs_1.default.existsSync(this.envPath)) {
          console.log(`Encrypted environment variable file ${text.yellow}${this.envPath}${text.reset} not found`);
          return;
        }
        fs_1.default.unlinkSync(this.envPath);
      };
      this.viewVars = () => __awaiter(this, undefined, undefined, function* () {
        if (!fs_1.default.existsSync(this.envPath)) {
          console.log(`Encrypted environment variable file ${text.yellow}${this.envPath}${text.reset} not found`);
          return;
        }
        if (!this.readEnvEncFile()) {
          return;
        }
        const mutableStream = new stream_1.Writable({
          write: (chunk, encoding, callback) => {
            process.stdout.write(chunk, encoding);
            callback();
          }
        });
        const prompt = readline_1.default.createInterface({
          input: process.stdin,
          output: mutableStream
        });
        if (Object.keys(this.envVars).length === 0) {
          mutableStream.write(`There are currently no variables stored in ${text.yellow}${this.envPath}${text.reset}
`);
          yield new Promise((resolve) => {
            prompt.question(`${text.green}Press ENTER to continue${text.reset}`, resolve);
          });
          this.clearLine();
          this.clearLine();
          mutableStream.end();
          return;
        }
        mutableStream.write(`${text.underline}The following variables are encrypted and stored in ${text.yellow}${this.envPath}${text.reset}
`);
        for (const name in this.envVars) {
          mutableStream.write(`${text.yellow}${name} = ${text.reset}${this.envVars[name]}
`);
        }
        yield new Promise((resolve) => {
          prompt.question(`${text.green}Press ENTER to continue${text.reset}`, resolve);
        });
        for (let i = 0;i < Object.keys(this.envVars).length + 2; i++) {
          this.clearLine();
        }
        mutableStream.end();
      });
      this.load = () => {
        if (fs_1.default.existsSync(this.envPath) && this.readEnvEncFile()) {
          for (const name in this.envVars) {
            process.env[name] = this.envVars[name];
          }
        }
      };
      this.resolveHome = (envPath) => {
        return envPath[0] === "~" ? path_1.default.join(os_1.default.homedir(), envPath.slice(1)) : envPath;
      };
      this.getHiddenInput = (promptText) => __awaiter(this, undefined, undefined, function* () {
        const hiddenStream = new stream_1.Writable({
          write: (_chunk, _encoding, callback) => {
            callback();
          }
        });
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          const rl = readline_1.default.createInterface({
            input: process.stdin,
            output: hiddenStream,
            terminal: true
          });
          readline_1.default.emitKeypressEvents(process.stdin, rl);
          process.stdout.write(promptText);
          let input = "";
          const keypressHandler = (str, key) => __awaiter(this, undefined, undefined, function* () {
            if (!str) {
              return;
            }
            const keyCode = str.charCodeAt(0);
            if (keyCode === 13) {
              process.stdin.removeListener("keypress", keypressHandler);
              process.stdout.write(`
`);
              rl.close();
              resolve(input);
            } else if (keyCode === 8 || keyCode === 127) {
              if (input.length > 0) {
                input = input.slice(0, -1);
                process.stdout.write("\b \b");
              }
            } else {
              input += str;
              process.stdout.write("*".repeat(str.length));
            }
          });
          process.stdin.on("keypress", keypressHandler);
          process.stdin.setRawMode(true);
        }));
      });
      this.isFileEmpty = (path) => {
        return fs_1.default.readFileSync(path).toString().replace(/\s+/g, "").length === 0;
      };
      this.readEnvEncFile = () => {
        if (!this.password) {
          console.log(`Please set the encryption password by running: ${text.yellow}npx env-enc set-pw${text.reset}
If you do not know your password, delete the file ${text.yellow}${this.envPath}${text.reset} and set a new password. (Note: This will cause you to lose all encrypted variables.)
`);
          return false;
        }
        try {
          const lines = fs_1.default.readFileSync(this.envPath).toString().split(`
`);
          for (const line of lines) {
            const sanitizedLine = line.replace(/[ \t]+/g, "");
            if (sanitizedLine.length > 2) {
              const [name, value] = sanitizedLine.split(":");
              if (typeof name !== "string" || typeof value !== "string") {
                throw Error("Invalid encrypted environment variable file format");
              }
              this.envVars[name] = this.decrypt(value.slice(10));
            }
          }
        } catch (e) {
          console.log(`Error loading encrypted environment variables from file ${text.yellow}${this.envPath}${text.reset}.
If you do not know your password, delete the file ${text.yellow}${this.envPath}${text.reset} and set a new password. (Note: This will cause you to lose all encrypted variables.)
${e}`);
          return false;
        }
        return true;
      };
      this.writeEnvEncFile = () => {
        const lines = [];
        for (const name in this.envVars) {
          lines.push(`${name}: ENCRYPTED|${this.encrypt(this.envVars[name])}`);
        }
        fs_1.default.writeFileSync(this.envPath, lines.join(`
`));
      };
      this.encrypt = (plaintext) => {
        const salt = crypto_1.default.randomBytes(16);
        const iv = crypto_1.default.randomBytes(16);
        const key = crypto_1.default.scryptSync(this.password, salt, 32);
        const cipher = crypto_1.default.createCipheriv("aes-256-gcm", key, iv);
        const encrypted = Buffer.concat([cipher.update(plaintext, "utf8"), cipher.final()]);
        const tag = cipher.getAuthTag();
        const encryptedData = Buffer.concat([salt, iv, tag, encrypted]).toString("base64");
        return encryptedData;
      };
      this.decrypt = (encrypted) => {
        const dataBuffer = Buffer.from(encrypted, "base64");
        const salt = dataBuffer.slice(0, 16);
        const iv = dataBuffer.slice(16, 32);
        const tag = dataBuffer.slice(32, 48);
        const encryptedText = dataBuffer.slice(48);
        const key = crypto_1.default.scryptSync(this.password, salt, 32);
        const decipher = crypto_1.default.createDecipheriv("aes-256-gcm", key, iv);
        decipher.setAuthTag(tag);
        const decrypted = Buffer.concat([decipher.update(encryptedText), decipher.final()]);
        return decrypted.toString("utf8");
      };
      this.isValidEnvVarName = (name) => {
        const regex = /^[A-Z_][A-Z0-9_]*$/;
        return regex.test(name);
      };
      this.clearLine = () => {
        process.stdout.write("\x1B[1A");
        process.stdout.write("\x1B[0K");
      };
      this.password = process.env["ENV_ENC_PASSWORD"];
      if (options === null || options === undefined ? undefined : options.path) {
        this.envPath = this.resolveHome(options.path);
      } else {
        this.envPath = path_1.default.resolve(process.cwd(), ".env.enc");
      }
    }
  }
  exports.default = EncryptedEnv;
  var text = {
    reset: "\x1B[0m",
    underline: "\x1B[4m",
    green: "\x1B[32m",
    yellow: "\x1B[33m"
  };
});

// ../../../node_modules/@chainlink/env-enc/dist/index.js
var require_dist = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.config = exports.encryptedEnv = undefined;
  var EncryptedEnv_1 = __importDefault(require_EncryptedEnv());
  var config2 = (options) => {
    exports.encryptedEnv = new EncryptedEnv_1.default(options);
    exports.encryptedEnv.load();
  };
  exports.config = config2;
});

// ../../../node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.7",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// ../../../node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs = (() => ({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var os2 = (init_os(), __toCommonJS(exports_os));
  var crypto3 = (init_crypto2(), __toCommonJS(exports_crypto));
  var packageJson = require_package();
  var version4 = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _log(message) {
    console.log(`[dotenv@${version4}][INFO] ${message}`);
  }
  function _warn(message) {
    console.log(`[dotenv@${version4}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version4}][DEBUG] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path.join(os2.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config2(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto3.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config: config2,
    decrypt,
    parse,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// ../common/errorType.ts
var ErrorType;
((ErrorType2) => {
  ErrorType2[ErrorType2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  ErrorType2[ErrorType2["INVALID_BYTES_ARGS_LENGTH"] = 1] = "INVALID_BYTES_ARGS_LENGTH";
  ErrorType2[ErrorType2["ARRAY_LENGTH_MISMATCH"] = 2] = "ARRAY_LENGTH_MISMATCH";
  ErrorType2[ErrorType2["CONFIG_INVALID_VERSION"] = 10] = "CONFIG_INVALID_VERSION";
  ErrorType2[ErrorType2["CONFIG_INVALID_RELAYER_CONFIG"] = 11] = "CONFIG_INVALID_RELAYER_CONFIG";
  ErrorType2[ErrorType2["CONFIG_INVALID_MIN_SRC_CONFIRMATIONS"] = 12] = "CONFIG_INVALID_MIN_SRC_CONFIRMATIONS";
  ErrorType2[ErrorType2["CONFIG_INVALID_MIN_DST_CONFIRMATIONS"] = 13] = "CONFIG_INVALID_MIN_DST_CONFIRMATIONS";
  ErrorType2[ErrorType2["CONFIG_INVALID_SRC_CHAIN_SELECTOR"] = 14] = "CONFIG_INVALID_SRC_CHAIN_SELECTOR";
  ErrorType2[ErrorType2["CONFIG_INVALID_DST_CHAIN_SELECTOR"] = 15] = "CONFIG_INVALID_DST_CHAIN_SELECTOR";
  ErrorType2[ErrorType2["INVALID_MESSAGE_CONFIG"] = 16] = "INVALID_MESSAGE_CONFIG";
  ErrorType2[ErrorType2["CONFIG_SAME_CHAINS"] = 17] = "CONFIG_SAME_CHAINS";
  ErrorType2[ErrorType2["NO_CHAIN_DATA"] = 20] = "NO_CHAIN_DATA";
  ErrorType2[ErrorType2["NO_RPC_DATA"] = 21] = "NO_RPC_DATA";
  ErrorType2[ErrorType2["NO_RPC_PROVIDERS"] = 22] = "NO_RPC_PROVIDERS";
  ErrorType2[ErrorType2["INVALID_SOURCE_CHAIN"] = 23] = "INVALID_SOURCE_CHAIN";
  ErrorType2[ErrorType2["INVALID_DESTINATION_CHAIN"] = 24] = "INVALID_DESTINATION_CHAIN";
  ErrorType2[ErrorType2["INVALID_CHAIN"] = 25] = "INVALID_CHAIN";
  ErrorType2[ErrorType2["INVALID_RPC"] = 26] = "INVALID_RPC";
  ErrorType2[ErrorType2["EVENT_NOT_FOUND"] = 30] = "EVENT_NOT_FOUND";
  ErrorType2[ErrorType2["INVALID_HASHSUM"] = 31] = "INVALID_HASHSUM";
  ErrorType2[ErrorType2["INVALID_MESSAGE_ID"] = 32] = "INVALID_MESSAGE_ID";
  ErrorType2[ErrorType2["INVALID_DATA"] = 33] = "INVALID_DATA";
  ErrorType2[ErrorType2["INVALID_EXTRA_ARGS"] = 34] = "INVALID_EXTRA_ARGS";
  ErrorType2[ErrorType2["INVALID_INPUT"] = 35] = "INVALID_INPUT";
  ErrorType2[ErrorType2["INVALID_HASH_SUM"] = 36] = "INVALID_HASH_SUM";
  ErrorType2[ErrorType2["INVALID_CHAIN_DATA"] = 37] = "INVALID_CHAIN_DATA";
  ErrorType2[ErrorType2["INVALID_CHAIN_TYPE"] = 38] = "INVALID_CHAIN_TYPE";
  ErrorType2[ErrorType2["INVALID_TOKEN_TYPE"] = 40] = "INVALID_TOKEN_TYPE";
  ErrorType2[ErrorType2["INVALID_TOKEN_AMOUNT"] = 41] = "INVALID_TOKEN_AMOUNT";
  ErrorType2[ErrorType2["INVALID_RELAYER"] = 50] = "INVALID_RELAYER";
  ErrorType2[ErrorType2["INVALID_OPERATOR_COUNT"] = 51] = "INVALID_OPERATOR_COUNT";
  ErrorType2[ErrorType2["NO_REGISTERED_OPERATORS"] = 52] = "NO_REGISTERED_OPERATORS";
  ErrorType2[ErrorType2["NO_ALLOWED_OPERATORS"] = 53] = "NO_ALLOWED_OPERATORS";
  ErrorType2[ErrorType2["OPERATOR_SELECTION_FAILED"] = 54] = "OPERATOR_SELECTION_FAILED";
  ErrorType2[ErrorType2["INVALID_COHORTS_COUNT"] = 55] = "INVALID_COHORTS_COUNT";
  ErrorType2[ErrorType2["INVALID_OPERATOR_ADDRESS"] = 56] = "INVALID_OPERATOR_ADDRESS";
  ErrorType2[ErrorType2["INVALID_ACTION"] = 57] = "INVALID_ACTION";
  ErrorType2[ErrorType2["INVALID_OPERATOR_STAKE"] = 58] = "INVALID_OPERATOR_STAKE";
  ErrorType2[ErrorType2["INVALID_RECEIVER"] = 60] = "INVALID_RECEIVER";
  ErrorType2[ErrorType2["INVALID_SENDER"] = 61] = "INVALID_SENDER";
  ErrorType2[ErrorType2["INVALID_UINT256"] = 62] = "INVALID_UINT256";
  ErrorType2[ErrorType2["INVALID_ETHEREUM_ADDRESS"] = 63] = "INVALID_ETHEREUM_ADDRESS";
  ErrorType2[ErrorType2["DECODE_FAILED"] = 70] = "DECODE_FAILED";
})(ErrorType ||= {});

// ../common/errorHandler.ts
class CustomErrorHandler extends Error {
  type;
  data;
  constructor(type, data = null) {
    super(ErrorType[type]);
    this.type = type;
    this.data = data;
  }
}
function handleError(type) {
  throw new CustomErrorHandler(type);
}

// ../../../node_modules/viem/_esm/index.js
init_exports();

// ../../../node_modules/viem/_esm/utils/getAction.js
function getAction(client, actionFn, name) {
  const action_implicit = client[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client, params);
}

// ../../../node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_abi();

// ../../../node_modules/viem/_esm/errors/log.js
init_base();

class FilterTypeNotSupportedError extends BaseError2 {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
}

// ../../../node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_toBytes();
init_keccak256();
init_toEventSelector();
init_encodeAbiParameters();
init_formatAbiItem2();
init_getAbiItem();
var docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  const { abi, eventName, args } = parameters;
  let abiItem = abi[0];
  if (eventName) {
    const item = getAbiItem({ abi, name: eventName });
    if (!item)
      throw new AbiEventNotFoundError(eventName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(undefined, { docsPath });
  const definition = formatAbiItem2(abiItem);
  const signature = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => ("indexed" in param) && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i) => {
        if (Array.isArray(args_[i]))
          return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));
        return typeof args_[i] !== "undefined" && args_[i] !== null ? encodeArg({ param, value: args_[i] }) : null;
      }) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}

// ../../../node_modules/viem/_esm/actions/public/createContractEventFilter.js
init_toHex();

// ../../../node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id] = transport.request;
    });
  return (id) => requestMap[id] || client.request;
}

// ../../../node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, parameters) {
  const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : undefined;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    type: "event"
  };
}

// ../../../node_modules/viem/_esm/actions/public/estimateContractGas.js
init_encodeFunctionData();

// ../../../node_modules/viem/_esm/utils/errors/getContractError.js
init_abi();
init_base();
init_contract();
init_request();
init_rpc();
var EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath: docsPath3, functionName, sender }) {
  const error = err instanceof RawContractError ? err : err instanceof BaseError2 ? err.walk((err2) => ("data" in err2)) || err.walk() : {};
  const { code, data, details, message, shortMessage } = error;
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || details || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: error instanceof RpcRequestError ? details : shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath3,
    functionName,
    sender
  });
}

// ../../../node_modules/viem/_esm/actions/public/estimateGas.js
init_base();

// ../../../node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
init_getAddress();
init_keccak256();
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// ../../../node_modules/viem/_esm/utils/signature/recoverPublicKey.js
init_fromHex();
init_toHex();
async function recoverPublicKey({ hash: hash2, signature }) {
  const hashHex = isHex(hash2) ? hash2 : toHex(hash2);
  const { secp256k1: secp256k12 } = await Promise.resolve().then(() => (init_secp256k1(), exports_secp256k1));
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r, s, v, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// ../../../node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash: hash2, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash2, signature }));
}

// ../../../node_modules/viem/_esm/experimental/eip7702/utils/hashAuthorization.js
init_toBytes();
init_toHex();

// ../../../node_modules/viem/_esm/utils/encoding/toRlp.js
init_base();
init_cursor2();
init_toBytes();
init_toHex();
function toRlp(bytes, to = "hex") {
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === "hex")
    return bytesToHex(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x) => getEncodable(x)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode } of list) {
        encode(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError2("Length is too large.");
}

// ../../../node_modules/viem/_esm/experimental/eip7702/utils/hashAuthorization.js
init_keccak256();
function hashAuthorization(parameters) {
  const { chainId, contractAddress, nonce, to } = parameters;
  const hash2 = keccak256(concatHex([
    "0x05",
    toRlp([
      chainId ? numberToHex(chainId) : "0x",
      contractAddress,
      nonce ? numberToHex(nonce) : "0x"
    ])
  ]));
  if (to === "bytes")
    return hexToBytes(hash2);
  return hash2;
}

// ../../../node_modules/viem/_esm/experimental/eip7702/utils/recoverAuthorizationAddress.js
async function recoverAuthorizationAddress(parameters) {
  const { authorization, signature } = parameters;
  return recoverAddress({
    hash: hashAuthorization(authorization),
    signature: signature ?? authorization
  });
}

// ../../../node_modules/viem/_esm/actions/public/estimateGas.js
init_toHex();

// ../../../node_modules/viem/_esm/errors/estimateGas.js
init_formatEther();
init_formatGwei();
init_base();
init_transaction();

class EstimateGasExecutionError extends BaseError2 {
  constructor(cause, { account, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath3,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.cause = cause;
  }
}

// ../../../node_modules/viem/_esm/utils/errors/getEstimateGasError.js
init_node();
init_getNodeError();
function getEstimateGasError(err, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}

// ../../../node_modules/viem/_esm/actions/public/estimateGas.js
init_transactionRequest();
init_stateOverride2();
init_assertRequest();
// ../../../node_modules/viem/_esm/errors/fee.js
init_formatGwei();
init_base();

class BaseFeeScalarError extends BaseError2 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}

class Eip1559FeesNotSupportedError extends BaseError2 {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}

class MaxFeePerGasTooLowError extends BaseError2 {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}

// ../../../node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
init_fromHex();

// ../../../node_modules/viem/_esm/errors/block.js
init_base();

class BlockNotFoundError extends BaseError2 {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`, { name: "BlockNotFoundError" });
  }
}

// ../../../node_modules/viem/_esm/actions/public/getBlock.js
init_toHex();
// ../../../node_modules/viem/_esm/utils/formatters/transaction.js
init_fromHex();
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,
    gas: transaction.gas ? BigInt(transaction.gas) : undefined,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : undefined,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : undefined,
    typeHex: transaction.type ? transaction.type : undefined,
    value: transaction.value ? BigInt(transaction.value) : undefined,
    v: transaction.v ? BigInt(transaction.v) : undefined
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList2(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
function formatAuthorizationList2(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// ../../../node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : undefined,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : undefined,
    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);

// ../../../node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    }, { dedupe: true });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client.chain?.formatters?.block?.format || formatBlock;
  return format(block);
}

// ../../../node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// ../../../node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function estimateMaxPriorityFeePerGas(client, args) {
  return internal_estimateMaxPriorityFeePerGas(client, args);
}
async function internal_estimateMaxPriorityFeePerGas(client, args) {
  const { block: block_, chain = client.chain, request } = args || {};
  try {
    const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
    if (typeof maxPriorityFeePerGas === "function") {
      const block = block_ || await getAction(client, getBlock, "getBlock")({});
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client,
        request
      });
      if (maxPriorityFeePerGas_ === null)
        throw new Error;
      return maxPriorityFeePerGas_;
    }
    if (typeof maxPriorityFeePerGas !== "undefined")
      return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// ../../../node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function estimateFeesPerGas(client, args) {
  return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
  const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client,
        request
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError;
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError;
    const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// ../../../node_modules/viem/_esm/actions/public/getTransactionCount.js
init_fromHex();
init_toHex();
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// ../../../node_modules/viem/_esm/utils/blob/blobsToCommitments.js
init_toBytes();
init_toHex();
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === "bytes" ? commitments : commitments.map((x) => bytesToHex(x));
}

// ../../../node_modules/viem/_esm/utils/blob/blobsToProofs.js
init_toBytes();
init_toHex();
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0;i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x) => bytesToHex(x));
}

// ../../../node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
init_toHex();

// ../../../node_modules/viem/_esm/utils/hash/sha256.js
init_sha256();
init_toBytes();
init_toHex();
function sha2562(value, to_) {
  const to = to_ || "hex";
  const bytes = sha256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}

// ../../../node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version3 = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha2562(commitment, "bytes");
  versionedHash.set([version3], 0);
  return to === "bytes" ? versionedHash : bytesToHex(versionedHash);
}

// ../../../node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version3 } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version: version3
    }));
  }
  return hashes;
}

// ../../../node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - 1 - 1 * fieldElementsPerBlob * blobsPerTransaction;

// ../../../node_modules/viem/_esm/constants/kzg.js
var versionedHashVersionKzg = 1;

// ../../../node_modules/viem/_esm/errors/blob.js
init_base();

class BlobSizeTooLargeError extends BaseError2 {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}

class EmptyBlobError extends BaseError2 {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}

class InvalidVersionedHashSizeError extends BaseError2 {
  constructor({ hash: hash2, size: size2 }) {
    super(`Versioned hash "${hash2}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size2}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}

class InvalidVersionedHashVersionError extends BaseError2 {
  constructor({ hash: hash2, version: version3 }) {
    super(`Versioned hash "${hash2}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${version3}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}

// ../../../node_modules/viem/_esm/utils/blob/toBlobs.js
init_cursor2();
init_size();
init_toBytes();
init_toHex();
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_)
    throw new EmptyBlobError;
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex(x.bytes));
}

// ../../../node_modules/viem/_esm/utils/blob/toBlobSidecars.js
function toBlobSidecars(parameters) {
  const { data, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let i = 0;i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}

// ../../../node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_assertRequest();

// ../../../node_modules/viem/_esm/utils/transaction/getTransactionType.js
init_transaction();
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// ../../../node_modules/viem/_esm/actions/public/getChainId.js
init_fromHex();
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  }, { dedupe: true });
  return hexToNumber(chainIdHex);
}

// ../../../node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
var defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
var eip1559NetworkCache = /* @__PURE__ */ new Map;
async function prepareTransactionRequest(client, args) {
  const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = defaultParameters, type } = args;
  const account = account_ ? parseAccount(account_) : account_;
  const request = { ...args, ...account ? { from: account?.address } : {} };
  let block;
  async function getBlock2() {
    if (block)
      return block;
    block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (chain)
      return chain.id;
    if (typeof args.chainId !== "undefined")
      return args.chainId;
    const chainId_ = await getAction(client, getChainId, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account) {
    if (nonceManager) {
      const chainId2 = await getChainId2();
      request.nonce = await nonceManager.consume({
        address: account.address,
        chainId: chainId2,
        client
      });
    } else {
      request.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
    }
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId"))
    request.chainId = await getChainId2();
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      let isEip1559Network = eip1559NetworkCache.get(client.uid);
      if (typeof isEip1559Network === "undefined") {
        const block2 = await getBlock2();
        isEip1559Network = typeof block2?.baseFeePerGas === "bigint";
        eip1559NetworkCache.set(client.uid, isEip1559Network);
      }
      request.type = isEip1559Network ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type !== "legacy" && request.type !== "eip2930") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock2();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError;
      if (typeof args.gasPrice === "undefined") {
        const block2 = await getBlock2();
        const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain,
          request,
          type: "legacy"
        });
        request.gasPrice = gasPrice_;
      }
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction(client, estimateGas, "estimateGas")({
      ...request,
      account: account ? { address: account.address, type: "json-rpc" } : account
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}

// ../../../node_modules/viem/_esm/actions/public/getBalance.js
init_toHex();
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// ../../../node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, args) {
  const { account: account_ = client.account } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  try {
    let estimateGas_rpc = function(parameters) {
      const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;
      return client.request({
        method: "eth_estimateGas",
        params: rpcStateOverride2 ? [request2, block2 ?? "latest", rpcStateOverride2] : block2 ? [request2, block2] : [request2]
      });
    };
    const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client, {
      ...args,
      parameters: account?.type === "local" ? undefined : ["blobVersionedHashes"]
    });
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to = await (async () => {
      if (rest.to)
        return rest.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError2("`to` is required. Could not infer from `authorizationList`");
        });
      return;
    })();
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
    if (authorizationList) {
      const value2 = await getBalance(client, { address: request.from });
      const estimates = await Promise.all(authorizationList.map(async (authorization) => {
        const { contractAddress } = authorization;
        const estimate2 = await estimateGas_rpc({
          block,
          request: {
            authorizationList: undefined,
            data,
            from: account?.address,
            to: contractAddress,
            value: numberToHex(value2)
          },
          rpcStateOverride
        }).catch(() => 100000n);
        return 2n * BigInt(estimate2);
      }));
      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
    }
    return estimate;
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// ../../../node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, parameters) {
  const { abi, address, args, functionName, dataSuffix, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas, "estimateGas")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : undefined;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}

// ../../../node_modules/viem/_esm/actions/public/getContractEvents.js
init_getAbiItem();

// ../../../node_modules/viem/_esm/utils/abi/parseEventLogs.js
init_abi();
init_isAddressEqual();
init_toBytes();
init_keccak256();
init_toEventSelector();

// ../../../node_modules/viem/_esm/utils/abi/decodeEventLog.js
init_abi();
init_size();
init_toEventSelector();
init_cursor();
init_decodeAbiParameters();
init_formatAbiItem2();
var docsPath3 = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath3 });
  const abiItem = (() => {
    if (abi.length === 1)
      return abi[0];
    return abi.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem2(x)));
  })();
  if (!(abiItem && ("name" in abiItem)) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath3 });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x) => !(("name" in x) && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => ("indexed" in x) && x.indexed);
  for (let i = 0;i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !(("indexed" in x) && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0;i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size(data)
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : undefined
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}

// ../../../node_modules/viem/_esm/utils/abi/parseEventLogs.js
function parseEventLogs(parameters) {
  const { abi, args, logs, strict = true } = parameters;
  const eventName = (() => {
    if (!parameters.eventName)
      return;
    if (Array.isArray(parameters.eventName))
      return parameters.eventName;
    return [parameters.eventName];
  })();
  return logs.map((log) => {
    try {
      const abiItem = abi.find((abiItem2) => abiItem2.type === "event" && log.topics[0] === toEventSelector(abiItem2));
      if (!abiItem)
        return null;
      const event = decodeEventLog({
        ...log,
        abi: [abiItem],
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      if (!includesArgs({
        args: event.args,
        inputs: abiItem.inputs,
        matchArgs: args
      }))
        return null;
      return { ...event, ...log };
    } catch (err) {
      let eventName2;
      let isUnnamed;
      if (err instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}
function includesArgs(parameters) {
  const { args, inputs, matchArgs } = parameters;
  if (!matchArgs)
    return true;
  if (!args)
    return false;
  function isEqual(input, value, arg) {
    try {
      if (input.type === "address")
        return isAddressEqual(value, arg);
      if (input.type === "string" || input.type === "bytes")
        return keccak256(toBytes(value)) === arg;
      return value === arg;
    } catch {
      return false;
    }
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    return matchArgs.every((value, index) => {
      if (value === null || value === undefined)
        return true;
      const input = inputs[index];
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[index]));
    });
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    return Object.entries(matchArgs).every(([key, value]) => {
      if (value === null || value === undefined)
        return true;
      const input = inputs.find((input2) => input2.name === key);
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[key]));
    });
  return false;
}

// ../../../node_modules/viem/_esm/actions/public/getLogs.js
init_toHex();

// ../../../node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// ../../../node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : undefined);
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args: events_ ? undefined : args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!events)
    return formattedLogs;
  return parseEventLogs({
    abi: events,
    args,
    logs: formattedLogs,
    strict
  });
}

// ../../../node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, parameters) {
  const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi, name: eventName }) : undefined;
  const events = !event ? abi.filter((x) => x.type === "event") : undefined;
  return getAction(client, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}

// ../../../node_modules/viem/_esm/actions/public/readContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function readContract(client, parameters) {
  const { abi, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await getAction(client, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// ../../../node_modules/viem/_esm/actions/public/simulateContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function simulateContract(client, parameters) {
  const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
  const calldata = encodeFunctionData({ abi, args, functionName });
  try {
    const { data } = await getAction(client, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi.filter((abiItem) => ("name" in abiItem) && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}

// ../../../node_modules/viem/_esm/actions/public/watchContractEvent.js
init_abi();
init_rpc();

// ../../../node_modules/viem/_esm/utils/observe.js
var listenersCache = /* @__PURE__ */ new Map;
var cleanupCache = /* @__PURE__ */ new Map;
var callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const listeners2 = getListeners();
    if (!listeners2.some((cb) => cb.id === callbackId))
      return;
    const cleanup2 = cleanupCache.get(observerId);
    if (listeners2.length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        listener.fns[key]?.(...args);
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// ../../../node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// ../../../node_modules/viem/_esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = undefined;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}
// ../../../node_modules/viem/_esm/utils/promise/withCache.js
var promiseCache = /* @__PURE__ */ new Map;
var responseCache = /* @__PURE__ */ new Map;
function getCache(cacheKey) {
  const buildCache = (cacheKey2, cache) => ({
    clear: () => cache.delete(cacheKey2),
    get: () => cache.get(cacheKey2),
    set: (data) => cache.set(cacheKey2, data)
  });
  const promise = buildCache(cacheKey, promiseCache);
  const response = buildCache(cacheKey, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: new Date, data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// ../../../node_modules/viem/_esm/actions/public/getBlockNumber.js
var cacheKey = (id) => `blockNumber.${id}`;
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime });
  return BigInt(blockNumberHex);
}

// ../../../node_modules/viem/_esm/actions/public/getFilterChanges.js
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!("abi" in filter) || !filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// ../../../node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// ../../../node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, parameters) {
  const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== undefined)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              args,
              eventName,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber < blockNumber) {
              logs = await getAction(client, getContractEvents, "getContractEvents")({
                abi,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const topics = eventName ? encodeEventTopics({
            abi,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: args2 } = decodeEventLog({
                  abi,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog(log, {
                  args: args2,
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              } catch (err) {
                let eventName2;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              }
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

// ../../../node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}

// ../../../node_modules/viem/_esm/errors/eip712.js
init_base();

class Eip712DomainNotFoundError extends BaseError2 {
  constructor({ address }) {
    super(`No EIP-712 domain found on contract "${address}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${address}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
}

// ../../../node_modules/viem/_esm/actions/public/getEip712Domain.js
async function getEip712Domain(client, parameters) {
  const { address, factory, factoryData } = parameters;
  try {
    const [fields, name, version3, chainId, verifyingContract, salt, extensions] = await getAction(client, readContract, "readContract")({
      abi,
      address,
      functionName: "eip712Domain",
      factory,
      factoryData
    });
    return {
      domain: {
        name,
        version: version3,
        chainId: Number(chainId),
        verifyingContract,
        salt
      },
      extensions,
      fields
    };
  } catch (e) {
    const error = e;
    if (error.name === "ContractFunctionExecutionError" && error.cause.name === "ContractFunctionZeroDataError") {
      throw new Eip712DomainNotFoundError({ address });
    }
    throw error;
  }
}
var abi = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
// ../../../node_modules/viem/_esm/utils/uid.js
var size2 = 256;
var index = size2;
var buffer;
function uid(length = 11) {
  if (!buffer || index + length > size2 * 2) {
    buffer = "";
    index = 0;
    for (let i = 0;i < size2; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// ../../../node_modules/viem/_esm/clients/createClient.js
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4000, ccipRead, key = "base", name = "Base Client", pollingInterval = 4000, type = "base" } = parameters;
  const chain = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : undefined;
  const { config, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config, ...value };
  const client = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid()
  };
  function extend(base) {
    return (extendFn) => {
      const extended = extendFn(base);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client, { extend: extend(client) });
}

// ../../../node_modules/viem/_esm/utils/buildRequest.js
init_base();
init_request();
init_rpc();
init_toHex();

// ../../../node_modules/viem/_esm/utils/promise/withDedupe.js
init_lru();
var promiseCache2 = /* @__PURE__ */ new LruMap(8192);
function withDedupe(fn, { enabled = true, id }) {
  if (!enabled || !id)
    return fn();
  if (promiseCache2.get(id))
    return promiseCache2.get(id);
  const promise = fn().finally(() => promiseCache2.delete(id));
  promiseCache2.set(id, promise);
  return promise;
}

// ../../../node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}

// ../../../node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const { method } = args;
    if (methods?.exclude?.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    if (methods?.include && !methods.include.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    const requestId = dedupe ? stringToHex(`${uid2}.${stringify(args)}`) : undefined;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err, { method: args.method });
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err, {
              method: args.method
            });
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          case 5000:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError2)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count, error }) => {
        if (error && error instanceof HttpRequestError) {
          const retryAfter = error?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return Number.parseInt(retryAfter) * 1000;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}

// ../../../node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  const uid2 = uid();
  return {
    config: {
      key,
      methods,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type
    },
    request: buildRequest(request, { methods, retryCount, retryDelay, uid: uid2 }),
    value
  };
}

// ../../../node_modules/viem/_esm/clients/transports/fallback.js
init_node();
init_rpc();
function fallback(transports_, config = {}) {
  const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config;
  return ({ chain, pollingInterval = 4000, timeout, ...rest }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport = createTransport({
      key,
      name,
      async request({ method, params }) {
        let includes;
        const fetch2 = async (i = 0) => {
          const transport2 = transports[i]({
            ...rest,
            chain,
            retryCount: 0,
            timeout
          });
          try {
            const response = await transport2.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport2,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport2,
              status: "error"
            });
            if (shouldThrow(err))
              throw err;
            if (i === transports.length - 1)
              throw err;
            includes ??= transports.slice(i + 1).some((transport3) => {
              const { include, exclude } = transport3({ chain }).config.methods || {};
              if (include)
                return include.includes(method);
              if (exclude)
                return !exclude.includes(method);
              return true;
            });
            if (!includes)
              throw err;
            return fetch2(i + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn) => onResponse = fn,
      transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        ping: rankOptions.ping,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport;
  };
}
function shouldThrow(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error.message) || error.code === 5000)
      return true;
  }
  return false;
}
function rankTransports({ chain, interval = 4000, onTransports, ping, sampleCount = 10, timeout = 1000, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport) => {
      const transport_ = transport({ chain, retryCount: 0, timeout });
      const start = Date.now();
      let end;
      let success;
      try {
        await (ping ? ping({ transport: transport_ }) : transport_.request({ method: "net_listening" }));
        success = 1;
      } catch {
        success = 0;
      } finally {
        end = Date.now();
      }
      const latency = end - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_, i) => {
      const latencies = samples.map((sample2) => sample2[i].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i
      ];
    }).sort((a, b) => b[0] - a[0]);
    onTransports(scores.map(([, i]) => transports[i]));
    await wait(interval);
    rankTransports_();
  };
  rankTransports_();
}
// ../../../node_modules/viem/_esm/clients/transports/http.js
init_request();

// ../../../node_modules/viem/_esm/errors/transport.js
init_base();

class UrlRequiredError extends BaseError2 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}

// ../../../node_modules/viem/_esm/clients/transports/http.js
init_createBatchScheduler();

// ../../../node_modules/viem/_esm/utils/rpc/http.js
init_request();

// ../../../node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController;
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: controller?.signal || null }));
      } catch (err) {
        if (err?.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
// ../../../node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = /* @__PURE__ */ createIdStore();

// ../../../node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init);
          const args = await onRequest?.(request, init) ?? { ...init, url };
          const response2 = await fetch(args.url ?? url, args);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          try {
            data = JSON.parse(data || "{}");
          } catch (err) {
            if (response.ok)
              throw err;
            data = { error: data };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError)
          throw err;
        throw new HttpRequestError({
          body,
          cause: err,
          url
        });
      }
    }
  };
}

// ../../../node_modules/viem/_esm/clients/transports/http.js
function http(url, config = {}) {
  const { batch, fetchOptions, key = "http", methods, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1000, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError;
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key,
      methods,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a, b) => a.id - b.id
        });
        const fn = async (body2) => batch ? schedule(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error, result }] = await fn(body);
        if (raw)
          return { error, result };
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
// ../../../node_modules/viem/_esm/actions/ens/getEnsAddress.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
init_toHex();

// ../../../node_modules/viem/_esm/utils/ens/errors.js
init_solidity();
init_base();
init_contract();
function isNullUniversalResolverError(err, callType) {
  if (!(err instanceof BaseError2))
    return false;
  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.data?.errorName === "ResolverNotContract")
    return true;
  if (cause.data?.errorName === "ResolverError")
    return true;
  if (cause.data?.errorName === "HttpError")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}

// ../../../node_modules/viem/_esm/utils/ens/namehash.js
init_toBytes();
init_toHex();
init_keccak256();

// ../../../node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash2))
    return null;
  return hash2;
}

// ../../../node_modules/viem/_esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let i = labels.length - 1;i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// ../../../node_modules/viem/_esm/utils/ens/packetToBytes.js
init_toBytes();

// ../../../node_modules/viem/_esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}

// ../../../node_modules/viem/_esm/utils/ens/labelhash.js
init_toBytes();
init_toHex();
init_keccak256();
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}

// ../../../node_modules/viem/_esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i = 0;i < list.length; i++) {
    let encoded = stringToBytes(list[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes.byteLength !== offset + 1)
    return bytes.slice(0, offset + 1);
  return bytes;
}

// ../../../node_modules/viem/_esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(name)), functionData],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// ../../../node_modules/viem/_esm/errors/ens.js
init_base();

class EnsAvatarInvalidMetadataError extends BaseError2 {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
}

class EnsAvatarInvalidNftUriError extends BaseError2 {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
}

class EnsAvatarUriResolutionError extends BaseError2 {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
}

class EnsAvatarUnsupportedNamespaceError extends BaseError2 {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
}

// ../../../node_modules/viem/_esm/utils/ens/avatar/utils.js
var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image;
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom, defaultGateway) {
  if (!custom)
    return defaultGateway;
  if (custom.endsWith("/"))
    return custom.slice(0, -1);
  return custom;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}

// ../../../node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}

// ../../../node_modules/viem/_esm/actions/ens/getEnsText.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
init_toHex();
async function getEnsText(client, { blockNumber, blockTag, name, key, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key]
        })
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// ../../../node_modules/viem/_esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
  const record = await getAction(client, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress,
    gatewayUrls,
    strict
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client, {
      record,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}

// ../../../node_modules/viem/_esm/actions/ens/getEnsName.js
init_abis();
init_getChainContractAddress();
init_toHex();
async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}

// ../../../node_modules/viem/_esm/actions/ens/getEnsResolver.js
init_getChainContractAddress();
init_toHex();
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await getAction(client, readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}

// ../../../node_modules/viem/_esm/clients/decorators/public.js
init_call();

// ../../../node_modules/viem/_esm/actions/public/createAccessList.js
init_toHex();
init_getCallError();
init_transactionRequest();
init_assertRequest();
async function createAccessList(client, args) {
  const { account: account_ = client.account, blockNumber, blockTag = "latest", blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = args;
  const account = account_ ? parseAccount(account_) : undefined;
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      to,
      value
    });
    const response = await client.request({
      method: "eth_createAccessList",
      params: [request, block]
    });
    return {
      accessList: response.accessList,
      gasUsed: BigInt(response.gasUsed)
    };
  } catch (err) {
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// ../../../node_modules/viem/_esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id, request: getRequest(id), type: "block" };
}

// ../../../node_modules/viem/_esm/actions/public/createEventFilter.js
init_toHex();
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : undefined);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args,
    eventName: event ? event.name : undefined,
    fromBlock,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    toBlock,
    type: "event"
  };
}

// ../../../node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id, request: getRequest(id), type: "transaction" };
}

// ../../../node_modules/viem/_esm/actions/public/getBlobBaseFee.js
async function getBlobBaseFee(client) {
  const baseFee = await client.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(baseFee);
}

// ../../../node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
init_fromHex();
init_toHex();
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let count;
  if (blockHash) {
    count = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    }, { dedupe: true });
  } else {
    count = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  return hexToNumber(count);
}

// ../../../node_modules/viem/_esm/actions/public/getCode.js
init_toHex();
async function getCode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const hex = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  }, { dedupe: Boolean(blockNumberHex) });
  if (hex === "0x")
    return;
  return hex;
}

// ../../../node_modules/viem/_esm/actions/public/getFeeHistory.js
init_toHex();

// ../../../node_modules/viem/_esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}

// ../../../node_modules/viem/_esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  }, { dedupe: Boolean(blockNumberHex) });
  return formatFeeHistory(feeHistory);
}

// ../../../node_modules/viem/_esm/actions/public/getFilterLogs.js
async function getFilterLogs(_client, { filter }) {
  const strict = filter.strict ?? false;
  const logs = await filter.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// ../../../node_modules/viem/_esm/actions/public/getProof.js
init_toHex();

// ../../../node_modules/viem/_esm/utils/chain/defineChain.js
function defineChain(chain) {
  return {
    formatters: undefined,
    fees: undefined,
    serializers: undefined,
    ...chain
  };
}

// ../../../node_modules/viem/_esm/utils/typedData.js
init_abi();
init_address();

// ../../../node_modules/viem/_esm/errors/typedData.js
init_base();

class InvalidDomainError extends BaseError2 {
  constructor({ domain }) {
    super(`Invalid domain "${stringify(domain)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}

class InvalidPrimaryTypeError extends BaseError2 {
  constructor({ primaryType, types }) {
    super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}

class InvalidStructTypeError extends BaseError2 {
  constructor({ type }) {
    super(`Struct type "${type}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}

// ../../../node_modules/viem/_esm/utils/typedData.js
init_isAddress();
init_size();
init_toHex();
init_regex2();

// ../../../node_modules/viem/_esm/utils/signature/hashTypedData.js
init_encodeAbiParameters();
init_toHex();
init_keccak256();
function hashTypedData(parameters) {
  const { domain = {}, message, primaryType } = parameters;
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  return keccak256(concat(parts));
}
function hashDomain({ domain, types }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
function hashStruct({ data, primaryType, types }) {
  const encoded = encodeData({
    data,
    primaryType,
    types
  });
  return keccak256(encoded);
}
function encodeData({ data, primaryType, types }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
  const encodedHashType = toHex(encodeType({ primaryType, types }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = new Set) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match?.[0];
  if (results.has(primaryType) || types[primaryType] === undefined) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results);
  }
  return results;
}
function encodeField({ types, name, type, value }) {
  if (types[type] !== undefined) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type, types }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256(toHex(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type }, value];
}

// ../../../node_modules/viem/_esm/utils/typedData.js
function validateTypedData(parameters) {
  const { domain, message, primaryType, types } = parameters;
  const validateData = (struct, data) => {
    for (const param of struct) {
      const { name, type } = param;
      const value = data[name];
      const integerMatch = type.match(integerRegex2);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base, size_] = integerMatch;
        numberToHex(value, {
          signed: base === "int",
          size: Number.parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex2);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== Number.parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size_),
            givenSize: size(value)
          });
      }
      const struct2 = types[type];
      if (struct2) {
        validateReference(type);
        validateData(struct2, value);
      }
    }
  };
  if (types.EIP712Domain && domain) {
    if (typeof domain !== "object")
      throw new InvalidDomainError({ domain });
    validateData(types.EIP712Domain, domain);
  }
  if (primaryType !== "EIP712Domain") {
    if (types[primaryType])
      validateData(types[primaryType], message);
    else
      throw new InvalidPrimaryTypeError({ primaryType, types });
  }
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    (typeof domain?.chainId === "number" || typeof domain?.chainId === "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function validateReference(type) {
  if (type === "address" || type === "bool" || type === "string" || type.startsWith("bytes") || type.startsWith("uint") || type.startsWith("int"))
    throw new InvalidStructTypeError({ type });
}

// ../../../node_modules/viem/_esm/utils/index.js
init_encodeFunctionData();

// ../../../node_modules/viem/_esm/utils/formatters/transactionReceipt.js
init_fromHex();
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt);

// ../../../node_modules/viem/_esm/utils/index.js
init_fromHex();

// ../../../node_modules/viem/_esm/utils/signature/hashMessage.js
init_keccak256();

// ../../../node_modules/viem/_esm/constants/strings.js
var presignMessagePrefix = `\x19Ethereum Signed Message:
`;

// ../../../node_modules/viem/_esm/utils/signature/toPrefixedMessage.js
init_size();
init_toHex();
function toPrefixedMessage(message_) {
  const message = (() => {
    if (typeof message_ === "string")
      return stringToHex(message_);
    if (typeof message_.raw === "string")
      return message_.raw;
    return bytesToHex(message_.raw);
  })();
  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);
  return concat([prefix, message]);
}

// ../../../node_modules/viem/_esm/utils/signature/hashMessage.js
function hashMessage(message, to_) {
  return keccak256(toPrefixedMessage(message), to_);
}

// ../../../node_modules/viem/_esm/constants/bytes.js
var erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";

// ../../../node_modules/viem/_esm/utils/signature/isErc6492Signature.js
init_slice();
function isErc6492Signature(signature) {
  return sliceHex(signature, -32) === erc6492MagicBytes;
}

// ../../../node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js
init_encodeAbiParameters();
init_toBytes();
function serializeErc6492Signature(parameters) {
  const { address, data, signature, to = "hex" } = parameters;
  const signature_ = concatHex([
    encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature]),
    erc6492MagicBytes
  ]);
  if (to === "hex")
    return signature_;
  return hexToBytes(signature_);
}

// ../../../node_modules/viem/_esm/utils/transaction/assertTransaction.js
init_number();
init_address();
init_base();
init_chain();
init_node();
init_isAddress();
init_size();
init_slice();
init_fromHex();
function assertTransactionEIP7702(transaction) {
  const { authorizationList } = transaction;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { contractAddress, chainId } = authorization;
      if (!isAddress(contractAddress))
        throw new InvalidAddressError({ address: contractAddress });
      if (chainId < 0)
        throw new InvalidChainIdError({ chainId });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
  const { blobVersionedHashes } = transaction;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobError;
    for (const hash2 of blobVersionedHashes) {
      const size_ = size(hash2);
      const version3 = hexToNumber(slice(hash2, 0, 1));
      if (size_ !== 32)
        throw new InvalidVersionedHashSizeError({ hash: hash2, size: size_ });
      if (version3 !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({
          hash: hash2,
          version: version3
        });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
function assertTransactionEIP2930(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
function assertTransactionLegacy(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}

// ../../../node_modules/viem/_esm/utils/transaction/serializeTransaction.js
init_transaction();
init_toHex();

// ../../../node_modules/viem/_esm/experimental/eip7702/utils/serializeAuthorizationList.js
init_toHex();
function serializeAuthorizationList(authorizationList) {
  if (!authorizationList || authorizationList.length === 0)
    return [];
  const serializedAuthorizationList = [];
  for (const authorization of authorizationList) {
    const { contractAddress, chainId, nonce, ...signature } = authorization;
    serializedAuthorizationList.push([
      chainId ? toHex(chainId) : "0x",
      contractAddress,
      nonce ? toHex(nonce) : "0x",
      ...toYParitySignatureArray({}, signature)
    ]);
  }
  return serializedAuthorizationList;
}

// ../../../node_modules/viem/_esm/utils/transaction/serializeAccessList.js
init_address();
init_transaction();
init_isAddress();
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const serializedAccessList = [];
  for (let i = 0;i < accessList.length; i++) {
    const { address, storageKeys } = accessList[i];
    for (let j = 0;j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
      }
    }
    if (!isAddress(address, { strict: false })) {
      throw new InvalidAddressError({ address });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}

// ../../../node_modules/viem/_esm/utils/transaction/serializeTransaction.js
function serializeTransaction(transaction, signature) {
  const type = getTransactionType(transaction);
  if (type === "eip1559")
    return serializeTransactionEIP1559(transaction, signature);
  if (type === "eip2930")
    return serializeTransactionEIP2930(transaction, signature);
  if (type === "eip4844")
    return serializeTransactionEIP4844(transaction, signature);
  if (type === "eip7702")
    return serializeTransactionEIP7702(transaction, signature);
  return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
  const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP7702(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
  return concatHex([
    "0x04",
    toRlp([
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? toHex(maxFeePerGas) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      serializedAuthorizationList,
      ...toYParitySignatureArray(transaction, signature)
    ])
  ]);
}
function serializeTransactionEIP4844(transaction, signature) {
  const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP4844(transaction);
  let blobVersionedHashes = transaction.blobVersionedHashes;
  let sidecars = transaction.sidecars;
  if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
    const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex(x));
    const kzg = transaction.kzg;
    const commitments2 = blobsToCommitments({
      blobs: blobs2,
      kzg
    });
    if (typeof blobVersionedHashes === "undefined")
      blobVersionedHashes = commitmentsToVersionedHashes({
        commitments: commitments2
      });
    if (typeof sidecars === "undefined") {
      const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });
      sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });
    }
  }
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...toYParitySignatureArray(transaction, signature)
  ];
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i = 0;i < sidecars.length; i++) {
      const { blob, commitment, proof } = sidecars[i];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concatHex([
    "0x03",
    sidecars ? toRlp([serializedTransaction, blobs, commitments, proofs]) : toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP1559(transaction, signature) {
  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP1559(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x02",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP2930(transaction, signature) {
  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
  assertTransactionEIP2930(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x01",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionLegacy(transaction, signature) {
  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
  assertTransactionLegacy(transaction);
  let serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x"
  ];
  if (signature) {
    const v = (() => {
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n;
        if (inferredChainId > 0)
          return signature.v;
        return 27n + (signature.v === 35n ? 0n : 1n);
      }
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      const v2 = 27n + (signature.v === 27n ? 0n : 1n);
      if (signature.v !== v2)
        throw new InvalidLegacyVError({ v: signature.v });
      return v2;
    })();
    const r = trim(signature.r);
    const s = trim(signature.s);
    serializedTransaction = [
      ...serializedTransaction,
      toHex(v),
      r === "0x00" ? "0x" : r,
      s === "0x00" ? "0x" : s
    ];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      toHex(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
  const signature = signature_ ?? transaction;
  const { v, yParity } = signature;
  if (typeof signature.r === "undefined")
    return [];
  if (typeof signature.s === "undefined")
    return [];
  if (typeof v === "undefined" && typeof yParity === "undefined")
    return [];
  const r = trim(signature.r);
  const s = trim(signature.s);
  const yParity_ = (() => {
    if (typeof yParity === "number")
      return yParity ? toHex(1) : "0x";
    if (v === 0n)
      return "0x";
    if (v === 1n)
      return toHex(1);
    return v === 27n ? "0x" : toHex(1);
  })();
  return [yParity_, r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
}

// ../../../node_modules/viem/_esm/errors/unit.js
init_base();

class InvalidDecimalNumberError extends BaseError2 {
  constructor({ value }) {
    super(`Number \`${value}\` is not a valid decimal number.`, {
      name: "InvalidDecimalNumberError"
    });
  }
}

// ../../../node_modules/viem/_esm/utils/unit/parseUnits.js
function parseUnits(value, decimals) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
    throw new InvalidDecimalNumberError({ value });
  let [integer, fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right}`));
    if (rounded > 9)
      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
    else
      fraction = `${left}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}

// ../../../node_modules/viem/_esm/utils/unit/parseEther.js
init_unit();
function parseEther(ether, unit = "wei") {
  return parseUnits(ether, etherUnits[unit]);
}

// ../../../node_modules/viem/_esm/utils/formatters/proof.js
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : undefined,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : undefined,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : undefined
  };
}

// ../../../node_modules/viem/_esm/actions/public/getProof.js
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const proof = await client.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}

// ../../../node_modules/viem/_esm/actions/public/getStorageAt.js
init_toHex();
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}

// ../../../node_modules/viem/_esm/actions/public/getTransaction.js
init_transaction();
init_toHex();
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;
  let transaction = null;
  if (hash2) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    }, { dedupe: true });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    }, { dedupe: true });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format = client.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction);
}

// ../../../node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash: hash2, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getAction(client, getBlockNumber, "getBlockNumber")({}),
    hash2 ? getAction(client, getTransaction, "getTransaction")({ hash: hash2 }) : undefined
  ]);
  const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// ../../../node_modules/viem/_esm/actions/public/getTransactionReceipt.js
init_transaction();
async function getTransactionReceipt(client, { hash: hash2 }) {
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  }, { dedupe: true });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format(receipt);
}

// ../../../node_modules/viem/_esm/actions/public/multicall.js
init_abis();
init_abi();
init_base();
init_contract();
init_decodeFunctionResult();
init_encodeFunctionData();
init_getChainContractAddress();
async function multicall(client, parameters) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
  const contracts = parameters.contracts;
  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0;i < contracts.length; i++) {
    const { abi: abi2, address, args, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({ abi: abi2, args, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi: abi2,
        address,
        args,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results = [];
  for (let i = 0;i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j = 0;j < chunkedCalls[i].length; j++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: undefined
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j = 0;j < aggregate3Result.length; j++) {
      const { returnData, success } = aggregate3Result[j];
      const { callData } = chunkedCalls[i][j];
      const { abi: abi2, address, functionName, args } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError;
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi2,
          args,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi: abi2,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: undefined, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError2("multicall results mismatch");
  return results;
}

// ../../../node_modules/ox/_esm/core/version.js
var version3 = "0.1.1";

// ../../../node_modules/ox/_esm/core/internal/errors.js
function getVersion() {
  return version3;
}

// ../../../node_modules/ox/_esm/core/Errors.js
class BaseError3 extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      if (options.cause instanceof BaseError3) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if (options.cause?.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath6 = (() => {
      if (options.cause instanceof BaseError3)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath6 ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath6 ? [
        "",
        details ? `Details: ${details}` : undefined,
        docsPath6 ? `See: ${docs}` : undefined
      ] : []
    ].filter((x) => typeof x === "string").join(`
`);
    super(message, options.cause ? { cause: options.cause } : undefined);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath6;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return walk2(this, fn);
  }
}
function walk2(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk2(err.cause, fn);
  return fn ? null : err;
}

// ../../../node_modules/ox/_esm/core/Json.js
var bigIntSuffix = "#__bigint";
function stringify2(value, replacer, space) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof replacer === "function")
      return replacer(key, value2);
    if (typeof value2 === "bigint")
      return value2.toString() + bigIntSuffix;
    return value2;
  }, space);
}

// ../../../node_modules/ox/_esm/core/internal/bytes.js
function assertSize2(bytes, size_) {
  if (size3(bytes) > size_)
    throw new SizeOverflowError2({
      givenSize: size3(bytes),
      maxSize: size_
    });
}
var charCodeMap2 = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase162(char) {
  if (char >= charCodeMap2.zero && char <= charCodeMap2.nine)
    return char - charCodeMap2.zero;
  if (char >= charCodeMap2.A && char <= charCodeMap2.F)
    return char - (charCodeMap2.A - 10);
  if (char >= charCodeMap2.a && char <= charCodeMap2.f)
    return char - (charCodeMap2.a - 10);
  return;
}
function pad2(bytes, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return bytes;
  if (bytes.length > size4)
    throw new SizeExceedsPaddingSizeError2({
      size: bytes.length,
      targetSize: size4,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size4);
  for (let i = 0;i < size4; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size4 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}

// ../../../node_modules/ox/_esm/core/internal/hex.js
function assertSize3(hex, size_) {
  if (size4(hex) > size_)
    throw new SizeOverflowError3({
      givenSize: size4(hex),
      maxSize: size_
    });
}
function assertStartOffset2(value, start) {
  if (typeof start === "number" && start > 0 && start > size4(value) - 1)
    throw new SliceOffsetOutOfBoundsError3({
      offset: start,
      position: "start",
      size: size4(value)
    });
}
function assertEndOffset2(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size4(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError3({
      offset: end,
      position: "end",
      size: size4(value)
    });
  }
}
function pad3(hex_, options = {}) {
  const { dir, size: size5 = 32 } = options;
  if (size5 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size5 * 2)
    throw new SizeExceedsPaddingSizeError3({
      size: Math.ceil(hex.length / 2),
      targetSize: size5,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size5 * 2, "0")}`;
}

// ../../../node_modules/ox/_esm/core/Bytes.js
var encoder3 = /* @__PURE__ */ new TextEncoder;
function from(value) {
  if (value instanceof Uint8Array)
    return value;
  if (typeof value === "string")
    return fromHex2(value);
  return fromArray(value);
}
function fromArray(value) {
  return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromHex2(value, options = {}) {
  const { size: size5 } = options;
  let hex = value;
  if (size5) {
    assertSize3(value, size5);
    hex = padRight(value, size5);
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index2 = 0, j = 0;index2 < length; index2++) {
    const nibbleLeft = charCodeToBase162(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase162(hexString.charCodeAt(j++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new BaseError3(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function fromString(value, options = {}) {
  const { size: size5 } = options;
  const bytes = encoder3.encode(value);
  if (typeof size5 === "number") {
    assertSize2(bytes, size5);
    return padRight2(bytes, size5);
  }
  return bytes;
}
function padRight2(value, size5) {
  return pad2(value, { dir: "right", size: size5 });
}
function size3(value) {
  return value.length;
}
class SizeOverflowError2 extends BaseError3 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeOverflowError"
    });
  }
}
class SizeExceedsPaddingSizeError2 extends BaseError3 {
  constructor({ size: size5, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size5}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
}

// ../../../node_modules/ox/_esm/core/Hex.js
var encoder4 = /* @__PURE__ */ new TextEncoder;
var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
function assert(value, options = {}) {
  const { strict = false } = options;
  if (!value)
    throw new InvalidHexTypeError(value);
  if (typeof value !== "string")
    throw new InvalidHexTypeError(value);
  if (strict) {
    if (!/^0x[0-9a-fA-F]*$/.test(value))
      throw new InvalidHexValueError(value);
  }
  if (!value.startsWith("0x"))
    throw new InvalidHexValueError(value);
}
function concat2(...values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}
function fromBoolean(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize3(hex, options.size);
    return padLeft(hex, options.size);
  }
  return hex;
}
function fromBytes(value, options = {}) {
  let string = "";
  for (let i = 0;i < value.length; i++)
    string += hexes3[value[i]];
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize3(hex, options.size);
    return padRight(hex, options.size);
  }
  return hex;
}
function fromNumber(value, options = {}) {
  const { signed, size: size5 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size5) {
    if (signed)
      maxValue = (1n << BigInt(size5) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size5) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError2({
      max: maxValue ? `${maxValue}${suffix}` : undefined,
      min: `${minValue}${suffix}`,
      signed,
      size: size5,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size5 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size5)
    return padLeft(hex, size5);
  return hex;
}
function fromString2(value, options = {}) {
  return fromBytes(encoder4.encode(value), options);
}
function padLeft(value, size5) {
  return pad3(value, { dir: "left", size: size5 });
}
function padRight(value, size5) {
  return pad3(value, { dir: "right", size: size5 });
}
function slice2(value, start, end, options = {}) {
  const { strict } = options;
  assertStartOffset2(value, start);
  const value_ = `0x${value.replace("0x", "").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;
  if (strict)
    assertEndOffset2(value_, start, end);
  return value_;
}
function size4(value) {
  return Math.ceil((value.length - 2) / 2);
}
function validate(value, options = {}) {
  const { strict = false } = options;
  try {
    assert(value, { strict });
    return true;
  } catch {
    return false;
  }
}

class IntegerOutOfRangeError2 extends BaseError3 {
  constructor({ max, min, signed, size: size5, value }) {
    super(`Number \`${value}\` is not in safe${size5 ? ` ${size5 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
}
class InvalidHexTypeError extends BaseError3 {
  constructor(value) {
    super(`Value \`${typeof value === "object" ? stringify2(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
      metaMessages: ['Hex types must be represented as `"0x${string}"`.']
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexTypeError"
    });
  }
}

class InvalidHexValueError extends BaseError3 {
  constructor(value) {
    super(`Value \`${value}\` is an invalid hex value.`, {
      metaMessages: [
        'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexValueError"
    });
  }
}
class SizeOverflowError3 extends BaseError3 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
}

class SliceOffsetOutOfBoundsError3 extends BaseError3 {
  constructor({ offset, position, size: size5 }) {
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size5}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SliceOffsetOutOfBoundsError"
    });
  }
}

class SizeExceedsPaddingSizeError3 extends BaseError3 {
  constructor({ size: size5, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size5}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
}

// ../../../node_modules/ox/_esm/core/Withdrawal.js
function toRpc(withdrawal) {
  return {
    address: withdrawal.address,
    amount: fromNumber(withdrawal.amount),
    index: fromNumber(withdrawal.index),
    validatorIndex: fromNumber(withdrawal.validatorIndex)
  };
}

// ../../../node_modules/ox/_esm/core/BlockOverrides.js
function toRpc2(blockOverrides) {
  return {
    ...typeof blockOverrides.baseFeePerGas === "bigint" && {
      baseFeePerGas: fromNumber(blockOverrides.baseFeePerGas)
    },
    ...typeof blockOverrides.blobBaseFee === "bigint" && {
      blobBaseFee: fromNumber(blockOverrides.blobBaseFee)
    },
    ...typeof blockOverrides.feeRecipient === "string" && {
      feeRecipient: blockOverrides.feeRecipient
    },
    ...typeof blockOverrides.gasLimit === "bigint" && {
      gasLimit: fromNumber(blockOverrides.gasLimit)
    },
    ...typeof blockOverrides.number === "bigint" && {
      number: fromNumber(blockOverrides.number)
    },
    ...typeof blockOverrides.prevRandao === "bigint" && {
      prevRandao: fromNumber(blockOverrides.prevRandao)
    },
    ...typeof blockOverrides.time === "bigint" && {
      time: fromNumber(blockOverrides.time)
    },
    ...blockOverrides.withdrawals && {
      withdrawals: blockOverrides.withdrawals.map(toRpc)
    }
  };
}

// ../../../node_modules/viem/_esm/actions/public/simulateBlocks.js
init_abi();
init_contract();
init_node();
init_decodeFunctionResult();
init_encodeFunctionData();
init_toHex();
init_getNodeError();
init_transactionRequest();
init_stateOverride2();
init_assertRequest();
async function simulateBlocks(client, parameters) {
  const { blockNumber, blockTag = "latest", blocks, returnFullTransactions, traceTransfers, validation } = parameters;
  try {
    const blockStateCalls = [];
    for (const block2 of blocks) {
      const blockOverrides = block2.blockOverrides ? toRpc2(block2.blockOverrides) : undefined;
      const calls = block2.calls.map((call_) => {
        const call2 = call_;
        const account = call2.account ? parseAccount(call2.account) : undefined;
        const request = {
          ...call2,
          data: call2.abi ? encodeFunctionData(call2) : call2.data,
          from: call2.from ?? account?.address
        };
        assertRequest(request);
        return formatTransactionRequest(request);
      });
      const stateOverrides = block2.stateOverrides ? serializeStateOverride(block2.stateOverrides) : undefined;
      blockStateCalls.push({
        blockOverrides,
        calls,
        stateOverrides
      });
    }
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const result = await client.request({
      method: "eth_simulateV1",
      params: [
        { blockStateCalls, returnFullTransactions, traceTransfers, validation },
        block
      ]
    });
    return result.map((block2, i) => ({
      ...formatBlock(block2),
      calls: block2.calls.map((call2, j) => {
        const { abi: abi2, args, functionName, to } = blocks[i].calls[j];
        const data = call2.error?.data ?? call2.returnData;
        const gasUsed = BigInt(call2.gasUsed);
        const logs = call2.logs?.map((log) => formatLog(log));
        const status = call2.status === "0x1" ? "success" : "failure";
        const result2 = abi2 && status === "success" ? decodeFunctionResult({
          abi: abi2,
          data,
          functionName
        }) : null;
        const error = (() => {
          if (status === "success")
            return;
          let error2 = undefined;
          if (call2.error?.data === "0x")
            error2 = new AbiDecodingZeroDataError;
          else if (call2.error)
            error2 = new RawContractError(call2.error);
          if (!error2)
            return;
          return getContractError(error2, {
            abi: abi2 ?? [],
            address: to,
            args,
            functionName: functionName ?? "<unknown>"
          });
        })();
        return {
          data,
          gasUsed,
          logs,
          status,
          ...status === "success" ? {
            result: result2
          } : {
            error
          }
        };
      })
    }));
  } catch (e) {
    const cause = e;
    const error = getNodeError(cause, {});
    if (error instanceof UnknownNodeError)
      throw cause;
    throw error;
  }
}

// ../../../node_modules/ox/_esm/core/AbiItem.js
init_exports();

// ../../../node_modules/ox/_esm/core/Hash.js
init_sha3();
function keccak2562(value, options = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes(bytes);
}

// ../../../node_modules/ox/_esm/core/internal/lru.js
class LruMap2 extends Map {
  constructor(size5) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.maxSize = size5;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== undefined) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
}

// ../../../node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: /* @__PURE__ */ new LruMap2(8192)
};
var checksum = caches.checksum;

// ../../../node_modules/ox/_esm/core/Address.js
var addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
function assert2(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex2.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert2(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash2 = keccak2562(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i = 0;i < 40; i += 2) {
    if (hash2[i >> 1] >> 4 >= 8 && characters[i]) {
      characters[i] = characters[i].toUpperCase();
    }
    if ((hash2[i >> 1] & 15) >= 8 && characters[i + 1]) {
      characters[i + 1] = characters[i + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
function validate2(address, options = {}) {
  const { strict = true } = options ?? {};
  try {
    assert2(address, { strict });
    return true;
  } catch {
    return false;
  }
}

class InvalidAddressError2 extends BaseError3 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
}

class InvalidInputError extends BaseError3 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
}

class InvalidChecksumError extends BaseError3 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
}

// ../../../node_modules/ox/_esm/core/internal/abiItem.js
function normalizeSignature2(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0;i < signature.length; i++) {
    const char = signature[i];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", "error", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError3("Unable to normalize signature.");
  return result;
}
function isArgOfType2(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return validate2(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index2) => {
          return isArgOfType2(Object.values(arg)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType2(x, {
          ...abiParameter,
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes2(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes2(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types.includes("address") && types.includes("bytes20"))
        return true;
      if (types.includes("address") && types.includes("string"))
        return validate2(args[parameterIndex], {
          strict: false
        });
      if (types.includes("address") && types.includes("bytes"))
        return validate2(args[parameterIndex], {
          strict: false
        });
      return false;
    })();
    if (ambiguous)
      return types;
  }
  return;
}

// ../../../node_modules/ox/_esm/core/AbiItem.js
function from2(abiItem, options = {}) {
  const { prepare = true } = options;
  const item = (() => {
    if (Array.isArray(abiItem))
      return parseAbiItem(abiItem);
    if (typeof abiItem === "string")
      return parseAbiItem(abiItem);
    return abiItem;
  })();
  return {
    ...item,
    ...prepare ? { hash: getSignatureHash(item) } : {}
  };
}
function fromAbi(abi2, name, options) {
  const { args = [], prepare = true } = options ?? {};
  const isSelector = validate(name, { strict: false });
  const abiItems = abi2.filter((abiItem2) => {
    if (isSelector) {
      if (abiItem2.type === "function" || abiItem2.type === "error")
        return getSelector(abiItem2) === slice2(name, 0, 4);
      if (abiItem2.type === "event")
        return getSignatureHash(abiItem2) === name;
      return false;
    }
    return "name" in abiItem2 && abiItem2.name === name;
  });
  if (abiItems.length === 0)
    throw new NotFoundError({ name });
  if (abiItems.length === 1)
    return {
      ...abiItems[0],
      ...prepare ? { hash: getSignatureHash(abiItems[0]) } : {}
    };
  let matchedAbiItem = undefined;
  for (const abiItem2 of abiItems) {
    if (!("inputs" in abiItem2))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem2.inputs || abiItem2.inputs.length === 0)
        return {
          ...abiItem2,
          ...prepare ? { hash: getSignatureHash(abiItem2) } : {}
        };
      continue;
    }
    if (!abiItem2.inputs)
      continue;
    if (abiItem2.inputs.length === 0)
      continue;
    if (abiItem2.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index2) => {
      const abiParameter = "inputs" in abiItem2 && abiItem2.inputs[index2];
      if (!abiParameter)
        return false;
      return isArgOfType2(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes2(abiItem2.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AmbiguityError({
            abiItem: abiItem2,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem2;
    }
  }
  const abiItem = (() => {
    if (matchedAbiItem)
      return matchedAbiItem;
    const [abiItem2, ...overloads] = abiItems;
    return { ...abiItem2, overloads };
  })();
  if (!abiItem)
    throw new NotFoundError({ name });
  return {
    ...abiItem,
    ...prepare ? { hash: getSignatureHash(abiItem) } : {}
  };
}
function getSelector(abiItem) {
  return slice2(getSignatureHash(abiItem), 0, 4);
}
function getSignature(abiItem) {
  const signature = (() => {
    if (typeof abiItem === "string")
      return abiItem;
    return formatAbiItem(abiItem);
  })();
  return normalizeSignature2(signature);
}
function getSignatureHash(abiItem) {
  if (typeof abiItem !== "string" && "hash" in abiItem && abiItem.hash)
    return abiItem.hash;
  return keccak2562(fromString2(getSignature(abiItem)));
}

class AmbiguityError extends BaseError3 {
  constructor(x, y) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        `\`${x.type}\` in \`${normalizeSignature2(formatAbiItem(x.abiItem))}\`, and`,
        `\`${y.type}\` in \`${normalizeSignature2(formatAbiItem(y.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.AmbiguityError"
    });
  }
}

class NotFoundError extends BaseError3 {
  constructor({ name, data, type = "item" }) {
    const selector = (() => {
      if (name)
        return ` with name "${name}"`;
      if (data)
        return ` with data "${data}"`;
      return "";
    })();
    super(`ABI ${type}${selector} not found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.NotFoundError"
    });
  }
}

// ../../../node_modules/ox/_esm/core/Solidity.js
var arrayRegex = /^(.*)\[([0-9]*)\]$/;
var bytesRegex3 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex3 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt82 = 2n ** (8n - 1n) - 1n;
var maxInt162 = 2n ** (16n - 1n) - 1n;
var maxInt242 = 2n ** (24n - 1n) - 1n;
var maxInt322 = 2n ** (32n - 1n) - 1n;
var maxInt402 = 2n ** (40n - 1n) - 1n;
var maxInt482 = 2n ** (48n - 1n) - 1n;
var maxInt562 = 2n ** (56n - 1n) - 1n;
var maxInt642 = 2n ** (64n - 1n) - 1n;
var maxInt722 = 2n ** (72n - 1n) - 1n;
var maxInt802 = 2n ** (80n - 1n) - 1n;
var maxInt882 = 2n ** (88n - 1n) - 1n;
var maxInt962 = 2n ** (96n - 1n) - 1n;
var maxInt1042 = 2n ** (104n - 1n) - 1n;
var maxInt1122 = 2n ** (112n - 1n) - 1n;
var maxInt1202 = 2n ** (120n - 1n) - 1n;
var maxInt1282 = 2n ** (128n - 1n) - 1n;
var maxInt1362 = 2n ** (136n - 1n) - 1n;
var maxInt1442 = 2n ** (144n - 1n) - 1n;
var maxInt1522 = 2n ** (152n - 1n) - 1n;
var maxInt1602 = 2n ** (160n - 1n) - 1n;
var maxInt1682 = 2n ** (168n - 1n) - 1n;
var maxInt1762 = 2n ** (176n - 1n) - 1n;
var maxInt1842 = 2n ** (184n - 1n) - 1n;
var maxInt1922 = 2n ** (192n - 1n) - 1n;
var maxInt2002 = 2n ** (200n - 1n) - 1n;
var maxInt2082 = 2n ** (208n - 1n) - 1n;
var maxInt2162 = 2n ** (216n - 1n) - 1n;
var maxInt2242 = 2n ** (224n - 1n) - 1n;
var maxInt2322 = 2n ** (232n - 1n) - 1n;
var maxInt2402 = 2n ** (240n - 1n) - 1n;
var maxInt2482 = 2n ** (248n - 1n) - 1n;
var maxInt2562 = 2n ** (256n - 1n) - 1n;
var minInt82 = -(2n ** (8n - 1n));
var minInt162 = -(2n ** (16n - 1n));
var minInt242 = -(2n ** (24n - 1n));
var minInt322 = -(2n ** (32n - 1n));
var minInt402 = -(2n ** (40n - 1n));
var minInt482 = -(2n ** (48n - 1n));
var minInt562 = -(2n ** (56n - 1n));
var minInt642 = -(2n ** (64n - 1n));
var minInt722 = -(2n ** (72n - 1n));
var minInt802 = -(2n ** (80n - 1n));
var minInt882 = -(2n ** (88n - 1n));
var minInt962 = -(2n ** (96n - 1n));
var minInt1042 = -(2n ** (104n - 1n));
var minInt1122 = -(2n ** (112n - 1n));
var minInt1202 = -(2n ** (120n - 1n));
var minInt1282 = -(2n ** (128n - 1n));
var minInt1362 = -(2n ** (136n - 1n));
var minInt1442 = -(2n ** (144n - 1n));
var minInt1522 = -(2n ** (152n - 1n));
var minInt1602 = -(2n ** (160n - 1n));
var minInt1682 = -(2n ** (168n - 1n));
var minInt1762 = -(2n ** (176n - 1n));
var minInt1842 = -(2n ** (184n - 1n));
var minInt1922 = -(2n ** (192n - 1n));
var minInt2002 = -(2n ** (200n - 1n));
var minInt2082 = -(2n ** (208n - 1n));
var minInt2162 = -(2n ** (216n - 1n));
var minInt2242 = -(2n ** (224n - 1n));
var minInt2322 = -(2n ** (232n - 1n));
var minInt2402 = -(2n ** (240n - 1n));
var minInt2482 = -(2n ** (248n - 1n));
var minInt2562 = -(2n ** (256n - 1n));
var maxUint82 = 2n ** 8n - 1n;
var maxUint162 = 2n ** 16n - 1n;
var maxUint242 = 2n ** 24n - 1n;
var maxUint322 = 2n ** 32n - 1n;
var maxUint402 = 2n ** 40n - 1n;
var maxUint482 = 2n ** 48n - 1n;
var maxUint562 = 2n ** 56n - 1n;
var maxUint642 = 2n ** 64n - 1n;
var maxUint722 = 2n ** 72n - 1n;
var maxUint802 = 2n ** 80n - 1n;
var maxUint882 = 2n ** 88n - 1n;
var maxUint962 = 2n ** 96n - 1n;
var maxUint1042 = 2n ** 104n - 1n;
var maxUint1122 = 2n ** 112n - 1n;
var maxUint1202 = 2n ** 120n - 1n;
var maxUint1282 = 2n ** 128n - 1n;
var maxUint1362 = 2n ** 136n - 1n;
var maxUint1442 = 2n ** 144n - 1n;
var maxUint1522 = 2n ** 152n - 1n;
var maxUint1602 = 2n ** 160n - 1n;
var maxUint1682 = 2n ** 168n - 1n;
var maxUint1762 = 2n ** 176n - 1n;
var maxUint1842 = 2n ** 184n - 1n;
var maxUint1922 = 2n ** 192n - 1n;
var maxUint2002 = 2n ** 200n - 1n;
var maxUint2082 = 2n ** 208n - 1n;
var maxUint2162 = 2n ** 216n - 1n;
var maxUint2242 = 2n ** 224n - 1n;
var maxUint2322 = 2n ** 232n - 1n;
var maxUint2402 = 2n ** 240n - 1n;
var maxUint2482 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// ../../../node_modules/ox/_esm/core/internal/abiParameters.js
function prepareParameters({ checksumAddress: checksumAddress2, parameters, values }) {
  const preparedParameters = [];
  for (let i = 0;i < parameters.length; i++) {
    preparedParameters.push(prepareParameter({
      checksumAddress: checksumAddress2,
      parameter: parameters[i],
      value: values[i]
    }));
  }
  return preparedParameters;
}
function prepareParameter({ checksumAddress: checksumAddress2 = false, parameter: parameter_, value }) {
  const parameter = parameter_;
  const arrayComponents = getArrayComponents2(parameter.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray2(value, {
      checksumAddress: checksumAddress2,
      length,
      parameter: {
        ...parameter,
        type
      }
    });
  }
  if (parameter.type === "tuple") {
    return encodeTuple2(value, {
      checksumAddress: checksumAddress2,
      parameter
    });
  }
  if (parameter.type === "address") {
    return encodeAddress2(value, {
      checksum: checksumAddress2
    });
  }
  if (parameter.type === "bool") {
    return encodeBoolean(value);
  }
  if (parameter.type.startsWith("uint") || parameter.type.startsWith("int")) {
    const signed = parameter.type.startsWith("int");
    const [, , size5 = "256"] = integerRegex3.exec(parameter.type) ?? [];
    return encodeNumber2(value, {
      signed,
      size: Number(size5)
    });
  }
  if (parameter.type.startsWith("bytes")) {
    return encodeBytes2(value, { type: parameter.type });
  }
  if (parameter.type === "string") {
    return encodeString2(value);
  }
  throw new InvalidTypeError(parameter.type);
}
function encode(preparedParameters) {
  let staticSize = 0;
  for (let i = 0;i < preparedParameters.length; i++) {
    const { dynamic, encoded } = preparedParameters[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size4(encoded);
  }
  const staticParameters = [];
  const dynamicParameters = [];
  let dynamicSize = 0;
  for (let i = 0;i < preparedParameters.length; i++) {
    const { dynamic, encoded } = preparedParameters[i];
    if (dynamic) {
      staticParameters.push(fromNumber(staticSize + dynamicSize, { size: 32 }));
      dynamicParameters.push(encoded);
      dynamicSize += size4(encoded);
    } else {
      staticParameters.push(encoded);
    }
  }
  return concat2(...staticParameters, ...dynamicParameters);
}
function encodeAddress2(value, options) {
  const { checksum: checksum3 = false } = options;
  assert2(value, { strict: checksum3 });
  return {
    dynamic: false,
    encoded: padLeft(value.toLowerCase())
  };
}
function encodeArray2(value, options) {
  const { checksumAddress: checksumAddress2, length, parameter } = options;
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError2(value);
  if (!dynamic && value.length !== length)
    throw new ArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${parameter.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParameters = [];
  for (let i = 0;i < value.length; i++) {
    const preparedParam = prepareParameter({
      checksumAddress: checksumAddress2,
      parameter,
      value: value[i]
    });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParameters.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encode(preparedParameters);
    if (dynamic) {
      const length2 = fromNumber(preparedParameters.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParameters.length > 0 ? concat2(length2, data) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat2(...preparedParameters.map(({ encoded }) => encoded))
  };
}
function encodeBytes2(value, { type }) {
  const [, parametersize] = type.split("bytes");
  const bytesSize = size4(value);
  if (!parametersize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);
    return {
      dynamic: true,
      encoded: concat2(padLeft(fromNumber(bytesSize, { size: 32 })), value_)
    };
  }
  if (bytesSize !== Number.parseInt(parametersize))
    throw new BytesSizeMismatchError2({
      expectedSize: Number.parseInt(parametersize),
      value
    });
  return { dynamic: false, encoded: padRight(value) };
}
function encodeBoolean(value) {
  if (typeof value !== "boolean")
    throw new BaseError3(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padLeft(fromBoolean(value)) };
}
function encodeNumber2(value, { signed, size: size5 }) {
  if (typeof size5 === "number") {
    const max = 2n ** (BigInt(size5) - (signed ? 1n : 0n)) - 1n;
    const min = signed ? -max - 1n : 0n;
    if (value > max || value < min)
      throw new IntegerOutOfRangeError2({
        max: max.toString(),
        min: min.toString(),
        signed,
        size: size5 / 8,
        value: value.toString()
      });
  }
  return {
    dynamic: false,
    encoded: fromNumber(value, {
      size: 32,
      signed
    })
  };
}
function encodeString2(value) {
  const hexValue = fromString2(value);
  const partsLength = Math.ceil(size4(hexValue) / 32);
  const parts = [];
  for (let i = 0;i < partsLength; i++) {
    parts.push(padRight(slice2(hexValue, i * 32, (i + 1) * 32)));
  }
  return {
    dynamic: true,
    encoded: concat2(padRight(fromNumber(size4(hexValue), { size: 32 })), ...parts)
  };
}
function encodeTuple2(value, options) {
  const { checksumAddress: checksumAddress2, parameter } = options;
  let dynamic = false;
  const preparedParameters = [];
  for (let i = 0;i < parameter.components.length; i++) {
    const param_ = parameter.components[i];
    const index2 = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParameter({
      checksumAddress: checksumAddress2,
      parameter: param_,
      value: value[index2]
    });
    preparedParameters.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encode(preparedParameters) : concat2(...preparedParameters.map(({ encoded }) => encoded))
  };
}
function getArrayComponents2(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;
}

// ../../../node_modules/ox/_esm/core/AbiParameters.js
function encode2(parameters, values, options) {
  const { checksumAddress: checksumAddress2 = false } = options ?? {};
  if (parameters.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: parameters.length,
      givenLength: values.length
    });
  const preparedParameters = prepareParameters({
    checksumAddress: checksumAddress2,
    parameters,
    values
  });
  const data = encode(preparedParameters);
  if (data.length === 0)
    return "0x";
  return data;
}
function encodePacked(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i = 0;i < types.length; i++) {
    const type = types[i];
    const value = values[i];
    data.push(encodePacked.encode(type, value));
  }
  return concat2(...data);
}
(function(encodePacked2) {
  function encode3(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert2(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString2(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex3);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size5 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size5,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex3);
    if (bytesMatch) {
      const [_type, size5] = bytesMatch;
      if (Number.parseInt(size5) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size5),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i = 0;i < value.length; i++) {
        data.push(encode3(childType, value[i], true));
      }
      if (data.length === 0)
        return "0x";
      return concat2(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked2.encode = encode3;
})(encodePacked || (encodePacked = {}));
class ArrayLengthMismatchError extends BaseError3 {
  constructor({ expectedLength, givenLength, type }) {
    super(`Array length mismatch for type \`${type}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.ArrayLengthMismatchError"
    });
  }
}

class BytesSizeMismatchError2 extends BaseError3 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size4(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
}

class LengthMismatchError extends BaseError3 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join(`
`));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
}

class InvalidArrayError2 extends BaseError3 {
  constructor(value) {
    super(`Value \`${value}\` is not a valid array.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidArrayError"
    });
  }
}

class InvalidTypeError extends BaseError3 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
}

// ../../../node_modules/ox/_esm/core/AbiConstructor.js
function encode3(abiConstructor, options) {
  const { bytecode, args } = options;
  return concat2(bytecode, abiConstructor.inputs?.length && args?.length ? encode2(abiConstructor.inputs, args) : "0x");
}
function from3(abiConstructor) {
  return from2(abiConstructor);
}

// ../../../node_modules/ox/_esm/core/AbiFunction.js
function encodeData2(abiFunction, ...args) {
  const { overloads } = abiFunction;
  const item = overloads ? fromAbi2([abiFunction, ...overloads], abiFunction.name, {
    args: args[0]
  }) : abiFunction;
  const selector = getSelector2(item);
  const data = args.length > 0 ? encode2(item.inputs, args[0]) : undefined;
  return data ? concat2(selector, data) : selector;
}
function from4(abiFunction, options = {}) {
  return from2(abiFunction, options);
}
function fromAbi2(abi2, name, options) {
  const item = fromAbi(abi2, name, options);
  if (item.type !== "function")
    throw new NotFoundError({ name, type: "function" });
  return item;
}
function getSelector2(abiItem) {
  return getSelector(abiItem);
}
// ../../../node_modules/viem/_esm/constants/address.js
var ethAddress = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
var zeroAddress = "0x0000000000000000000000000000000000000000";

// ../../../node_modules/viem/_esm/actions/public/simulateCalls.js
init_base();
init_encodeFunctionData();
var getBalanceCode = "0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";
async function simulateCalls(client, parameters) {
  const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation } = parameters;
  const account = parameters.account ? parseAccount(parameters.account) : undefined;
  if (traceAssetChanges && !account)
    throw new BaseError2("`account` is required when `traceAssetChanges` is true");
  const getBalanceData = account ? encode3(from3("constructor(bytes, bytes)"), {
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [
      getBalanceCode,
      encodeData2(from4("function getBalance(address)"), [account.address])
    ]
  }) : undefined;
  const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async (call2) => {
    if (!call2.data && !call2.abi)
      return;
    const { accessList } = await createAccessList(client, {
      account: account.address,
      ...call2,
      data: call2.abi ? encodeFunctionData(call2) : call2.data
    });
    return accessList.map(({ address, storageKeys }) => storageKeys.length > 0 ? address : null);
  })).then((x) => x.flat().filter(Boolean)) : [];
  const resultsStateOverrides = stateOverrides?.map((override) => {
    if (override.address === account?.address)
      return {
        ...override,
        nonce: 0
      };
    return override;
  });
  const blocks = await simulateBlocks(client, {
    blockNumber,
    blockTag,
    blocks: [
      ...traceAssetChanges ? [
        {
          calls: [{ data: getBalanceData }],
          stateOverrides
        },
        {
          calls: assetAddresses.map((address, i) => ({
            abi: [
              from4("function balanceOf(address) returns (uint256)")
            ],
            functionName: "balanceOf",
            args: [account.address],
            to: address,
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        }
      ] : [],
      {
        calls: [...calls, {}].map((call2, index2) => ({
          ...call2,
          from: account?.address,
          nonce: index2
        })),
        stateOverrides: resultsStateOverrides
      },
      ...traceAssetChanges ? [
        {
          calls: [{ data: getBalanceData }]
        },
        {
          calls: assetAddresses.map((address, i) => ({
            abi: [
              from4("function balanceOf(address) returns (uint256)")
            ],
            functionName: "balanceOf",
            args: [account.address],
            to: address,
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        {
          calls: assetAddresses.map((address, i) => ({
            to: address,
            abi: [
              from4("function decimals() returns (uint256)")
            ],
            functionName: "decimals",
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        {
          calls: assetAddresses.map((address, i) => ({
            to: address,
            abi: [
              from4("function tokenURI(uint256) returns (string)")
            ],
            functionName: "tokenURI",
            args: [0n],
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        {
          calls: assetAddresses.map((address, i) => ({
            to: address,
            abi: [from4("function symbol() returns (string)")],
            functionName: "symbol",
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        }
      ] : []
    ],
    traceTransfers,
    validation
  });
  const block_results = traceAssetChanges ? blocks[2] : blocks[0];
  const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];
  const { calls: block_calls, ...block } = block_results;
  const results = block_calls.slice(0, -1) ?? [];
  const ethPre = block_ethPre?.calls ?? [];
  const assetsPre = block_assetsPre?.calls ?? [];
  const balancesPre = [...ethPre, ...assetsPre].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
  const ethPost = block_ethPost?.calls ?? [];
  const assetsPost = block_assetsPost?.calls ?? [];
  const balancesPost = [...ethPost, ...assetsPost].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
  const decimals = (block_decimals?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
  const symbols = (block_symbols?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
  const tokenURI = (block_tokenURI?.calls ?? []).map((x) => x.status === "success" ? x.result : null);
  const changes = [];
  for (const [i, balancePost] of balancesPost.entries()) {
    const balancePre = balancesPre[i];
    if (typeof balancePost !== "bigint")
      continue;
    if (typeof balancePre !== "bigint")
      continue;
    const decimals_ = decimals[i - 1];
    const symbol_ = symbols[i - 1];
    const tokenURI_ = tokenURI[i - 1];
    const token = (() => {
      if (i === 0)
        return {
          address: ethAddress,
          decimals: 18,
          symbol: "ETH"
        };
      return {
        address: assetAddresses[i - 1],
        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,
        symbol: symbol_ ?? undefined
      };
    })();
    if (changes.some((change) => change.token.address === token.address))
      continue;
    changes.push({
      token,
      value: {
        pre: balancePre,
        post: balancePost,
        diff: balancePost - balancePre
      }
    });
  }
  return {
    assetChanges: changes,
    block,
    results
  };
}

// ../../../node_modules/viem/_esm/actions/public/verifyHash.js
init_abis();
init_contract();
init_encodeDeployData();
init_getAddress();
init_isAddressEqual();
init_toHex();

// ../../../node_modules/viem/_esm/utils/signature/serializeSignature.js
init_secp256k1();
init_fromHex();
init_toBytes();
function serializeSignature({ r, s, to = "hex", v, yParity }) {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n))
      return v % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
  if (to === "hex")
    return signature;
  return hexToBytes(signature);
}

// ../../../node_modules/viem/_esm/actions/public/verifyHash.js
init_call();
async function verifyHash(client, parameters) {
  const { address, factory, factoryData, hash: hash2, signature, universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address, ...rest } = parameters;
  const signatureHex = (() => {
    if (isHex(signature))
      return signature;
    if (typeof signature === "object" && "r" in signature && "s" in signature)
      return serializeSignature(signature);
    return bytesToHex(signature);
  })();
  const wrappedSignature = await (async () => {
    if (!factory && !factoryData)
      return signatureHex;
    if (isErc6492Signature(signatureHex))
      return signatureHex;
    return serializeErc6492Signature({
      address: factory,
      data: factoryData,
      signature: signatureHex
    });
  })();
  try {
    const args = universalSignatureVerifierAddress ? {
      to: universalSignatureVerifierAddress,
      data: encodeFunctionData({
        abi: universalSignatureValidatorAbi,
        functionName: "isValidSig",
        args: [address, hash2, wrappedSignature]
      }),
      ...rest
    } : {
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash2, wrappedSignature],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...rest
    };
    const { data } = await getAction(client, call, "call")(args);
    return hexToBool(data ?? "0x0");
  } catch (error) {
    try {
      const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash: hash2, signature }));
      if (verified)
        return true;
    } catch {
    }
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}

// ../../../node_modules/viem/_esm/actions/public/verifyMessage.js
async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {
  const hash2 = hashMessage(message);
  return verifyHash(client, {
    address,
    factory,
    factoryData,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// ../../../node_modules/viem/_esm/actions/public/verifyTypedData.js
async function verifyTypedData(client, parameters) {
  const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;
  const hash2 = hashTypedData({ message, primaryType, types, domain });
  return verifyHash(client, {
    address,
    factory,
    factoryData,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// ../../../node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
init_transaction();
// ../../../node_modules/viem/_esm/actions/public/watchBlockNumber.js
init_fromHex();
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      try {
        const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n;i < blockNumber; i++) {
              emit.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              if (!active)
                return;
              const blockNumber = hexToBigInt(data.result?.number);
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

// ../../../node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, {
  confirmations = 1,
  hash: hash2,
  onReplaced,
  pollingInterval = client.pollingInterval,
  retryCount = 6,
  retryDelay = ({ count }) => ~~(1 << count) * 200,
  timeout = 180000
}) {
  const observerId = stringify(["waitForTransactionReceipt", client.uid, hash2]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  const { promise, resolve, reject } = withResolvers();
  const timer = timeout ? setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout) : undefined;
  const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
    const _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
      emitMissed: true,
      emitOnBegin: true,
      poll: true,
      pollingInterval,
      async onBlockNumber(blockNumber_) {
        const done = (fn) => {
          clearTimeout(timer);
          _unwatch();
          fn();
          _unobserve();
        };
        let blockNumber = blockNumber_;
        if (retrying)
          return;
        try {
          if (receipt) {
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
            return;
          }
          if (!transaction) {
            retrying = true;
            await withRetry(async () => {
              transaction = await getAction(client, getTransaction, "getTransaction")({ hash: hash2 });
              if (transaction.blockNumber)
                blockNumber = transaction.blockNumber;
            }, {
              delay: retryDelay,
              retryCount
            });
            retrying = false;
          }
          receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
            return;
          done(() => emit.resolve(receipt));
        } catch (err) {
          if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {
            if (!transaction) {
              retrying = false;
              return;
            }
            try {
              replacedTransaction = transaction;
              retrying = true;
              const block = await withRetry(() => getAction(client, getBlock, "getBlock")({
                blockNumber,
                includeTransactions: true
              }), {
                delay: retryDelay,
                retryCount,
                shouldRetry: ({ error }) => error instanceof BlockNotFoundError
              });
              retrying = false;
              const replacementTransaction = block.transactions.find(({ from: from5, nonce }) => from5 === replacedTransaction.from && nonce === replacedTransaction.nonce);
              if (!replacementTransaction)
                return;
              receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                hash: replacementTransaction.hash
              });
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              let reason = "replaced";
              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {
                reason = "repriced";
              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                reason = "cancelled";
              }
              done(() => {
                emit.onReplaced?.({
                  reason,
                  replacedTransaction,
                  transaction: replacementTransaction,
                  transactionReceipt: receipt
                });
                emit.resolve(receipt);
              });
            } catch (err_) {
              done(() => emit.reject(err_));
            }
          } else {
            done(() => emit.reject(err));
          }
        }
      }
    });
  });
  return promise;
}
// ../../../node_modules/viem/_esm/actions/public/watchBlocks.js
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client.uid,
      blockTag,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      try {
        const block = await getAction(client, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block.number && prevBlock?.number) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = prevBlock?.number + 1n;i < block.number; i++) {
              const block2 = await getAction(client, getBlock, "getBlock")({
                blockNumber: i,
                includeTransactions
              });
              emit.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
          emit.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let emitFetched = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        if (emitOnBegin) {
          getAction(client, getBlock, "getBlock")({
            blockTag,
            includeTransactions
          }).then((block) => {
            if (!active)
              return;
            if (!emitFetched)
              return;
            onBlock(block, undefined);
            emitFetched = false;
          });
        }
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["newHeads"],
          async onData(data) {
            if (!active)
              return;
            const block = await getAction(client, getBlock, "getBlock")({
              blockNumber: data.blockNumber,
              includeTransactions
            }).catch(() => {
            });
            if (!active)
              return;
            onBlock(block, prevBlock);
            emitFetched = false;
            prevBlock = block;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}

// ../../../node_modules/viem/_esm/actions/public/watchEvent.js
init_abi();
init_rpc();
function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== undefined)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createEventFilter, "createEventFilter")({
              address,
              args,
              event,
              events,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getLogs, "getLogs")({
                address,
                args,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const events_ = events ?? (event ? [event] : undefined);
        let topics = [];
        if (events_) {
          const encoded = events_.flatMap((event2) => encodeEventTopics({
            abi: [event2],
            eventName: event2.name,
            args
          }));
          topics = [encoded];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_ ?? [],
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog(log, { args: args2, eventName });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !(("name" in x) && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}
// ../../../node_modules/viem/_esm/actions/public/watchPendingTransactions.js
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter;
      const unwatch = poll(async () => {
        try {
          if (!filter) {
            try {
              filter = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            for (const hash2 of hashes)
              emit.onTransactions([hash2]);
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction = data.result;
            onTransactions([transaction]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

// ../../../node_modules/viem/_esm/utils/siwe/parseSiweMessage.js
function parseSiweMessage(message) {
  const { scheme, statement, ...prefix } = message.match(prefixRegex)?.groups ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = message.match(suffixRegex)?.groups ?? {};
  const resources = message.split("Resources:")[1]?.split(`
- `).slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;

// ../../../node_modules/viem/_esm/utils/siwe/validateSiweMessage.js
init_isAddressEqual();
function validateSiweMessage(parameters) {
  const { address, domain, message, nonce, scheme, time = new Date } = parameters;
  if (domain && message.domain !== domain)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time >= message.expirationTime)
    return false;
  if (message.notBefore && time < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isAddressEqual(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}

// ../../../node_modules/viem/_esm/actions/siwe/verifySiweMessage.js
async function verifySiweMessage(client, parameters) {
  const { address, domain, message, nonce, scheme, signature, time = new Date, ...callRequest } = parameters;
  const parsed = parseSiweMessage(message);
  if (!parsed.address)
    return false;
  const isValid = validateSiweMessage({
    address,
    domain,
    message: parsed,
    nonce,
    scheme,
    time
  });
  if (!isValid)
    return false;
  const hash2 = hashMessage(message);
  return verifyHash(client, {
    address: parsed.address,
    hash: hash2,
    signature,
    ...callRequest
  });
}

// ../../../node_modules/viem/_esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (args) => call(client, args),
    createAccessList: (args) => createAccessList(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlobBaseFee: () => getBlobBaseFee(client),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getCode(client, args),
    getChainId: () => getChainId(client),
    getCode: (args) => getCode(client, args),
    getContractEvents: (args) => getContractEvents(client, args),
    getEip712Domain: (args) => getEip712Domain(client, args),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args),
    getProof: (args) => getProof(client, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    readContract: (args) => readContract(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    simulate: (args) => simulateBlocks(client, args),
    simulateBlocks: (args) => simulateBlocks(client, args),
    simulateCalls: (args) => simulateCalls(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage(client, args),
    verifySiweMessage: (args) => verifySiweMessage(client, args),
    verifyTypedData: (args) => verifyTypedData(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  };
}

// ../../../node_modules/viem/_esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}
// ../../../node_modules/viem/_esm/index.js
init_decodeAbiParameters();
init_encodeAbiParameters();
init_toBytes();
init_fromHex();
init_isAddress();
init_keccak256();
// ../common/reportBytes.ts
var COMMON_REPORT_BYTE_OFFSETS = {
  REPORT_TYPE: 248,
  VERSION: 240,
  REQUESTER: 0,
  REQUESTER_MASK: (1n << 160n) - 1n
};

// ../common/packReportConfig.ts
function packReportConfig(reportType, version4, requester) {
  if (reportType < 0 || reportType > 255)
    throw new Error("reportType must be a uint8 (0-255)");
  if (version4 < 0 || version4 > 255)
    throw new Error("version must be a uint8 (0-255)");
  const reportTypeBits = BigInt(reportType) << BigInt(COMMON_REPORT_BYTE_OFFSETS.REPORT_TYPE);
  const versionBits = BigInt(version4) << BigInt(COMMON_REPORT_BYTE_OFFSETS.VERSION);
  const requesterBits = hexToBigInt(requester) & COMMON_REPORT_BYTE_OFFSETS.REQUESTER_MASK;
  const packedValue = reportTypeBits | versionBits | requesterBits;
  return `0x${packedValue.toString(16).padStart(64, "0")}`;
}

// ../common/config.ts
function isDevelopment() {
  try {
    return secrets?.CONCERO_CLF_DEVELOPMENT === "true";
  } catch {
    return false;
  }
}
function getLocalhostRpcUrl() {
  try {
    return secrets?.LOCALHOST_RPC_URL;
  } catch {
    return;
  }
}
var config = {
  isDevelopment: isDevelopment(),
  localhostRpcUrl: getLocalhostRpcUrl()
};
// ../common/rpcs/1.json
var _1_default = {
  id: "1",
  urls: [
    "virginia.rpc.blxrbdn.com/",
    "uk.rpc.blxrbdn.com/",
    "eth.rpc.blxrbdn.com/",
    "singapore.rpc.blxrbdn.com/",
    "mainnet.gateway.tenderly.co",
    "rpc.ankr.com/eth",
    "eth-mainnet.public.blastapi.io",
    "eth.drpc.org",
    "gateway.tenderly.co/public/mainnet",
    "ethereum-rpc.publicnode.com",
    "rpc.mevblocker.io",
    "rpc.eth.gateway.fm",
    "ethereum.blockpi.network/v1/rpc/public",
    "eth.merkle.io",
    "rpc.flashbots.net/",
    "core.gashawk.io/rpc",
    "rpc.graffiti.farm",
    "eth.blockrazor.xyz",
    "1rpc.io/eth",
    "api.securerpc.com/v1",
    "0xrpc.io/eth",
    "eth.nodeconnect.org/",
    "eth-mainnet.4everland.org/v1/37fa9972c1b1cd5fab542c7bdd4cde2f",
    "rpc.payload.de",
    "endpoints.omniatech.io/v1/eth/mainnet/public",
    "eth-pokt.nodies.app",
    "eth.meowrpc.com",
    "openapi.bitstack.com/v1/wNFxbiJyQsSeLrX8RRCHi7NpRxrlErZk/DjShIqLishPCTB9HiMkPHXjUM9CNM9Na/ETH/mainnet",
    "api.zan.top/eth-mainnet"
  ],
  chainSelector: 1
};
// ../common/rpcs/10.json
var _10_default = {
  id: "10",
  urls: [
    "rpc.ankr.com/optimism",
    "gateway.tenderly.co/public/optimism",
    "go.getblock.io/e8a75f8dcf614861becfbcb185be6eb4",
    "opt-mainnet.4everland.org/v1/37fa9972c1b1cd5fab542c7bdd4cde2f",
    "op-pokt.nodies.app",
    "optimism-mainnet.public.blastapi.io",
    "optimism.blockpi.network/v1/rpc/public",
    "optimism-rpc.publicnode.com",
    "optimism.meowrpc.com",
    "optimism.api.onfinality.io/public",
    "0xrpc.io/op",
    "optimism.gateway.tenderly.co",
    "1rpc.io/op",
    "endpoints.omniatech.io/v1/op/mainnet/public",
    "optimism.lava.build",
    "optimism.drpc.org",
    "api.zan.top/opt-mainnet"
  ],
  chainSelector: 10
};
// ../common/rpcs/137.json
var _137_default = {
  id: "137",
  urls: [
    "gateway.tenderly.co/public/polygon",
    "go.getblock.io/02667b699f05444ab2c64f9bff28f027",
    "endpoints.omniatech.io/v1/matic/mainnet/public",
    "rpc.ankr.com/polygon",
    "polygon-bor-rpc.publicnode.com",
    "polygon.gateway.tenderly.co",
    "polygon.meowrpc.com",
    "polygon.drpc.org",
    "polygon-mainnet.4everland.org/v1/37fa9972c1b1cd5fab542c7bdd4cde2f",
    "1rpc.io/matic",
    "api.zan.top/polygon-mainnet",
    "polygon-mainnet.public.blastapi.io",
    "polygon-pokt.nodies.app",
    "polygon.lava.build",
    "polygon.api.onfinality.io/public",
    "rpc-mainnet.matic.quiknode.pro"
  ],
  chainSelector: 137
};
// ../common/rpcs/8453.json
var _8453_default = {
  id: "8453",
  urls: [
    "gateway.tenderly.co/public/base",
    "endpoints.omniatech.io/v1/base/mainnet/public",
    "base-mainnet.public.blastapi.io",
    "base.gateway.tenderly.co",
    "base-rpc.publicnode.com",
    "base.meowrpc.com",
    "base.lava.build",
    "base.blockpi.network/v1/rpc/public",
    "base.drpc.org",
    "1rpc.io/base",
    "base-pokt.nodies.app",
    "0xrpc.io/base",
    "api.zan.top/base-mainnet",
    "base.api.onfinality.io/public"
  ],
  chainSelector: 8453
};
// ../common/rpcs/42161.json
var _42161_default = {
  id: "42161",
  urls: [
    "rpc.ankr.com/arbitrum",
    "arbitrum-one.public.blastapi.io",
    "arbitrum.meowrpc.com",
    "arbitrum.blockpi.network/v1/rpc/public",
    "arbitrum.drpc.org",
    "arbitrum.gateway.tenderly.co",
    "arb1.lava.build",
    "1rpc.io/arb",
    "arbitrum-one-rpc.publicnode.com",
    "arb-pokt.nodies.app",
    "api.zan.top/arb-one",
    "endpoints.omniatech.io/v1/arbitrum/one/public"
  ],
  chainSelector: 42161
};
// ../common/rpcs/43113.json
var _43113_default = {
  id: "43113",
  urls: [
    "rpc.ankr.com/avalanche_fuji",
    "endpoints.omniatech.io/v1/avax/fuji/public",
    "avalanche-fuji-c-chain-rpc.publicnode.com",
    "avalanche-fuji.drpc.org",
    "ava-testnet.public.blastapi.io/ext/bc/C/rpc",
    "api.zan.top/avax-fuji/ext/bc/C/rpc"
  ],
  chainSelector: 43113
};
// ../common/rpcs/43114.json
var _43114_default = {
  id: "43114",
  urls: [
    "rpc.ankr.com/avalanche",
    "endpoints.omniatech.io/v1/avax/mainnet/public",
    "1rpc.io/avax/c",
    "avalanche-mainnet.gateway.tenderly.co",
    "avax.meowrpc.com",
    "avalanche.drpc.org",
    "ava-mainnet.public.blastapi.io/ext/bc/C/rpc",
    "avalanche-c-chain-rpc.publicnode.com",
    "avax-pokt.nodies.app/ext/bc/C/rpc",
    "api.zan.top/avax-mainnet/ext/bc/C/rpc",
    "0xrpc.io/avax",
    "avalanche.api.onfinality.io/public/ext/bc/C/rpc"
  ],
  chainSelector: 43114
};
// ../common/rpcs/80002.json
var _80002_default = {
  id: "80002",
  urls: [
    "rpc.ankr.com/polygon_amoy",
    "polygon-amoy.gateway.tenderly.co",
    "polygon-amoy.drpc.org",
    "api.zan.top/polygon-amoy"
  ],
  chainSelector: 80002
};
// ../common/rpcs/84532.json
var _84532_default = {
  id: "84532",
  urls: [
    "base-sepolia.gateway.tenderly.co",
    "base-sepolia.drpc.org"
  ],
  chainSelector: 84532
};
// ../common/rpcs/421614.json
var _421614_default = {
  id: "421614",
  urls: [
    "endpoints.omniatech.io/v1/arbitrum/sepolia/public",
    "arbitrum-sepolia.gateway.tenderly.co",
    "arbitrum-sepolia.drpc.org",
    "api.zan.top/arb-sepolia"
  ],
  chainSelector: 421614
};
// ../common/rpcs/11155111.json
var _11155111_default = {
  id: "11155111",
  urls: [
    "gateway.tenderly.co/public/sepolia",
    "eth-sepolia.public.blastapi.io",
    "ethereum-sepolia-rpc.publicnode.com",
    "sepolia.gateway.tenderly.co",
    "eth-sepolia.api.onfinality.io/public",
    "1rpc.io/sepolia",
    "eth-testnet.4everland.org/v1/37fa9972c1b1cd5fab542c7bdd4cde2f",
    "api.zan.top/eth-sepolia",
    "0xrpc.io/sep",
    "endpoints.omniatech.io/v1/eth/sepolia/public"
  ],
  chainSelector: 11155111
};
// ../common/rpcs/11155420.json
var _11155420_default = {
  id: "11155420",
  urls: [
    "endpoints.omniatech.io/v1/op/sepolia/public",
    "optimism-sepolia.gateway.tenderly.co",
    "optimism-sepolia.api.onfinality.io/public",
    "api.zan.top/opt-sepolia"
  ],
  chainSelector: 11155420
};

// ../common/rpcLoader.ts
var rpcConfigs = {
  "1": _1_default,
  "10": _10_default,
  "11155111": _11155111_default,
  "11155420": _11155420_default,
  "137": _137_default,
  "42161": _42161_default,
  "421614": _421614_default,
  "43113": _43113_default,
  "43114": _43114_default,
  "80002": _80002_default,
  "8453": _8453_default,
  "84532": _84532_default
};

// ../../../node_modules/viem/_esm/op-stack/contracts.js
var contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};

// ../../../node_modules/viem/_esm/op-stack/formatters.js
init_fromHex();
var formatters = {
  block: /* @__PURE__ */ defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction.isSystemTx;
          formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : undefined;
          formatted.sourceHash = transaction.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x7e") {
        transaction.isSystemTx = args.isSystemTx;
        transaction.mint = args.mint ? hexToBigInt(args.mint) : undefined;
        transaction.sourceHash = args.sourceHash;
        transaction.type = "deposit";
      }
      return transaction;
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};

// ../../../node_modules/viem/_esm/op-stack/serializers.js
init_address();
init_isAddress();
init_toHex();
function serializeTransaction2(transaction, signature) {
  if (isDeposit(transaction))
    return serializeTransactionDeposit(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers = {
  transaction: serializeTransaction2
};
function serializeTransactionDeposit(transaction) {
  assertTransactionDeposit(transaction);
  const { sourceHash, data, from: from5, gas, isSystemTx, mint, to, value } = transaction;
  const serializedTransaction = [
    sourceHash,
    from5,
    to ?? "0x",
    mint ? toHex(mint) : "0x",
    value ? toHex(value) : "0x",
    gas ? toHex(gas) : "0x",
    isSystemTx ? "0x1" : "0x",
    data ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(serializedTransaction)
  ]);
}
function isDeposit(transaction) {
  if (transaction.type === "deposit")
    return true;
  if (typeof transaction.sourceHash !== "undefined")
    return true;
  return false;
}
function assertTransactionDeposit(transaction) {
  const { from: from5, to } = transaction;
  if (from5 && !isAddress(from5))
    throw new InvalidAddressError({ address: from5 });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
}

// ../../../node_modules/viem/_esm/op-stack/chainConfig.js
var chainConfig = {
  contracts,
  formatters,
  serializers
};

// ../../../node_modules/viem/_esm/chains/definitions/arbitrum.js
var arbitrum = /* @__PURE__ */ defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});
// ../../../node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
var arbitrumSepolia = /* @__PURE__ */ defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});
// ../../../node_modules/viem/_esm/chains/definitions/avalanche.js
var avalanche = /* @__PURE__ */ defineChain({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});
// ../../../node_modules/viem/_esm/chains/definitions/avalancheFuji.js
var avalancheFuji = /* @__PURE__ */ defineChain({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: true
});
// ../../../node_modules/viem/_esm/chains/definitions/base.js
var sourceId = 1;
var base = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [sourceId]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [sourceId]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId
});
// ../../../node_modules/viem/_esm/chains/definitions/baseSepolia.js
var sourceId2 = 11155111;
var baseSepolia = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId2]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [sourceId2]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [sourceId2]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [sourceId2]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: sourceId2
});
// ../../../node_modules/viem/_esm/chains/definitions/mainnet.js
var mainnet = /* @__PURE__ */ defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
// ../../../node_modules/viem/_esm/chains/definitions/optimism.js
var sourceId3 = 1;
var optimism = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId3]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [sourceId3]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId3]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId3]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: sourceId3
});
// ../../../node_modules/viem/_esm/chains/definitions/optimismSepolia.js
var sourceId4 = 11155111;
var optimismSepolia = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    disputeGameFactory: {
      [sourceId4]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [sourceId4]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [sourceId4]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [sourceId4]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: true,
  sourceId: sourceId4
});
// ../../../node_modules/viem/_esm/chains/definitions/polygon.js
var polygon = /* @__PURE__ */ defineChain({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});
// ../../../node_modules/viem/_esm/chains/definitions/polygonAmoy.js
var polygonAmoy = /* @__PURE__ */ defineChain({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: true
});
// ../../../node_modules/viem/_esm/chains/definitions/sepolia.js
var sepolia = /* @__PURE__ */ defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: true
});
// ../common/viemChains.ts
var localhostChain = defineChain({
  id: 1,
  name: "localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: config.localhostRpcUrl
    }
  }
});
var localhostChains = {
  "1": localhostChain,
  "10": localhostChain
};
var liveChains = {
  "1": mainnet,
  "10": optimism,
  "8453": base,
  "421614": arbitrumSepolia,
  "84532": baseSepolia
};
var viemChains = config.isDevelopment ? localhostChains : liveChains;

// ../common/viemClient.ts
function getRpcConfigForChain(chainSelector) {
  if (config.isDevelopment) {
    return {
      id: chainSelector,
      urls: [config.localhostRpcUrl]
    };
  }
  return rpcConfigs[chainSelector];
}
function createFallbackTransport(chainSelector) {
  const rpcConfig = getRpcConfigForChain(chainSelector);
  if (!rpcConfig || !rpcConfig.urls || rpcConfig.urls.length === 0) {
    handleError(22 /* NO_RPC_PROVIDERS */);
  }
  const transportFactories = rpcConfig.urls.map((url) => http(url.startsWith("http") ? url : `https://${url}`, { batch: true }));
  return fallback(transportFactories);
}
function getPublicClient(chainSelector) {
  return createPublicClient({
    transport: createFallbackTransport(chainSelector),
    chain: viemChains[chainSelector]
  });
}

// ../../../utils/configureDotEnv.ts
var envEnc = __toESM(require_dist(), 1);
var dotenv = __toESM(require_main(), 1);
var { default: fs} = (() => ({}));
var ENV_FILES = [
  ".env",
  ".env.clf",
  ".env.clccip",
  ".env.tokens",
  ".env.deployments.mainnet",
  ".env.deployments.testnet",
  ".env.deployments.localhost",
  ".env.wallets"
];
function configureDotEnv(basePath = "./") {
  const normalizedBasePath = basePath.endsWith("/") ? basePath : `${basePath}/`;
  ENV_FILES.forEach((file) => {
    dotenv.config({ path: `${normalizedBasePath}${file}` });
  });
  envEnc.config({ path: process.env.PATH_TO_ENC_FILE });
}
configureDotEnv();

// ../../../../../../../../../bun-vfs$$/node_modules/process/index.js
var C3 = Object.create;
var T3 = Object.defineProperty;
var q2 = Object.getOwnPropertyDescriptor;
var A4 = Object.getOwnPropertyNames;
var I4 = Object.getPrototypeOf;
var Q3 = Object.prototype.hasOwnProperty;
var S2 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var N7 = (e, t) => {
  for (var n in t)
    T3(e, n, { get: t[n], enumerable: true });
};
var d4 = (e, t, n, w2) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let l3 of A4(t))
      !Q3.call(e, l3) && l3 !== n && T3(e, l3, { get: () => t[l3], enumerable: !(w2 = q2(t, l3)) || w2.enumerable });
  return e;
};
var h4 = (e, t, n) => (d4(e, t, "default"), n && d4(n, t, "default"));
var y4 = (e, t, n) => (n = e != null ? C3(I4(e)) : {}, d4(t || !e || !e.__esModule ? T3(n, "default", { value: e, enumerable: true }) : n, e));
var v2 = S2((B3, E6) => {
  var r = E6.exports = {}, i, u3;
  function p4() {
    throw new Error("setTimeout has not been defined");
  }
  function g4() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? i = setTimeout : i = p4;
    } catch {
      i = p4;
    }
    try {
      typeof clearTimeout == "function" ? u3 = clearTimeout : u3 = g4;
    } catch {
      u3 = g4;
    }
  })();
  function b4(e) {
    if (i === setTimeout)
      return setTimeout(e, 0);
    if ((i === p4 || !i) && setTimeout)
      return i = setTimeout, setTimeout(e, 0);
    try {
      return i(e, 0);
    } catch {
      try {
        return i.call(null, e, 0);
      } catch {
        return i.call(this, e, 0);
      }
    }
  }
  function O3(e) {
    if (u3 === clearTimeout)
      return clearTimeout(e);
    if ((u3 === g4 || !u3) && clearTimeout)
      return u3 = clearTimeout, clearTimeout(e);
    try {
      return u3(e);
    } catch {
      try {
        return u3.call(null, e);
      } catch {
        return u3.call(this, e);
      }
    }
  }
  var o2 = [], s3 = false, a3, m4 = -1;
  function U3() {
    !s3 || !a3 || (s3 = false, a3.length ? o2 = a3.concat(o2) : m4 = -1, o2.length && x4());
  }
  function x4() {
    if (!s3) {
      var e = b4(U3);
      s3 = true;
      for (var t = o2.length;t; ) {
        for (a3 = o2, o2 = [];++m4 < t; )
          a3 && a3[m4].run();
        m4 = -1, t = o2.length;
      }
      a3 = null, s3 = false, O3(e);
    }
  }
  r.nextTick = function(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n = 1;n < arguments.length; n++)
        t[n - 1] = arguments[n];
    o2.push(new L4(e, t)), o2.length === 1 && !s3 && b4(x4);
  };
  function L4(e, t) {
    this.fun = e, this.array = t;
  }
  L4.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  r.title = "browser";
  r.browser = true;
  r.env = {};
  r.argv = [];
  r.version = "";
  r.versions = {};
  function c2() {
  }
  r.on = c2;
  r.addListener = c2;
  r.once = c2;
  r.off = c2;
  r.removeListener = c2;
  r.removeAllListeners = c2;
  r.emit = c2;
  r.prependListener = c2;
  r.prependOnceListener = c2;
  r.listeners = function(e) {
    return [];
  };
  r.binding = function(e) {
    throw new Error("process.binding is not supported");
  };
  r.cwd = function() {
    return "/";
  };
  r.chdir = function(e) {
    throw new Error("process.chdir is not supported");
  };
  r.umask = function() {
    return 0;
  };
});
var f2 = {};
N7(f2, { default: () => j6 });
h4(f2, y4(v2()));
var j6 = y4(v2());

// ../../../utils/getEnvVar.ts
function getEnvVar(key) {
  const value = j6.env[key];
  if (value === undefined)
    throw new Error(`Missing required environment variable ${key}`);
  if (value === "")
    throw new Error(`${key} must not be empty`);
  return value;
}

// ../../../utils/getWallet.ts
function getWallet(chainType, accountType, walletType) {
  let prefix;
  let walletKey;
  switch (accountType) {
    case "proxyDeployer":
      prefix = "PROXY_DEPLOYER";
      break;
    case "deployer":
      prefix = "DEPLOYER";
      break;
    case "operator":
      prefix = "OPERATOR";
      break;
    default:
      throw new Error(`Unknown account type: ${accountType}`);
  }
  switch (walletType) {
    case "privateKey":
      walletKey = "PRIVATE_KEY";
      break;
    case "address":
      walletKey = "ADDRESS";
      break;
    default:
      throw new Error(`Unknown wallet type: ${walletType}`);
  }
  const envKey = `${chainType.toUpperCase()}_${prefix}_${walletKey}`;
  const walletValue = process.env[envKey];
  if (!walletValue) {
    throw new Error(`Environment variable ${envKey} is not set.`);
  }
  return walletValue;
}

// ../../../utils/localhostViemChain.ts
var localhostViemChain = defineChain({
  id: Number(process.env.LOCALHOST_FORK_CHAIN_ID),
  name: "localhost",
  nativeCurrency: {
    decimals: 18,
    name: "eth",
    symbol: "eth"
  },
  rpcUrls: {
    default: { http: [process.env.LOCALHOST_RPC_URL] }
  },
  testnet: true
});
var hardhatViemChain = defineChain({
  id: Number(process.env.HARDHAT_CHAIN_ID),
  name: "hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "eth",
    symbol: "eth"
  },
  rpcUrls: {
    default: { http: [process.env.HARDHAT_RPC_URL] }
  },
  testnet: true
});

// ../../../utils/getGasParameters.ts
var NETWORK_MINIMUMS = {
  polygon: {
    minTipCap: BigInt(30000000000),
    minBaseFee: BigInt(30000000000)
  }
};

// ../../../utils/updateEnvVariable.ts
init_path();
var {readFileSync, writeFileSync} = (() => ({}));
var __dirname = "/Users/user/Documents/GitHub/concero/v2-contracts/utils";

// ../../../constants/rpcUrls.ts
var { INFURA_API_KEY, ALCHEMY_API_KEY, BLAST_API_KEY, CHAINSTACK_API_KEY, TENDERLY_API_KEY } = process.env;
var rpcUrl = {
  hardhat: getEnvVar("HARDHAT_RPC_URL"),
  localhost: getEnvVar("LOCALHOST_RPC_URL"),
  arbitrum: `https://arbitrum-mainnet.infura.io/v3/${INFURA_API_KEY}`,
  arbitrumSepolia: `https://arbitrum-sepolia.infura.io/v3/${INFURA_API_KEY}`,
  base: `https://base-sepolia.infura.io/v3/${INFURA_API_KEY}`,
  baseSepolia: `https://base-sepolia.infura.io/v3/${INFURA_API_KEY}`,
  avalanche: `https://avalanche-mainnet.infura.io/v3/${INFURA_API_KEY}`,
  avalancheFuji: `https://avalanche-fuji.infura.io/v3/${INFURA_API_KEY}`,
  ethereum: `https://mainnet.infura.io/v3/${INFURA_API_KEY}`,
  sepolia: `https://sepolia.infura.io/v3/${INFURA_API_KEY}`,
  optimism: `https://optimism-mainnet.infura.io/v3/${INFURA_API_KEY}`,
  optimismSepolia: `https://optimism-sepolia.infura.io/v3/${INFURA_API_KEY}`,
  polygon: `https://polygon-mainnet.infura.io/v3/${INFURA_API_KEY}`,
  polygonAmoy: `https://polygon-amoy.infura.io/v3/${INFURA_API_KEY}`
};
var urls = {
  hardhat: [rpcUrl.hardhat],
  localhost: [rpcUrl.localhost],
  ethereum: [
    `https://mainnet.infura.io/v3/${INFURA_API_KEY}`,
    `https://eth-mainnet.blastapi.io/${BLAST_API_KEY}`,
    "https://rpc.ankr.com/eth"
  ],
  sepolia: [
    `https://sepolia.infura.io/v3/${INFURA_API_KEY}`,
    `https://eth-sepolia.blastapi.io/${BLAST_API_KEY}`,
    "https://rpc.ankr.com/eth_sepolia"
  ],
  avalanche: [
    `https://ava-mainnet.blastapi.io/${BLAST_API_KEY}`,
    "https://rpc.ankr.com/avalanche",
    `https://avalanche-mainnet.infura.io/v3/${INFURA_API_KEY}`
  ],
  avalancheFuji: [
    "https://rpc.ankr.com/avalanche_fuji",
    `https://avalanche-fuji.infura.io/v3/${INFURA_API_KEY}`,
    `https://avalanche-fuji.core.chainstack.com/ext/bc/C/rpc/${CHAINSTACK_API_KEY}`,
    `https://ava-testnet.blastapi.io/${BLAST_API_KEY}`
  ],
  arbitrum: [
    `https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`,
    `https://arbitrum-one.blastapi.io/${BLAST_API_KEY}`,
    "https://rpc.ankr.com/arbitrum"
  ],
  arbitrumSepolia: [
    `https://arbitrum-sepolia.infura.io/v3/${INFURA_API_KEY}`,
    `https://arbitrum-sepolia.blastapi.io/${BLAST_API_KEY}`,
    "https://rpc.ankr.com/arbitrum_sepolia"
  ],
  optimism: [
    `https://optimism-mainnet.infura.io/v3/${INFURA_API_KEY}`,
    `https://optimism-mainnet.blastapi.io/${BLAST_API_KEY}`,
    "https://rpc.ankr.com/optimism"
  ],
  optimismSepolia: [
    `https://optimism-sepolia.infura.io/v3/${INFURA_API_KEY}`,
    `https://optimism-sepolia.blastapi.io/${BLAST_API_KEY}`,
    "https://rpc.ankr.com/optimism_sepolia"
  ],
  polygon: [
    `https://polygon.gateway.tenderly.co/${TENDERLY_API_KEY}`,
    `https://polygon-mainnet.blastapi.io/${BLAST_API_KEY}`,
    "https://rpc.ankr.com/polygon",
    "https://polygon-mainnet.infura.io/v3/${INFURA_API_KEY}",
    "https://polygon-bor-rpc.publicnode.com"
  ],
  polygonAmoy: [
    "https://rpc.ankr.com/polygon_amoy",
    `https://polygon-amoy.blastapi.io/${BLAST_API_KEY}`,
    `https://polygon-amoy.infura.io/v3/${INFURA_API_KEY}`
  ],
  base: [
    "https://rpc.ankr.com/base",
    `https://base-rpc.publicnode.com`,
    `https://base-mainnet.blastapi.io/${BLAST_API_KEY}`
  ],
  baseSepolia: [
    `https://base-sepolia.g.alchemy.com/v2/${ALCHEMY_API_KEY}`,
    "https://rpc.ankr.com/base_sepolia",
    `https://base-sepolia.blastapi.io/${BLAST_API_KEY}`
  ],
  bsc: ["https://rpc.ankr.com/bsc"],
  scroll: ["https://rpc.ankr.com/scroll"],
  scrollSepolia: ["https://rpc.ankr.com/scroll_sepolia"],
  polygonZkEvm: [`https://polygon-zkevm-mainnet.blastapi.io/${BLAST_API_KEY}`],
  polygonZkEvmCardona: [`https://polygon-zkevm-cardona.blastapi.io/${BLAST_API_KEY}`]
};

// ../../../constants/conceroNetworks.ts
var DEFAULT_BLOCK_CONFIRMATIONS = 2;
var mainnetProxyDeployerPK = getWallet("mainnet", "proxyDeployer", "privateKey");
var testnetProxyDeployerPK = getWallet("testnet", "proxyDeployer", "privateKey");
var localhostProxyDeployerPK = getWallet("localhost", "proxyDeployer", "privateKey");
var mainnetDeployerPK = getWallet("mainnet", "deployer", "privateKey");
var testnetDeployerPK = getWallet("testnet", "deployer", "privateKey");
var localhostDeployerPK = getWallet("localhost", "deployer", "privateKey");
var networkTypes = {
  mainnet: "mainnet",
  testnet: "testnet",
  localhost: "localhost"
};
var testingNetworks = {
  hardhat: {
    name: "hardhat",
    chainId: Number(process.env.LOCALHOST_FORK_CHAIN_ID),
    type: networkTypes.localhost,
    saveDeployments: false,
    accounts: [
      {
        privateKey: localhostProxyDeployerPK,
        balance: "10000000000000000000000"
      },
      {
        privateKey: localhostDeployerPK,
        balance: "10000000000000000000000"
      },
      {
        privateKey: getEnvVar("TESTNET_OPERATOR_PRIVATE_KEY"),
        balance: "10000000000000000000000"
      },
      {
        privateKey: getEnvVar("TESTNET_USER_PRIVATE_KEY"),
        balance: "10000000000000000000000"
      }
    ],
    chainSelector: process.env.CL_CCIP_CHAIN_SELECTOR_LOCALHOST,
    confirmations: 1,
    viemChain: hardhatViemChain,
    forking: {
      url: `https://base-mainnet.infura.io/v3/${process.env.INFURA_API_KEY}`,
      enabled: false,
      blockNumber: Number(process.env.LOCALHOST_FORK_LATEST_BLOCK_NUMBER)
    },
    saveDeployments: false
  },
  localhost: {
    name: "localhost",
    type: networkTypes.localhost,
    chainId: 1,
    viemChain: localhostViemChain,
    url: rpcUrl.localhost,
    rpcUrls: [rpcUrl.localhost],
    confirmations: 1,
    chainSelector: process.env.CL_CCIP_CHAIN_SELECTOR_LOCALHOST,
    accounts: [
      localhostDeployerPK,
      localhostProxyDeployerPK,
      getEnvVar("TESTNET_OPERATOR_PRIVATE_KEY")
    ],
    saveDeployments: true
  }
};
var testnetNetworks = {
  sepolia: {
    name: "sepolia",
    type: networkTypes.testnet,
    chainId: 11155111,
    url: urls.sepolia[0],
    rpcUrls: urls.sepolia,
    accounts: [testnetDeployerPK, testnetProxyDeployerPK],
    chainSelector: "16015286601757825753",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: sepolia
  },
  avalancheFuji: {
    name: "avalancheFuji",
    type: networkTypes.testnet,
    chainId: 43113,
    url: urls.avalancheFuji[0],
    rpcUrls: urls.avalancheFuji,
    accounts: [testnetDeployerPK, testnetProxyDeployerPK],
    chainSelector: "14767482510784806043",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: avalancheFuji
  },
  optimismSepolia: {
    name: "optimismSepolia",
    type: networkTypes.testnet,
    chainId: 11155420,
    url: urls.optimismSepolia[0],
    rpcUrls: urls.optimismSepolia,
    accounts: [testnetDeployerPK, testnetProxyDeployerPK],
    chainSelector: "5224473277236331295",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: optimismSepolia
  },
  arbitrumSepolia: {
    name: "arbitrumSepolia",
    type: networkTypes.testnet,
    chainId: 421614,
    url: urls.arbitrumSepolia[0],
    rpcUrls: urls.arbitrumSepolia,
    accounts: [testnetDeployerPK, testnetProxyDeployerPK],
    chainSelector: "3478487238524512106",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: arbitrumSepolia
  },
  baseSepolia: {
    name: "baseSepolia",
    type: networkTypes.testnet,
    chainId: 84532,
    url: urls.baseSepolia[0],
    rpcUrls: urls.baseSepolia,
    accounts: [testnetDeployerPK, testnetProxyDeployerPK],
    chainSelector: "10344971235874465080",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: baseSepolia,
    saveDeployments: false
  },
  polygonAmoy: {
    name: "polygonAmoy",
    type: networkTypes.testnet,
    chainId: 80002,
    url: urls.polygonAmoy[0],
    rpcUrls: urls.polygonAmoy,
    accounts: [testnetDeployerPK, testnetProxyDeployerPK],
    chainSelector: "16281711391670634445",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: polygonAmoy
  }
};
var mainnetNetworks = {
  ethereum: {
    name: "ethereum",
    type: networkTypes.mainnet,
    chainId: 1,
    url: urls.ethereum[0],
    rpcUrls: urls.ethereum,
    accounts: [mainnetDeployerPK, mainnetProxyDeployerPK],
    chainSelector: "1",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: mainnet
  },
  base: {
    name: "base",
    type: networkTypes.mainnet,
    chainId: 8453,
    url: urls.base[0],
    rpcUrls: urls.base,
    accounts: [mainnetDeployerPK, mainnetProxyDeployerPK],
    chainSelector: "15971525489660198786",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: base
  },
  arbitrum: {
    name: "arbitrum",
    type: networkTypes.mainnet,
    chainId: 42161,
    url: urls.arbitrum[0],
    rpcUrls: urls.arbitrum,
    accounts: [mainnetDeployerPK, mainnetProxyDeployerPK],
    chainSelector: "4949039107694359620",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: arbitrum
  },
  polygon: {
    name: "polygon",
    type: networkTypes.mainnet,
    chainId: 137,
    url: urls.polygon[0],
    rpcUrls: urls.polygon,
    accounts: [mainnetDeployerPK, mainnetProxyDeployerPK],
    chainSelector: "4051577828743386545",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: polygon
  },
  avalanche: {
    name: "avalanche",
    type: networkTypes.mainnet,
    chainId: 43114,
    url: urls.avalanche[0],
    rpcUrls: urls.avalanche,
    accounts: [mainnetDeployerPK, mainnetProxyDeployerPK],
    chainSelector: "6433500567565415381",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: avalanche
  },
  optimism: {
    name: "optimism",
    type: networkTypes.mainnet,
    chainId: 10,
    url: urls.optimism[0],
    rpcUrls: urls.optimism,
    accounts: [mainnetDeployerPK, mainnetProxyDeployerPK],
    chainSelector: "10",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: optimism
  },
  polygonZkEvm: {
    chainId: 137,
    name: "polygonZkEvm",
    type: networkTypes.mainnet,
    url: urls.polygonZkEvm[0],
    rpcUrls: urls.polygonZkEvm,
    accounts: [mainnetDeployerPK, mainnetProxyDeployerPK],
    chainSelector: "137",
    confirmations: DEFAULT_BLOCK_CONFIRMATIONS,
    viemChain: polygon
  }
};
var conceroNetworks = {
  ...testnetNetworks,
  ...mainnetNetworks,
  ...testingNetworks
};

// ../../../constants/targetBalances.ts
var messengerTargetBalances = {
  ethereum: parseEther("0.01"),
  arbitrum: parseEther("0.01"),
  polygon: parseEther("0.1"),
  avalanche: parseEther("0.01"),
  base: parseEther("0.01")
};
var deployerTargetBalances = {
  ethereum: parseEther("0.01"),
  arbitrum: parseEther("0.01"),
  polygon: parseEther("1"),
  avalanche: parseEther("0.3"),
  base: parseEther("0.01"),
  sepolia: parseEther("0.1"),
  arbitrumSepolia: parseEther("0.01"),
  polygonAmoy: parseEther("0.01"),
  avalancheFuji: parseEther("0.3"),
  baseSepolia: parseEther("0.01")
};

// constants/conceroRouters.ts
function getConceroVerifier() {
  try {
    if (config.isDevelopment)
      return secrets3.CONCERO_VERIFIER_LOCALHOST;
    return "0xa45F4A08eCE764a74cE20306d704e7CbD755D8a4";
  } catch {
    return "0xa45F4A08eCE764a74cE20306d704e7CbD755D8a4";
  }
}
var CONCERO_VERIFIER_CONTRACT_ADDRESS = getConceroVerifier();
var conceroRouters = {
  "1": CONCERO_ROUTER_ETHEREUM,
  "10": CONCERO_ROUTER_OPTIMISM
};

// constants/config.ts
var CONFIG = {
  REPORT_VERSION: 1,
  VIEM: {
    RETRY_COUNT: 5,
    RETRY_DELAY: 2000
  }
};

// constants/abis.ts
var ClientMessageRequestBase = "bytes32 internalMessageConfig, bytes dstChainData, bytes message";
var ClientMessageRequest = `tuple(${ClientMessageRequestBase})`;
var CONCERO_VERIFIER_CONTRACT_ABI = parseAbi([
  "function getCohortsCount() external returns (uint8)",
  "function getRegisteredOperators(uint8 chainType) external view returns (bytes[] memory)"
]);
var NonIndexedConceroMessageParams = [
  { type: "bytes", name: "dstChainData" },
  { type: "bytes", name: "message" }
];

// utils/decoders.ts
function decodeConceroMessageLog(log2) {
  try {
    const messageId = log2.topics[1];
    const internalMessageConfig = log2.topics[2];
    const [dstChainData, message] = decodeAbiParameters(NonIndexedConceroMessageParams, log2.data);
    return {
      messageId,
      internalMessageConfig,
      dstChainData,
      message
    };
  } catch (error) {
    handleError(33 /* INVALID_DATA */);
  }
}

// utils/fetchConceroMessage.ts
async function fetchConceroMessage(client, routerAddress, messageId, blockNumber) {
  const logs = await client.getLogs({
    address: routerAddress,
    topics: [null, null, messageId],
    fromBlock: blockNumber - 10n,
    toBlock: blockNumber
  });
  if (!logs.length)
    handleError(30 /* EVENT_NOT_FOUND */);
  return logs[0];
}

// utils/utils.ts
function getOperatorCohortId(operator, cohortsCount) {
  return parseInt(operator.slice(2), 16) % cohortsCount;
}
function getMessageCohortId(messageId, cohortsCount) {
  return parseInt(messageId.slice(2), 16) % cohortsCount;
}
function pick(array, n) {
  if (n > array.length) {
    handleError(51 /* INVALID_OPERATOR_COUNT */);
  }
  const shuffled = [...array];
  for (let i = shuffled.length - 1;i > 0; i--) {
    const j5 = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j5]] = [shuffled[j5], shuffled[i]];
  }
  return shuffled.slice(0, n);
}

// utils/getAllowedOperators.ts
async function getAllowedOperators(client, chainType, messageId) {
  try {
    const cohortsCount = await getCohortsCount(client);
    const messageCohort = getMessageCohortId(messageId, cohortsCount);
    const registeredOperators = await getRegisteredOperators(client, chainType);
    const allowedOperators = registeredOperators.filter((operator) => getOperatorCohortId(operator, cohortsCount) === messageCohort);
    if (!allowedOperators.length) {
      handleError(53 /* NO_ALLOWED_OPERATORS */);
    }
    return allowedOperators;
  } catch (error) {
    console.log(error);
    handleError(54 /* OPERATOR_SELECTION_FAILED */);
  }
}
async function getCohortsCount(client) {
  const cohortsCount = await client.readContract({
    abi: CONCERO_VERIFIER_CONTRACT_ABI,
    address: CONCERO_VERIFIER_CONTRACT_ADDRESS,
    functionName: "getCohortsCount",
    args: []
  });
  if (cohortsCount <= 0) {
    handleError(55 /* INVALID_COHORTS_COUNT */);
  }
  return cohortsCount;
}
async function getRegisteredOperators(client, chainType) {
  if (config.isDevelopment) {
    return [zeroAddress];
  }
  const registeredOperators = await client.readContract({
    abi: CONCERO_VERIFIER_CONTRACT_ABI,
    address: CONCERO_VERIFIER_CONTRACT_ADDRESS,
    functionName: "getRegisteredOperators",
    args: [chainType]
  });
  if (!registeredOperators.length) {
    handleError(52 /* NO_REGISTERED_OPERATORS */);
  }
  return registeredOperators;
}

// ../common/encoders.ts
function hexStringToUint8Array(hex) {
  hex = hex.replace(/^0x/, "");
  const length = hex.length / 2;
  const res = new Uint8Array(length);
  for (let i = 0;i < res.length; i++) {
    res[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  }
  return res;
}

// utils/packResult.ts
function packResult(result, packedReportConfig) {
  const encoded = encodeAbiParameters([
    { type: "bytes32" },
    { type: "bytes32" },
    { type: "bytes32" },
    { type: "bytes32" },
    { type: "bytes" },
    { type: "bytes[]" }
  ], [
    packedReportConfig,
    result.internalMessageConfig,
    result.messageId,
    result.messageHashSum,
    result.dstChainData,
    result.allowedOperators
  ]);
  return hexStringToUint8Array(encoded);
}

// ../common/bitMasks.ts
var MASKS = {
  UINT24: 0xffffffn,
  UINT16: 0xffffn,
  UINT8: 0xffn,
  BOOL: 0x1n,
  UPPER_BYTE: 65280,
  LOWER_BYTE: 255,
  UPPER_BYTE_SHIFT: 8
};

// constants/internalMessageConfig.ts
var INTERNAL_MESSAGE_CONFIG_OFFSETS = {
  VERSION: 224,
  SRC_CHAIN: 224,
  DST_CHAIN: 168,
  MIN_SRC_CONF: 152,
  MIN_DST_CONF: 136,
  RELAYER: 128,
  CALLBACKABLE: 127
};

// utils/messageConfig.ts
function decodeInternalMessageConfig(config4) {
  const bigIntConfig = BigInt(config4);
  return {
    version: bigIntConfig >> BigInt(INTERNAL_MESSAGE_CONFIG_OFFSETS.VERSION) & MASKS.UINT8,
    srcChainSelector: bigIntConfig >> BigInt(INTERNAL_MESSAGE_CONFIG_OFFSETS.SRC_CHAIN) & MASKS.UINT24,
    dstChainSelector: bigIntConfig >> BigInt(INTERNAL_MESSAGE_CONFIG_OFFSETS.DST_CHAIN) & MASKS.UINT24,
    minSrcConfirmations: bigIntConfig >> BigInt(INTERNAL_MESSAGE_CONFIG_OFFSETS.MIN_SRC_CONF) & MASKS.UINT16,
    minDstConfirmations: bigIntConfig >> BigInt(INTERNAL_MESSAGE_CONFIG_OFFSETS.MIN_DST_CONF) & MASKS.UINT16,
    relayerConfig: bigIntConfig >> BigInt(INTERNAL_MESSAGE_CONFIG_OFFSETS.RELAYER) & MASKS.UINT8,
    isCallbackable: Boolean(bigIntConfig >> BigInt(INTERNAL_MESSAGE_CONFIG_OFFSETS.CALLBACKABLE) & MASKS.BOOL)
  };
}
function validateInternalMessageConfig(config4) {
  if (config4.version === 0n)
    handleError(10 /* CONFIG_INVALID_VERSION */);
  if (config4.relayerConfig > 255n)
    handleError(11 /* CONFIG_INVALID_RELAYER_CONFIG */);
  if (config4.minSrcConfirmations === 0n)
    handleError(12 /* CONFIG_INVALID_MIN_SRC_CONFIRMATIONS */);
  if (config4.minDstConfirmations === 0n)
    handleError(13 /* CONFIG_INVALID_MIN_DST_CONFIRMATIONS */);
  if (!viemChains[config4.srcChainSelector.toString()])
    handleError(14 /* CONFIG_INVALID_SRC_CHAIN_SELECTOR */);
  if (!viemChains[config4.dstChainSelector.toString()])
    handleError(15 /* CONFIG_INVALID_DST_CHAIN_SELECTOR */);
  if (config4.srcChainSelector === config4.dstChainSelector)
    handleError(17 /* CONFIG_SAME_CHAINS */);
}

// utils/validateInputs.ts
function decodeSrcChainData(srcChainSelector, srcChainData) {
  const srcChainDataBytes = hexToBytes(srcChainData);
  return decodeAbiParameters([
    {
      type: "tuple",
      components: [
        { name: "sender", type: "address" },
        { name: "blockNumber", type: "uint256" }
      ]
    }
  ], srcChainDataBytes)[0];
}
function decodeInputs(bytesArgs2) {
  if (bytesArgs2.length < 6) {
    handleError(1 /* INVALID_BYTES_ARGS_LENGTH */);
  }
  const [, internalMessageConfig, messageId, messageHashSum, srcChainData, operatorAddress] = bytesArgs2;
  const decodedInternalMessageConfig = decodeInternalMessageConfig(internalMessageConfig);
  validateInternalMessageConfig(decodedInternalMessageConfig);
  const decodedArgs = {
    internalMessageConfig: decodedInternalMessageConfig,
    messageId,
    messageHashSum,
    srcChainData: decodeSrcChainData(decodedInternalMessageConfig.srcChainSelector, srcChainData),
    operatorAddress
  };
  validateDecodedArgs(decodedArgs);
  return decodedArgs;
}
function validateDecodedArgs(args) {
  validateOperatorAddress(args.operatorAddress);
  validateMessageFields(args);
}
function validateOperatorAddress(address) {
  if (!isAddress(address)) {
    handleError(56 /* INVALID_OPERATOR_ADDRESS */);
  }
}
function validateMessageFields(args) {
  const { internalMessageConfig, messageId, messageHashSum, srcChainData } = args;
  if (!internalMessageConfig || internalMessageConfig.length === 0) {
    handleError(16 /* INVALID_MESSAGE_CONFIG */);
  }
  if (!messageId || messageId.length === 0) {
    handleError(32 /* INVALID_MESSAGE_ID */);
  }
  if (!messageHashSum || messageHashSum.length === 0) {
    handleError(36 /* INVALID_HASH_SUM */);
  }
  if (!srcChainData || srcChainData.length === 0) {
    handleError(37 /* INVALID_CHAIN_DATA */);
  }
}

// utils/verifyMessageHash.ts
function verifyMessageHash(message, expectedHashSum) {
  if (keccak256(message).toLowerCase() !== expectedHashSum.toLowerCase()) {
    handleError(31 /* INVALID_HASHSUM */);
  }
}

// index.ts
(async function main() {
  try {
    const args = decodeInputs(bytesArgs);
    const msgConfig = args.internalMessageConfig;
    const publicClient = getPublicClient(msgConfig.srcChainSelector.toString());
    const log2 = await fetchConceroMessage(publicClient, conceroRouters[Number(msgConfig.srcChainSelector)], args.messageId, BigInt(args.srcChainData.blockNumber));
    const {
      messageId: messageIdFromLog,
      internalMessageConfig: messageConfigFromLog,
      dstChainData: dstChainDataFromLog,
      message: messageFromLog
    } = decodeConceroMessageLog(log2);
    verifyMessageHash(messageFromLog, args.messageHashSum);
    const operators = await getAllowedOperators(publicClient, 0 /* EVM */, args.messageId);
    const allowedOperators = pick(operators, 1);
    const messageReportResult = {
      version: CONFIG.REPORT_VERSION,
      reportType: 1 /* MESSAGE */,
      requester: args.operatorAddress,
      internalMessageConfig: messageConfigFromLog.toString(),
      messageId: args.messageId,
      messageHashSum: args.messageHashSum,
      dstChainData: dstChainDataFromLog,
      allowedOperators
    };
    const packedReportConfig = packReportConfig(1 /* MESSAGE */, CONFIG.REPORT_VERSION, args.operatorAddress);
    return packResult(messageReportResult, packedReportConfig);
  } catch (error) {
    console.log(error);
    if (error instanceof CustomErrorHandler) {
      throw error;
    } else {
      handleError(0 /* UNKNOWN_ERROR */);
    }
  }
})();
