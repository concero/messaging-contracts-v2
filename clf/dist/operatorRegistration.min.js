// clf/src/messageReport/constants/errorTypes.ts
var ErrorType;
((ErrorType2) => {
  ErrorType2[ErrorType2["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  ErrorType2[ErrorType2["CONFIG_INVALID_VERSION"] = 10] = "CONFIG_INVALID_VERSION";
  ErrorType2[ErrorType2["CONFIG_INVALID_RELAYER_CONFIG"] = 11] = "CONFIG_INVALID_RELAYER_CONFIG";
  ErrorType2[ErrorType2["CONFIG_INVALID_MIN_SRC_CONFIRMATIONS"] = 12] = "CONFIG_INVALID_MIN_SRC_CONFIRMATIONS";
  ErrorType2[ErrorType2["CONFIG_INVALID_MIN_DST_CONFIRMATIONS"] = 13] = "CONFIG_INVALID_MIN_DST_CONFIRMATIONS";
  ErrorType2[ErrorType2["CONFIG_INVALID_SRC_CHAIN_SELECTOR"] = 14] = "CONFIG_INVALID_SRC_CHAIN_SELECTOR";
  ErrorType2[ErrorType2["CONFIG_INVALID_DST_CHAIN_SELECTOR"] = 15] = "CONFIG_INVALID_DST_CHAIN_SELECTOR";
  ErrorType2[ErrorType2["NO_CHAIN_DATA"] = 20] = "NO_CHAIN_DATA";
  ErrorType2[ErrorType2["NO_RPC_DATA"] = 21] = "NO_RPC_DATA";
  ErrorType2[ErrorType2["NO_RPC_PROVIDERS"] = 22] = "NO_RPC_PROVIDERS";
  ErrorType2[ErrorType2["INVALID_SOURCE_CHAIN"] = 23] = "INVALID_SOURCE_CHAIN";
  ErrorType2[ErrorType2["INVALID_DESTINATION_CHAIN"] = 24] = "INVALID_DESTINATION_CHAIN";
  ErrorType2[ErrorType2["INVALID_CHAIN"] = 25] = "INVALID_CHAIN";
  ErrorType2[ErrorType2["INVALID_RPC"] = 26] = "INVALID_RPC";
  ErrorType2[ErrorType2["EVENT_NOT_FOUND"] = 30] = "EVENT_NOT_FOUND";
  ErrorType2[ErrorType2["INVALID_HASHSUM"] = 31] = "INVALID_HASHSUM";
  ErrorType2[ErrorType2["INVALID_MESSAGE_ID"] = 32] = "INVALID_MESSAGE_ID";
  ErrorType2[ErrorType2["INVALID_DATA"] = 33] = "INVALID_DATA";
  ErrorType2[ErrorType2["INVALID_EXTRA_ARGS"] = 34] = "INVALID_EXTRA_ARGS";
  ErrorType2[ErrorType2["INVALID_INPUT"] = 35] = "INVALID_INPUT";
  ErrorType2[ErrorType2["INVALID_TOKEN_TYPE"] = 40] = "INVALID_TOKEN_TYPE";
  ErrorType2[ErrorType2["INVALID_TOKEN_AMOUNT"] = 41] = "INVALID_TOKEN_AMOUNT";
  ErrorType2[ErrorType2["INVALID_RELAYER"] = 50] = "INVALID_RELAYER";
  ErrorType2[ErrorType2["INVALID_OPERATOR_COUNT"] = 51] = "INVALID_OPERATOR_COUNT";
  ErrorType2[ErrorType2["NO_REGISTERED_OPERATORS"] = 52] = "NO_REGISTERED_OPERATORS";
  ErrorType2[ErrorType2["NO_ALLOWED_OPERATORS"] = 53] = "NO_ALLOWED_OPERATORS";
  ErrorType2[ErrorType2["OPERATOR_SELECTION_FAILED"] = 54] = "OPERATOR_SELECTION_FAILED";
  ErrorType2[ErrorType2["INVALID_COHORTS_COUNT"] = 55] = "INVALID_COHORTS_COUNT";
  ErrorType2[ErrorType2["INVALID_RECEIVER"] = 60] = "INVALID_RECEIVER";
  ErrorType2[ErrorType2["INVALID_SENDER"] = 61] = "INVALID_SENDER";
})(ErrorType ||= {});

// clf/src/common/errorHandler.ts
class CustomErrorHandler extends Error {
  type;
  data;
  constructor(type, data = null) {
    super(ErrorType[type]);
    this.type = type;
    this.data = data;
  }
}
function handleError(type) {
  throw new CustomErrorHandler(type);
}

// clf/src/operatorRegistration/utils/validateInputs.ts
function validateInputs(bytesArgs) {
  if (bytesArgs.length < 4)
    handleError(40 /* INVALID_INPUT */);
  const [_unusedHash, chainTypes, operatorAddresses, operatorAddress] = bytesArgs;
  return {
    chainTypes: JSON.parse(chainTypes),
    operatorAddresses: JSON.parse(operatorAddresses),
    operatorAddress
  };
}

// clf/src/operatorRegistration/utils/verifyOperatorStake.ts
async function verifyOperatorStake(operatorAddress) {
  const stakeAmount = Math.random() > 0.5 ? 100 : 0;
  if (stakeAmount <= 0) {
    handleError(30 /* INVALID_OPERATOR_STAKE */);
  }
  return stakeAmount;
}

// clf/src/operatorRegistration/constants/bitOffsets.ts
var OPERATOR_REGISTRATION_RESULT_SIZES = {
  VERSION: 1,
  REPORT_TYPE: 1,
  OPERATOR: 32,
  CHAIN_TYPES_LENGTH: 4,
  OPERATOR_ADDRESSES_LENGTH: 4
};
var OPERATOR_REGISTRATION_RESULT_OFFSETS = {
  VERSION: 0,
  REPORT_TYPE: 1,
  OPERATOR: 2,
  CHAIN_TYPES_LENGTH: 34,
  CHAIN_TYPES: 38
};

// clf/src/operatorRegistration/utils/packResult.ts
function packResult(registrationReportResult) {
  const chainTypesBytes = new Uint8Array(Buffer.from(JSON.stringify(registrationReportResult.chainTypes)));
  const operatorAddressesBytes = new Uint8Array(Buffer.from(JSON.stringify(registrationReportResult.operatorAddresses)));
  const resLength = OPERATOR_REGISTRATION_RESULT_OFFSETS.CHAIN_TYPES + chainTypesBytes.length + operatorAddressesBytes.length;
  const res = new Uint8Array(resLength);
  let offset = 0;
  res[OPERATOR_REGISTRATION_RESULT_OFFSETS.VERSION] = registrationReportResult.version;
  res[OPERATOR_REGISTRATION_RESULT_OFFSETS.REPORT_TYPE] = registrationReportResult.reportType;
  offset += 2;
  res.set(new Uint8Array(Buffer.from(registrationReportResult.operator.replace(/^0x/, ""), "hex")), OPERATOR_REGISTRATION_RESULT_OFFSETS.OPERATOR);
  offset += OPERATOR_REGISTRATION_RESULT_SIZES.OPERATOR;
  res.set(new Uint8Array(new Uint32Array([chainTypesBytes.length]).buffer), OPERATOR_REGISTRATION_RESULT_OFFSETS.CHAIN_TYPES_LENGTH);
  offset = OPERATOR_REGISTRATION_RESULT_OFFSETS.CHAIN_TYPES;
  res.set(chainTypesBytes, offset);
  offset += chainTypesBytes.length;
  res.set(new Uint8Array(new Uint32Array([operatorAddressesBytes.length]).buffer), offset);
  offset += OPERATOR_REGISTRATION_RESULT_SIZES.CHAIN_TYPES_LENGTH;
  res.set(operatorAddressesBytes, offset);
  return res;
}

// clf/src/operatorRegistration/constants/config.ts
var CONFIG = {
  REPORT_VERSION: 1
};

// clf/src/operatorRegistration/index.ts
async function main(bytesArgs) {
  try {
    const args = validateInputs(bytesArgs);
    if (args.chainTypes.includes(0 /* EVM */) && args.operatorAddresses[0] !== args.operatorAddress) {
      handleError(21 /* INVALID_OPERATOR_ADDRESS */);
    }
    await verifyOperatorStake(args.operatorAddress);
    const registrationReportResult = {
      version: CONFIG.REPORT_VERSION,
      reportType: 2 /* OPERATOR_REGISTRATION */,
      operator: args.operatorAddress,
      chainTypes: args.chainTypes,
      operatorAddresses: args.operatorAddresses
    };
    return packResult(registrationReportResult);
  } catch (error) {
    if (error instanceof CustomErrorHandler) {
      throw error;
    } else {
      handleError(0 /* UNKNOWN_ERROR */);
    }
  }
}
export {
  main
};
